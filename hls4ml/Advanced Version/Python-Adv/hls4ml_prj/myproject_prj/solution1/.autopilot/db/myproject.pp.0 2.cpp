# 1 "firmware/myproject.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 381 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/autopilot_ssdm_op.h" 1
# 105 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/autopilot_ssdm_op.h"
extern "C" {






    void _ssdm_op_IfRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_StreamRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_ReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Read(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_WriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Write(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_PrintNone(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_PrintInt(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_PrintDouble(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Wait(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Return(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecInterface(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_RegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_InlineAll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_Inline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecStream(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecStable(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecStableContent(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBindPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipoDepth(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecExpr(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecDependence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_DataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBitsMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecLicense(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void __xilinx_ip_top(...) __attribute__ ((nothrow)) __attribute__((overloadable));


}
# 2 "<built-in>" 2
# 1 "firmware/myproject.cpp" 2
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iostream" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iostream" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 1 3
# 236 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 258 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 508 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/os_defines.h" 1 3
# 509 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 2 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/cpu_defines.h" 1 3
# 512 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 2 3
# 39 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iostream" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ios" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ios" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iosfwd" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iosfwd" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stringfwd.h" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stringfwd.h" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/memoryfwd.h" 1 3
# 47 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/memoryfwd.h" 3



namespace std
{
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stringfwd.h" 2 3

namespace std
{
# 52 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stringfwd.h" 3
  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iosfwd" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/postypes.h" 1 3
# 39 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/postypes.h" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 3




# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 1 3








# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 1 3
# 10 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 1 3
# 12 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/_mingw_mac.h" 1 3
# 13 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/_mingw_secapi.h" 1 3
# 44 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/_mingw_secapi.h" 3
extern "C++" {
template <bool __test, typename __dsttype>
  struct __if_array;
template <typename __dsttype>
  struct __if_array <true, __dsttype> {
    typedef __dsttype __type;
};
}
# 14 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 282 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
# 1 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 1 3
# 26 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\vadefs.h" 1 3








# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 1 3
# 595 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/sdks/_mingw_directx.h" 1 3
# 596 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/sdks/_mingw_ddk.h" 1 3
# 597 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 10 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\vadefs.h" 2 3




#pragma pack(push,_CRT_PACKING)



extern "C" {





  typedef __builtin_va_list __gnuc_va_list;






  typedef __gnuc_va_list va_list;
# 99 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\vadefs.h" 3
}



#pragma pack(pop)
# 27 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 2 3
# 283 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 558 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
extern "C" {
# 569 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
void __attribute__((__cdecl__)) __debugbreak(void);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __debugbreak(void)
{
  __asm__ __volatile__("int {$}3":);
}




const char *__mingw_get_crt_info (void);


}
# 11 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 2 3




#pragma pack(push,_CRT_PACKING)
# 35 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef unsigned long size_t;
# 45 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef long ssize_t;






typedef size_t rsize_t;
# 62 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef long intptr_t;
# 75 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef unsigned long uintptr_t;
# 88 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef long ptrdiff_t;
# 106 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
typedef unsigned short wint_t;
typedef unsigned short wctype_t;





typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long __time64_t;
# 138 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
typedef __time64_t time_t;
# 422 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {
  int refcount;
  unsigned int lc_codepage;
  unsigned int lc_collate_cp;
  unsigned long lc_handle[6];
  LC_ID lc_id[6];
  struct {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
  } lc_category[6];
  int lc_clike;
  int mb_cur_max;
  int *lconv_intl_refcount;
  int *lconv_num_refcount;
  int *lconv_mon_refcount;
  struct lconv *lconv;
  int *ctype1_refcount;
  unsigned short *ctype1;
  const unsigned short *pctype;
  const unsigned char *pclmap;
  const unsigned char *pcumap;
  struct __lc_time_data *lc_time_curr;
} threadlocinfo;







#pragma pack(pop)
# 10 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw_print_push.h" 1 3
# 11 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 2 3
# 25 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
  };
  typedef struct _iobuf FILE;



__attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __acrt_iob_func(unsigned index);


  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __iob_func(void);
# 81 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  typedef unsigned long _fsize_t;




  struct _wfinddata32_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata32i64_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    __extension__ long size;
    wchar_t name[260];
  };

  struct _wfinddata64i32_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata64_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    __extension__ long size;
    wchar_t name[260];
  };
# 186 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  extern unsigned short ** __imp__pctype;
# 201 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  extern unsigned short ** __imp__wctype;
# 216 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  extern unsigned short ** __imp__pwctype;
# 262 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  int __attribute__((__cdecl__)) iswalpha(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalpha_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswupper(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswupper_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswlower(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswxdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswxdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswspace(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswspace_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswpunct(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswpunct_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswalnum(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalnum_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswprint(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswprint_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswgraph(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswgraph_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswcntrl(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcntrl_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswascii(wint_t _C);
  int __attribute__((__cdecl__)) isleadbyte(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isleadbyte_l(int _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towupper(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towupper_l(wint_t _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towlower(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswctype(wint_t _C,wctype_t _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswctype_l(wint_t _C,wctype_t _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsymf(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsymf_l(wint_t _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsym(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsym_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) is_wctype(wint_t _C,wctype_t _Type);


  int __attribute__((__cdecl__)) iswblank(wint_t _C);







  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetcwd(wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetdcwd(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  wchar_t *__attribute__((__cdecl__)) _wgetdcwd_nolock(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wmkdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrmdir(const wchar_t *_Path);





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _waccess(const wchar_t *_Filename,int _AccessMode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchmod(const wchar_t *_Filename,int _Mode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcreat(const wchar_t *_Filename,int _PermissionMode) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32(const wchar_t *_Filename,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32(intptr_t _FindHandle,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wunlink(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrename(const wchar_t *_OldFilename,const wchar_t *_NewFilename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wmktemp(wchar_t *_TemplateName) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32i64(const wchar_t *_Filename,struct _wfinddata32i64_t *_FindData);
  intptr_t __attribute__((__cdecl__)) _wfindfirst64i32(const wchar_t *_Filename,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst64(const wchar_t *_Filename,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32i64(intptr_t _FindHandle,struct _wfinddata32i64_t *_FindData);
  int __attribute__((__cdecl__)) _wfindnext64i32(intptr_t _FindHandle,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext64(intptr_t _FindHandle,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsopen_s(int *_FileHandle,const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionFlag);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wopen(const wchar_t *_Filename,int _OpenFlag,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsopen(const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,...) ;




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wsetlocale(int _Category,const wchar_t *_Locale);




  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecl(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecle(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclp(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclpe(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecv(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecve(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvp(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvpe(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);




  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnl(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnle(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlp(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlpe(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnv(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnve(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvp(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvpe(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);
# 409 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  typedef unsigned short _ino_t;

  typedef unsigned short ino_t;





  typedef unsigned int _dev_t;

  typedef unsigned int dev_t;




# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw_off_t.h" 1 3




  typedef long _off_t;

  typedef long off32_t;





  __extension__ typedef long long _off64_t;

  __extension__ typedef long long off64_t;
# 26 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw_off_t.h" 3
typedef off32_t off_t;
# 424 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw_stat64.h" 1 3
# 25 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw_stat64.h" 3
  struct _stat32 {
    _dev_t st_dev;
   _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };


  struct stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
  };


  struct _stat32i64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };

  struct _stat64i32 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };

  struct _stat64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };
# 425 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 2 3




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32(const wchar_t *_Name,struct _stat32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32i64(const wchar_t *_Name,struct _stat32i64 *_Stat);
  int __attribute__((__cdecl__)) _wstat64i32(const wchar_t *_Name,struct _stat64i32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat64(const wchar_t *_Name,struct _stat64 *_Stat);
# 443 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *_cgetws(wchar_t *_Buffer) ;
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwch(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwche(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _putwch(wchar_t _WCh);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwch(wint_t _WCh);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cputws(const wchar_t *_String);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  wint_t __attribute__((__cdecl__)) _putwch_nolock(wchar_t _WCh);
  wint_t __attribute__((__cdecl__)) _getwch_nolock(void);
  wint_t __attribute__((__cdecl__)) _getwche_nolock(void);
  wint_t __attribute__((__cdecl__)) _ungetwch_nolock(wint_t _WCh);





                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswscanf (const wchar_t * __restrict__ _Str,const wchar_t * __restrict__ Format,va_list argp);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wscanf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwscanf(const wchar_t * __restrict__ Format, va_list argp);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwscanf (FILE * __restrict__ fp, const wchar_t * __restrict__ Format,va_list argp);


                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wprintf(const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ , ...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ ,va_list);
# 525 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int swscanf(const wchar_t *__source, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vswscanf( __source, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (1)))
int wscanf(const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwscanf( (__acrt_iob_func(0)), __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int fwscanf(FILE *__stream, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwscanf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}


static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int vswscanf (const wchar_t *__source, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vswscanf( __source, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (1)))
int vwscanf(const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwscanf( (__acrt_iob_func(0)), __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int vfwscanf (FILE *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwscanf( __stream, __format, __local_argv );
}




static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int fwprintf (FILE *__stream, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (1)))
int wprintf (const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwprintf( (__acrt_iob_func(1)), __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int vfwprintf (FILE *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwprintf( __stream, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (1)))
int vwprintf (const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwprintf( (__acrt_iob_func(1)), __format, __local_argv );
}


static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int snwprintf (wchar_t *__stream, size_t __n, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsnwprintf( __stream, __n, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vsnwprintf (wchar_t *__stream, size_t __n, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsnwprintf( __stream, __n, __format, __local_argv );
}
# 768 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfsopen(const wchar_t *_Filename,const wchar_t *_Mode,int _ShFlag);


  wint_t __attribute__((__cdecl__)) fgetwc(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwchar(void);
  wint_t __attribute__((__cdecl__)) fputwc(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) getwc(FILE *_File);
  wint_t __attribute__((__cdecl__)) getwchar(void);
  wint_t __attribute__((__cdecl__)) putwc(wchar_t _Ch,FILE *_File);
  wint_t __attribute__((__cdecl__)) putwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) ungetwc(wint_t _Ch,FILE *_File);
  wchar_t *__attribute__((__cdecl__)) fgetws(wchar_t * __restrict__ _Dst,int _SizeInWords,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) fputws(const wchar_t * __restrict__ _Str,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putws(const wchar_t *_Str);
# 831 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_l(wchar_t * __restrict__ ,size_t _SizeInWords,const wchar_t * __restrict__ _Format,_locale_t _Locale,... ) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,va_list _Args) ;
# 1145 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vswprintf_p(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vscwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_p_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_l(wchar_t * __restrict__ _DstBuf,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,va_list _Args);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __swprintf_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,_locale_t _Plocinfo,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_l(wchar_t * __restrict__ _Dest,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __vswprintf_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,_locale_t _Plocinfo,va_list _Args) ;




# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\swprintf.inl" 1 3
# 10 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\swprintf.inl" 3
# 1 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 1 3
# 11 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\swprintf.inl" 2 3
# 25 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\swprintf.inl" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vswprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return vsnwprintf( __stream, __count, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int swprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __count, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}



extern "C++" {

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int vswprintf (wchar_t *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{

  return __mingw_vswprintf( __stream, __format, __local_argv );



}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int swprintf (wchar_t *__stream, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

}
# 1179 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 2 3
# 1188 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtempnam(const wchar_t *_Directory,const wchar_t *_FilePrefix);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_l(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,_locale_t _Locale,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_l(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,_locale_t _Locale,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf(const wchar_t * __restrict__ _Src,size_t _MaxCount,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_l(const wchar_t * __restrict__ _Src,size_t _MaxCount,const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...) ;

  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfdopen(int _FileHandle ,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode) ;
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfreopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode,FILE * __restrict__ _OldFile) ;



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wpopen(const wchar_t *_Command,const wchar_t *_Mode);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wremove(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtmpnam(wchar_t *_Buffer);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwc_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwc_nolock(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwc_nolock(wint_t _Ch,FILE *_File);
# 1235 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);


  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstod(_Str,_EndPtr);
  }
  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstof(_Str,_EndPtr);
  }






  long double __attribute__((__cdecl__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);

  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;




  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long _Val,wchar_t *_DstBuf,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsdup(const wchar_t *_Str);
  wchar_t *__attribute__((__cdecl__)) wcscat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
                wchar_t *__attribute__((__cdecl__)) wcschr(const wchar_t *_Str,wchar_t _Ch);
  int __attribute__((__cdecl__)) wcscmp(const wchar_t *_Str1,const wchar_t *_Str2);
  wchar_t *__attribute__((__cdecl__)) wcscpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  size_t __attribute__((__cdecl__)) wcscspn(const wchar_t *_Str,const wchar_t *_Control);
  size_t __attribute__((__cdecl__)) wcslen(const wchar_t *_Str);
  size_t __attribute__((__cdecl__)) wcsnlen(const wchar_t *_Src,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) wcsncmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  wchar_t *__attribute__((__cdecl__)) _wcsncpy_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count,_locale_t _Locale) ;
                wchar_t *__attribute__((__cdecl__)) wcspbrk(const wchar_t *_Str,const wchar_t *_Control);
                wchar_t *__attribute__((__cdecl__)) wcsrchr(const wchar_t *_Str,wchar_t _Ch);
  size_t __attribute__((__cdecl__)) wcsspn(const wchar_t *_Str,const wchar_t *_Control);
                wchar_t *__attribute__((__cdecl__)) wcsstr(const wchar_t *_Str,const wchar_t *_SubStr);
  wchar_t *__attribute__((__cdecl__)) wcstok(wchar_t * __restrict__ _Str,const wchar_t * __restrict__ _Delim) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcserror(int _ErrNum) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) __wcserror(const wchar_t *_Str) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsrev(wchar_t *_Str);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsset(wchar_t *_Str,wchar_t _Val) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcslwr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcslwr_l(wchar_t *_String,_locale_t _Locale) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsupr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcsupr_l(wchar_t *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcsxfrm(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsxfrm_l(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) wcscoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcscoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);


  wchar_t *__attribute__((__cdecl__)) wcsdup(const wchar_t *_Str) ;

  int __attribute__((__cdecl__)) wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2) ;
  int __attribute__((__cdecl__)) wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsrev(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsset(wchar_t *_Str,wchar_t _Val) ;
  wchar_t *__attribute__((__cdecl__)) wcslwr(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsupr(wchar_t *_Str) ;
  int __attribute__((__cdecl__)) wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2) ;





  struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
  };





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wasctime(const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  wchar_t *__attribute__((__cdecl__)) _wctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) wcsftime(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsftime_l(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrdate(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrtime(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);



  wchar_t *__attribute__((__cdecl__)) _wctime(const time_t *_Time) ;
# 1404 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  errno_t __attribute__((__cdecl__)) _wctime_s(wchar_t *, size_t, const time_t *);
# 1416 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
  typedef int mbstate_t;
  typedef wchar_t _Wint_t;

  wint_t __attribute__((__cdecl__)) btowc(int);
  size_t __attribute__((__cdecl__)) mbrlen(const char * __restrict__ _Ch,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbrtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbsrtowcs(wchar_t * __restrict__ _Dest,const char ** __restrict__ _PSrc,size_t _Count,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcrtomb(char * __restrict__ _Dest,wchar_t _Source,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcsrtombs(char * __restrict__ _Dest,const wchar_t ** __restrict__ _PSource,size_t _Count,mbstate_t * __restrict__ _State) ;
  int __attribute__((__cdecl__)) wctob(wint_t _WCh);


  wchar_t *__attribute__((__cdecl__)) wmemset(wchar_t *s, wchar_t c, size_t n);
                wchar_t *__attribute__((__cdecl__)) wmemchr(const wchar_t *s, wchar_t c, size_t n);
  int __attribute__((__cdecl__)) wmemcmp(const wchar_t *s1, const wchar_t *s2,size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemcpy(wchar_t * __restrict__ s1,const wchar_t * __restrict__ s2,size_t n) ;
  wchar_t * __attribute__((__cdecl__)) wmempcpy (wchar_t *_Dst, const wchar_t *_Src, size_t _Size);
  wchar_t *__attribute__((__cdecl__)) wmemmove(wchar_t *s1, const wchar_t *s2, size_t n) ;
  int __attribute__((__cdecl__)) fwide(FILE *stream,int mode);
  int __attribute__((__cdecl__)) mbsinit(const mbstate_t *ps);
  __extension__ long long __attribute__((__cdecl__)) wcstoll(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);
  __extension__ unsigned long long __attribute__((__cdecl__)) wcstoull(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);


  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _MaxCount) ;
# 1491 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
int __attribute__((__cdecl__)) __mingw_str_wide_utf8 (const wchar_t * const wptr, char **mbptr, size_t * buflen);
# 1505 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
int __attribute__((__cdecl__)) __mingw_str_utf8_wide (const char *const mbptr, wchar_t ** wptr, size_t * buflen);
# 1514 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 3
void __attribute__((__cdecl__)) __mingw_str_free(void *ptr);




}


#pragma pack(pop)


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/wchar_s.h" 1 3








# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 1 3
# 10 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/wchar_s.h" 2 3
# 1525 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw_print_pop.h" 1 3
# 1527 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wchar.h" 2 3
# 45 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 2 3
# 62 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 3
namespace std
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/postypes.h" 2 3
# 68 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/postypes.h" 3
namespace std
{
# 90 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
# 111 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iosfwd" 2 3

namespace std
{
# 74 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ios" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\exception" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\exception" 3

#pragma GCC visibility push(default)



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception.h" 1 3
# 35 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\exception" 2 3

extern "C++" {

namespace std
{


  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 102 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));
# 111 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\exception" 3
}

namespace __gnu_cxx
{
# 133 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_ptr.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_ptr.h" 3
#pragma GCC visibility push(default)



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_defines.h" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_ptr.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cxxabi_init_exception.h" 1 3
# 35 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)


# 1 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stddef.h" 1 3
# 51 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef long int ptrdiff_t;
# 62 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stddef.h" 3
typedef long unsigned int size_t;
# 118 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stddef.h" 3
# 1 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include/__stddef_max_align_t.h" 1 3
# 35 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 119 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stddef.h" 2 3
# 39 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cxxabi_init_exception.h" 2 3
# 50 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_ptr.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\typeinfo" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\typeinfo" 3



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/hash_bytes.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_ptr.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\new" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\new" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\exception" 1 3
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 120 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));






void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 168 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\new" 3
inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 216 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\new" 3
#pragma GCC visibility pop
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 117 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 144 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }

  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {
# 206 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/exception_ptr.h" 3
      return exception_ptr();

    }


}

}

#pragma GCC visibility pop
# 144 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\exception" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/nested_exception.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/nested_exception.h" 3
#pragma GCC visibility push(default)







# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/move.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/move.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/concept_check.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/concept_check.h" 3
# 35 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/move.h" 2 3

namespace std
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3







namespace std
{
# 56 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }






    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 180 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 312 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 340 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };
# 712 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 747 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __bool_constant<__is_assignable(_Tp, _Up)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, __bool_constant<
        __is_trivially_constructible(_Tp, _Args...)>>::type
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<is_default_constructible<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };
# 1452 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };
# 1509 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1590 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1694 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;
# 1744 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };
# 1781 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };
# 1820 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1840 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 1879 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }
# 2072 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };

  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };



  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };
# 2351 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename...> using __void_t = void;
# 2364 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2408 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };
# 2613 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>, is_convertible<typename _Result::type, _Ret>>::type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 2974 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\type_traits" 3
}
# 56 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/move.h" 2 3

namespace std
{
# 72 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 116 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 136 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 176 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {



      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/nested_exception.h" 2 3

extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }


  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 145 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\exception" 2 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ios" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/char_traits.h" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/char_traits.h" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 1 3
# 60 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/functexcept.h" 1 3
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/functexcept.h" 3
namespace std
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 1 3
# 36 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 3
# 67 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 3
extern "C++" {

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 278 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 408 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/type_traits.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/numeric_traits.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/numeric_traits.h" 3




namespace __gnu_cxx
{
# 54 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 53) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 15);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 308);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_pair.h" 1 3
# 65 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_pair.h" 3
namespace std
{
# 76 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


                    constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };




  struct __nonesuch_no_braces : std::__nonesuch {
    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };







  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 252 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;

      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 280 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch_no_braces&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
    is_assignable<_T2&, const _U2&>>::value,
    pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
    is_assignable<_T2&, _U2&&>>::value,
    pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };






  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline





    void

    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 521 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 541 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_pair.h" 3
}
# 65 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_types.h" 1 3
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_types.h" 3







namespace std
{
# 89 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 231 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_funcs.h" 1 3
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_funcs.h" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\debug/assertions.h" 1 3
# 66 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_funcs.h" 2 3

namespace std
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


                                ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {


      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {



      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 1 3
# 66 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ptr_traits.h" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ptr_traits.h" 3
namespace std
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 199 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ptr_traits.h" 3
}
# 67 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 2 3





namespace std
{
# 100 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
# 127 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }





      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>

        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




                           iterator_type
      base() const
      { return current; }
# 168 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
                           reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }
# 182 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
                           pointer
      operator->() const
      { return std::__addressof(operator*()); }






                           reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






                           reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






                           reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






                           reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






                           reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







                           reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






                           reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







                           reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






                           reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 300 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 390 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
# 425 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 454 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 489 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 531 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 546 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 580 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 622 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 641 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 692 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 737 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx
{
# 761 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 861 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }
# 1006 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;


      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>

 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

                           iterator_type
      base() const
      { return _M_current; }

                           reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

                           pointer
      operator->() const
      { return _M_current; }

                           move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

                           move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

                           move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

                           move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

                           move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

                           move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

                           move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

                           move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

                           reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 1272 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_iterator.h" 3
}
# 68 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\debug/debug.h" 1 3
# 48 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/predefined_ops.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>

      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };


  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>

        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>

    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 2 3

namespace std
{
# 118 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
# 148 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _Tp>

    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _Tp>

    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>

    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>

    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
        && __is_pointer<_II>::__value
        && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
         _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
        && __is_pointer<_BI1>::__value
        && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __is_pointer<_II1>::__value
        && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>
 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
 static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




                                                                  ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }
# 1037 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






                                                       ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1069 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1219 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
# 1233 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1255 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {



                                                       ;
                                                       ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1298 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1331 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 1433 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algobase.h" 3
}
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/char_traits.h" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 3
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/char_traits.h" 2 3





namespace __gnu_cxx
{
# 61 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
                         int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
                         std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
                         const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      if (__n == 0)
 return __s1;
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std
{
# 270 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return __builtin_strlen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {






 if (__n == 0)
   return 0;
 else
   return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {





   return wcslen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {






 if (__n == 0)
   return 0;
 else
   return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((wint_t)(0xFFFF)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}





# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdint" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdint" 3








# 1 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stdint.h" 1 3
# 63 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stdint.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdint.h" 1 3
# 32 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdint.h" 3
# 1 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stddef.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdint.h" 2 3


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
__extension__ typedef long long int64_t;
__extension__ typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
__extension__ typedef long long int_least64_t;
__extension__ typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef long long int_fast64_t;
__extension__ typedef unsigned long long uint_fast64_t;


__extension__ typedef long long intmax_t;
__extension__ typedef unsigned long long uintmax_t;
# 64 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stdint.h" 2 3
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 504 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/char_traits.h" 2 3

namespace std
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ios" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/localefwd.h" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/localefwd.h" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++locale.h" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++locale.h" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\clocale" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\clocale" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\locale.h" 1 3
# 12 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\locale.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 1 3
# 11 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw_print_push.h" 1 3
# 12 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 2 3

#pragma pack(push,_CRT_PACKING)


extern "C" {
# 82 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
__attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __acrt_iob_func(unsigned index);


  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __iob_func(void);
# 104 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
  __extension__ typedef long fpos_t;
# 162 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_scanf(const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vscanf(const char * __restrict__ Format, va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);

extern
  __attribute__((__format__ (gnu_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnprintf(char * __restrict__ _DstBuf,size_t _MaxCount,const char * __restrict__ _Format,
                               va_list _ArgList);
extern
  __attribute__((__format__ (gnu_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snprintf(char * __restrict__ s, size_t n, const char * __restrict__ format, ...);
extern
  __attribute__((__format__ (gnu_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_printf(const char * __restrict__ , ... ) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vprintf (const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fprintf (FILE * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfprintf (FILE * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sprintf (char * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsprintf (char * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_asprintf(char ** __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_vasprintf(char ** __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
# 262 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
extern "C++" {


static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int sscanf(const char *__source, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsscanf( __source, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
int scanf(const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfscanf( (__acrt_iob_func(0)), __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int fscanf(FILE *__stream, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfscanf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"


static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vsscanf (const char *__source, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsscanf( __source, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
int vscanf(const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfscanf( (__acrt_iob_func(0)), __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vfscanf (FILE *__stream, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfscanf( __stream, __format, __local_argv );
}


#pragma GCC diagnostic pop





static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int fprintf (FILE *__stream, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
int printf (const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfprintf( (__acrt_iob_func(1)), __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int sprintf (char *__stream, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vfprintf (FILE *__stream, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfprintf( __stream, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
int vprintf (const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfprintf( (__acrt_iob_func(1)), __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vsprintf (char *__stream, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsprintf( __stream, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
int snprintf (char *__stream, size_t __n, const char *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsnprintf( __stream, __n, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
int vsnprintf (char *__stream, size_t __n, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsnprintf( __stream, __n, __format, __local_argv );
}
# 411 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
}
# 571 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _filbuf(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flsbuf(int _Ch,FILE *_File);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fsopen(const char *_Filename,const char *_Mode,int _ShFlag);

  void __attribute__((__cdecl__)) clearerr(FILE *_File);
  int __attribute__((__cdecl__)) fclose(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fcloseall(void);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fdopen(int _FileHandle,const char *_Mode);

  int __attribute__((__cdecl__)) feof(FILE *_File);
  int __attribute__((__cdecl__)) ferror(FILE *_File);
  int __attribute__((__cdecl__)) fflush(FILE *_File);
  int __attribute__((__cdecl__)) fgetc(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fgetchar(void);
  int __attribute__((__cdecl__)) fgetpos(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  int __attribute__((__cdecl__)) fgetpos64(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  char *__attribute__((__cdecl__)) fgets(char * __restrict__ _Buf,int _MaxCount,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fileno(FILE *_File);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _tempnam(const char *_DirName,const char *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flushall(void);
  FILE *__attribute__((__cdecl__)) fopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode) ;
  FILE *fopen64(const char * __restrict__ filename,const char * __restrict__ mode);
  int __attribute__((__cdecl__)) fputc(int _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fputchar(int _Ch);
  int __attribute__((__cdecl__)) fputs(const char * __restrict__ _Str,FILE * __restrict__ _File);
  size_t __attribute__((__cdecl__)) fread(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  FILE *__attribute__((__cdecl__)) freopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode,FILE * __restrict__ _File) ;
  int __attribute__((__cdecl__)) fsetpos(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fsetpos64(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fseek(FILE *_File,long _Offset,int _Origin);
  long __attribute__((__cdecl__)) ftell(FILE *_File);
# 631 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
  __extension__ int __attribute__((__cdecl__)) _fseeki64(FILE *_File,long _Offset,int _Origin);
  __extension__ long __attribute__((__cdecl__)) _ftelli64(FILE *_File);
  int fseeko64(FILE* stream, _off64_t offset, int whence);
  int fseeko(FILE* stream, _off_t offset, int whence);

  _off_t ftello(FILE * stream);
  _off64_t ftello64(FILE * stream);
# 654 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
  size_t __attribute__((__cdecl__)) fwrite(const void * __restrict__ _Str,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) getc(FILE *_File);
  int __attribute__((__cdecl__)) getchar(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getmaxstdio(void);
  char *__attribute__((__cdecl__)) gets(char *_Buffer) ;
  int __attribute__((__cdecl__)) _getw(FILE *_File);


  void __attribute__((__cdecl__)) perror(const char *_ErrMsg);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _pclose(FILE *_File);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _popen(const char *_Command,const char *_Mode);




  int __attribute__((__cdecl__)) putc(int _Ch,FILE *_File);
  int __attribute__((__cdecl__)) putchar(int _Ch);
  int __attribute__((__cdecl__)) puts(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putw(int _Word,FILE *_File);


  int __attribute__((__cdecl__)) remove(const char *_Filename);
  int __attribute__((__cdecl__)) rename(const char *_OldFilename,const char *_NewFilename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _unlink(const char *_Filename);

  int __attribute__((__cdecl__)) unlink(const char *_Filename) ;


  void __attribute__((__cdecl__)) rewind(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _rmtmp(void);
  void __attribute__((__cdecl__)) setbuf(FILE * __restrict__ _File,char * __restrict__ _Buffer) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _setmaxstdio(int _Max);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_output_format(unsigned int _Format);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _get_output_format(void);
  int __attribute__((__cdecl__)) setvbuf(FILE * __restrict__ _File,char * __restrict__ _Buf,int _Mode,size_t _Size);
# 712 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf(const char * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf(const char * __restrict__ _Src,size_t _MaxCount,const char * __restrict__ _Format,...) ;

  FILE *__attribute__((__cdecl__)) tmpfile(void) ;
  char *__attribute__((__cdecl__)) tmpnam(char *_Buffer);
  int __attribute__((__cdecl__)) ungetc(int _Ch,FILE *_File);
# 734 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
  __attribute__((__format__ (ms_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,...) ;
  __attribute__((__format__ (ms_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,va_list _Args) ;
# 811 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf(const char * __restrict__ _Format,va_list _ArgList);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_printf_count_output(int _Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _get_printf_count_output(void);
# 1293 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _lock_file(FILE *_File);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _unlock_file(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fclose_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fflush_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseek_nolock(FILE *_File,long _Offset,int _Origin);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _ftell_nolock(FILE *_File);
  __extension__ __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseeki64_nolock(FILE *_File,long _Offset,int _Origin);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _ftelli64_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fwrite_nolock(const void * __restrict__ _DstBuf,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ungetc_nolock(int _Ch,FILE *_File);





  char *__attribute__((__cdecl__)) tempnam(const char *_Directory,const char *_FilePrefix) ;
  int __attribute__((__cdecl__)) fcloseall(void) ;
  FILE *__attribute__((__cdecl__)) fdopen(int _FileHandle,const char *_Format) ;
  int __attribute__((__cdecl__)) fgetchar(void) ;
  int __attribute__((__cdecl__)) fileno(FILE *_File) ;
  int __attribute__((__cdecl__)) flushall(void) ;
  int __attribute__((__cdecl__)) fputchar(int _Ch) ;
  int __attribute__((__cdecl__)) getw(FILE *_File) ;
  int __attribute__((__cdecl__)) putw(int _Ch,FILE *_File) ;
  int __attribute__((__cdecl__)) rmtmp(void) ;
# 1388 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 3
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnv(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnve(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvp(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvpe(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);



}


#pragma pack(pop)


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/stdio_s.h" 1 3








# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 1 3
# 10 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/stdio_s.h" 2 3
# 1401 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw_print_pop.h" 1 3
# 1403 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdio.h" 2 3
# 13 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\locale.h" 2 3


#pragma pack(push,_CRT_PACKING)


extern "C" {
# 45 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\locale.h" 3
  struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
  };
# 79 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\locale.h" 3
  int __attribute__((__cdecl__)) _configthreadlocale(int _Flag);
  char *__attribute__((__cdecl__)) setlocale(int _Category,const char *_Locale);
  __attribute__ ((__dllimport__)) struct lconv *__attribute__((__cdecl__)) localeconv(void);
  __attribute__ ((__dllimport__)) _locale_t __attribute__((__cdecl__)) _get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) _create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) _free_locale(_locale_t _Locale);
  _locale_t __attribute__((__cdecl__)) __get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) __create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) __free_locale(_locale_t _Locale);







}


#pragma pack(pop)
# 43 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\clocale" 2 3








namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++locale.h" 2 3



namespace std
{


  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, 0);
    char* __sav = 0;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __mingw_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }


}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/localefwd.h" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cctype" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cctype" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\ctype.h" 1 3
# 12 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\ctype.h" 3
extern "C" {
# 80 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\ctype.h" 3
  extern const unsigned char __newclmap[];
  extern const unsigned char __newcumap[];
  extern pthreadlocinfo __ptlocinfo;
  extern pthreadmbcinfo __ptmbcinfo;
  extern int __globallocalestatus;
  extern int __locale_changed;
  extern struct threadlocaleinfostruct __initiallocinfo;
  extern _locale_tstruct __initiallocalestructinfo;
  pthreadlocinfo __attribute__((__cdecl__)) __updatetlocinfo(void);
  pthreadmbcinfo __attribute__((__cdecl__)) __updatetmbcinfo(void);
# 108 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\ctype.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype(int _C,int _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype_l(int _C,int _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalpha(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalpha_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) islower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _islower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isxdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isxdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isspace(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isspace_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) ispunct(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ispunct_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalnum(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalnum_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isprint(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isprint_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isgraph(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isgraph_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) iscntrl(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iscntrl_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __isascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __toascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsymf(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsym(int _C);


int __attribute__((__cdecl__)) isblank(int _C);
# 203 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\ctype.h" 3
  extern int * __imp___mb_cur_max;




__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) ___mb_cur_max_func(void);
# 286 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\ctype.h" 3
}
# 43 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cctype" 2 3
# 62 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/localefwd.h" 2 3

namespace std
{
# 55 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ios" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/atomicity.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/atomicity.h" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr.h" 1 3
# 30 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr-default.h" 1 3
# 69 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr-default.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\errno.h" 1 3
# 12 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\errno.h" 3
extern "C" {




__attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);


errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);
# 239 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\errno.h" 3
}
# 70 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr-default.h" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 1 3
# 72 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr-default.h" 2 3
# 339 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr-default.h" 3
extern "C" {


typedef unsigned long __gthread_key_t;

typedef struct {
  int done;
  long started;
} __gthread_once_t;

typedef struct {
  long counter;
  void *sema;
} __gthread_mutex_t;

typedef struct {
  long counter;
  long depth;
  unsigned long owner;
  void *sema;
} __gthread_recursive_mutex_t;
# 373 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr-default.h" 3
extern int _CRT_MT;
extern int __mingwthr_key_dtor (unsigned long, void (*) (void *));
# 400 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{

  return _CRT_MT;



}







extern int __gthr_win32_once (__gthread_once_t *, void (*) (void));
extern int __gthr_win32_key_create (__gthread_key_t *, void (*) (void*));
extern int __gthr_win32_key_delete (__gthread_key_t);
extern void * __gthr_win32_getspecific (__gthread_key_t);
extern int __gthr_win32_setspecific (__gthread_key_t, const void *);
extern void __gthr_win32_mutex_init_function (__gthread_mutex_t *);
extern int __gthr_win32_mutex_lock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_trylock (__gthread_mutex_t *);
extern int __gthr_win32_mutex_unlock (__gthread_mutex_t *);
extern void
  __gthr_win32_recursive_mutex_init_function (__gthread_recursive_mutex_t *);
extern int __gthr_win32_recursive_mutex_lock (__gthread_recursive_mutex_t *);
extern int
  __gthr_win32_recursive_mutex_trylock (__gthread_recursive_mutex_t *);
extern int __gthr_win32_recursive_mutex_unlock (__gthread_recursive_mutex_t *);
extern void __gthr_win32_mutex_destroy (__gthread_mutex_t *);
extern int
  __gthr_win32_recursive_mutex_destroy (__gthread_recursive_mutex_t *);

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthr_win32_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthr_win32_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthr_win32_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthr_win32_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthr_win32_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  __gthr_win32_mutex_init_function (__mutex);
}

static inline void
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  __gthr_win32_mutex_destroy (__mutex);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_trylock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_mutex_unlock (__mutex);
  else
    return 0;
}

static inline void
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
   __gthr_win32_recursive_mutex_init_function (__mutex);
}

static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_recursive_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_recursive_mutex_trylock (__mutex);
  else
    return 0;
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthr_win32_recursive_mutex_unlock (__mutex);
  else
    return 0;
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthr_win32_recursive_mutex_destroy (__mutex);
}
# 782 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr-default.h" 3
}
# 149 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/atomicity.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/atomic_word.h" 1 3
# 32 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/atomicity.h" 2 3

namespace __gnu_cxx
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\string" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\string" 3




# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/allocator.h" 1 3
# 46 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/allocator.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++allocator.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++allocator.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/new_allocator.h" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/new_allocator.h" 3
namespace __gnu_cxx
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
 new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();
# 111 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/new_allocator.h" 3
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      {







 ::operator delete(__p);
      }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }
# 151 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++allocator.h" 2 3


namespace std
{
# 47 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/allocator.h" 2 3
# 57 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/allocator.h" 3
namespace std
{
# 67 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;

      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p) { __p->~_Up(); }

    };
# 107 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
 allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }



  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {
# 264 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/allocator.h" 3
 return false;

      }
    };



}
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\string" 2 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ostream_insert.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ostream_insert.h" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cxxabi_forced.h" 1 3
# 35 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ostream_insert.h" 2 3

namespace std
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   if (true)
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   if (false)
     {
       __out._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\string" 2 3



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 1 3
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 3
namespace std
{
# 104 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 166 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 350 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
                           bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x > __y))
   return __x > __y;
 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
                           bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x < __y))
   return __x < __y;
 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
                           bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x >= __y))
   return __x >= __y;
 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
                           bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
 if (__builtin_constant_p (__x <= __y))
   return __x <= __y;
 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };
# 761 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {

      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {

      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 854 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 3
  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {

      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };
# 978 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:

      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }


      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>

    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:

      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }


      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>

    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1055 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1178 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\backward/binders.h" 1 3
# 60 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std
{
# 107 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1369 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_function.h" 2 3
# 49 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\string" 2 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/range_access.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/range_access.h" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\initializer_list" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/range_access.h" 2 3
namespace std
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }
# 324 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/range_access.h" 3
}
# 52 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\string" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/alloc_traits.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/alloc_traits.h" 3



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 1 3
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
namespace std
{


  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 299 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 314 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 326 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 341 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 354 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 366 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 377 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 434 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 448 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 460 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 472 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 484 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;


}
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/alloc_traits.h" 2 3




namespace __gnu_cxx
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/alloc_traits.h" 3
  };


}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 2 3
# 52 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
namespace std
{



namespace __cxx11 {
# 76 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;
# 139 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 298 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)"),

       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 450 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 481 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 499 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }
# 514 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
# 529 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 541 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 609 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 656 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 713 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 731 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {

     if (__str.size())
       this->_S_copy(_M_data(), __str._M_data(), __str.size());
     _M_set_length(__str.size());
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }
# 825 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 954 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 967 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {
# 985 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 1016 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1045 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
                                  ;
 return _M_data()[__pos];
      }
# 1062 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


                                  ;

                                                                   ;
 return _M_data()[__pos];
      }
# 1083 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
 return _M_data()[__n];
      }
# 1104 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
                           ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
                           ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
                           ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
                           ;
 return operator[](this->size() - 1);
      }
# 1167 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1220 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1237 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
                                        ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1279 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1303 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }
# 1348 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1379 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1402 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1418 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
                                        ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1434 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1451 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1464 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1532 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
                                                         ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1574 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
                                                           ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1610 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
                                                         ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1630 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1653 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1676 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1695 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1719 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1737 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
                                                         ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1797 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1816 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1835 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
                           ;
 _M_erase(size() - 1, 1);
      }
# 1879 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1901 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1926 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
                                         ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1951 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1975 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1993 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2013 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2035 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2056 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2081 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                        ;
                                             ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2113 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2172 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2231 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2269 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2279 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2289 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2301 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2320 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2336 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2350 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2382 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2399 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2412 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2446 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2460 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2477 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2491 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2526 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2540 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2560 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2575 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2610 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2624 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2644 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2658 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2693 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2707 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2725 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2740 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2775 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2789 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2807 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2823 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2842 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2935 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2961 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 2979 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 3003 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3030 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;


      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 5925 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6046 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6093 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6131 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6169 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6207 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6245 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6283 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6303 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6321 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6344 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6361 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}




# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/string_conversions.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/string_conversions.h" 3








# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
# 75 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 1 3
# 10 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
# 1 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\limits.h" 1 3
# 37 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\limits.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\limits.h" 1 3
# 38 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\limits.h" 2 3
# 11 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 2 3
# 25 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 49 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);
# 59 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  typedef struct _div_t {
    int quot;
    int rem;
  } div_t;

  typedef struct _ldiv_t {
    long quot;
    long rem;
  } ldiv_t;





#pragma pack(4)
 typedef struct {
    unsigned char ld[10];
  } _LDOUBLE;
#pragma pack()



 typedef struct {
    double x;
  } _CRT_DOUBLE;

  typedef struct {
    float f;
  } _CRT_FLOAT;




  typedef struct {
    long double x;
  } _LONGDOUBLE;



#pragma pack(4)
 typedef struct {
    unsigned char ld12[12];
  } _LDBL12;
#pragma pack()
# 142 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
 typedef void (__attribute__((__cdecl__)) *_purecall_handler)(void);

  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _set_purecall_handler(_purecall_handler _Handler);
  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _get_purecall_handler(void);

  typedef void (__attribute__((__cdecl__)) *_invalid_parameter_handler)(const wchar_t *,const wchar_t *,const wchar_t *,unsigned int,uintptr_t);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _get_invalid_parameter_handler(void);
# 158 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned long *__attribute__((__cdecl__)) __doserrno(void);

  errno_t __attribute__((__cdecl__)) _set_doserrno(unsigned long _Value);
  errno_t __attribute__((__cdecl__)) _get_doserrno(unsigned long *_Value);
# 172 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern __attribute__((dllimport)) char *_sys_errlist[1];
  extern __attribute__((dllimport)) int _sys_nerr;





  __attribute__ ((__dllimport__)) char ***__attribute__((__cdecl__)) __p___argv(void);
  __attribute__ ((__dllimport__)) int *__attribute__((__cdecl__)) __p__fmode(void);
# 190 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  errno_t __attribute__((__cdecl__)) _get_pgmptr(char **_Value);
  errno_t __attribute__((__cdecl__)) _get_wpgmptr(wchar_t **_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_fmode(int _Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_fmode(int *_PMode);
# 281 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern int * __imp___argc;



  extern char *** __imp___argv;



  extern wchar_t *** __imp___wargv;





  extern char *** __imp__environ;




  extern wchar_t *** __imp__wenviron;





  extern char ** __imp__pgmptr;




  extern wchar_t ** __imp__wpgmptr;




  extern unsigned int * __imp__osplatform;




  extern unsigned int * __imp__osver;




  extern unsigned int * __imp__winver;




  extern unsigned int * __imp__winmajor;




  extern unsigned int * __imp__winminor;





  errno_t __attribute__((__cdecl__)) _get_osplatform(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_osver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winmajor(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winminor(unsigned int *_Value);




  extern "C++" {
    template <typename _CountofType,size_t _SizeOfArray> char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

  }





  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));
# 374 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) abort(void);




  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_abort_behavior(unsigned int _Flags,unsigned int _Mask);



  int __attribute__((__cdecl__)) abs(int _X);
  long __attribute__((__cdecl__)) labs(long _X);


  __extension__ long __attribute__((__cdecl__)) _abs64(long);

  extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) long __attribute__((__cdecl__)) _abs64(long x) {
    return __builtin_llabs(x);
  }


  int __attribute__((__cdecl__)) atexit(void (__attribute__((__cdecl__)) *)(void));


  double __attribute__((__cdecl__)) atof(const char *_String);
  double __attribute__((__cdecl__)) _atof_l(const char *_String,_locale_t _Locale);

  int __attribute__((__cdecl__)) atoi(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoi_l(const char *_Str,_locale_t _Locale);
  long __attribute__((__cdecl__)) atol(const char *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atol_l(const char *_Str,_locale_t _Locale);


  void *__attribute__((__cdecl__)) bsearch(const void *_Key,const void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));
  void __attribute__((__cdecl__)) qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));

  unsigned short __attribute__((__cdecl__)) _byteswap_ushort(unsigned short _Short);
  unsigned long __attribute__((__cdecl__)) _byteswap_ulong (unsigned long _Long);
  __extension__ unsigned long __attribute__((__cdecl__)) _byteswap_uint64(unsigned long _Int64);
  div_t __attribute__((__cdecl__)) div(int _Numerator,int _Denominator);
  char *__attribute__((__cdecl__)) getenv(const char *_VarName) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _itoa(int _Value,char *_Dest,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _i64toa(long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ui64toa(unsigned long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atoi64(const char *_String);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atoi64_l(const char *_String,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtoi64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtoi64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoui64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoui64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  ldiv_t __attribute__((__cdecl__)) ldiv(long _Numerator,long _Denominator);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ltoa(long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) mblen(const char *_Ch,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mblen_l(const char *_Ch,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen(const char *_Str);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen_l(const char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen(const char *_Str,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen_l(const char *_Str,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mbtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mbtowc_l(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstowcs_l(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mkstemp(char *template_name);
  int __attribute__((__cdecl__)) rand(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_error_mode(int _Mode);
  void __attribute__((__cdecl__)) srand(unsigned int _Seed);
# 449 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  return __mingw_strtod( _Str, _EndPtr);
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  return __mingw_strtof( _Str, _EndPtr);
}






  long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold(const char * __restrict__ , char ** __restrict__ );


  extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
  __strtod (const char * __restrict__ , char ** __restrict__);







  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  long double __attribute__((__cdecl__)) __mingw_strtold(const char * __restrict__, char ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _strtod_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) strtol(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtol_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) strtoul(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoul_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);


  int __attribute__((__cdecl__)) system(const char *_Command);

  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ultoa(unsigned long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) wctomb(char *_MbCh,wchar_t _WCh) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wctomb_l(char *_MbCh,wchar_t _WCh,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcstombs(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcstombs_l(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale) ;



  void *__attribute__((__cdecl__)) calloc(size_t _NumOfElements,size_t _SizeOfElements);
  void __attribute__((__cdecl__)) free(void *_Memory);
  void *__attribute__((__cdecl__)) malloc(size_t _Size);
  void *__attribute__((__cdecl__)) realloc(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _recalloc(void *_Memory,size_t _Count,size_t _Size);






  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _aligned_free(void *_Memory);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_malloc(size_t _Size,size_t _Alignment);



  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_malloc(size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_realloc(void *_Memory,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_realloc(void *_Memory,size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment,size_t _Offset);
# 579 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putenv(const char *_EnvString);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fullpath(char *_FullPath,const char *_Path,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl(_CRT_DOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl(_LDOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt(_CRT_FLOAT *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl_l(_CRT_DOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl_l(_LDOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale);
# 609 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long,int);
unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long,int);





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _makepath(char *_Path,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  _onexit_t __attribute__((__cdecl__)) _onexit(_onexit_t _Func);
# 627 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  __extension__ unsigned long __attribute__((__cdecl__)) _rotl64(unsigned long _Val,int _Shift);
  __extension__ unsigned long __attribute__((__cdecl__)) _rotr64(unsigned long Value,int Shift);






  unsigned int __attribute__((__cdecl__)) _rotr(unsigned int _Val,int _Shift);
  unsigned int __attribute__((__cdecl__)) _rotl(unsigned int _Val,int _Shift);


  __extension__ unsigned long __attribute__((__cdecl__)) _rotr64(unsigned long _Val,int _Shift);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _searchenv(const char *_Filename,const char *_EnvVar,char *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _splitpath(const char *_FullPath,char *_Drive,char *_Dir,char *_Filename,char *_Ext) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _swab(char *_Buf1,char *_Buf2,int _SizeInBytes);
# 656 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _beep(unsigned _Frequency,unsigned _Duration) __attribute__ ((__deprecated__));

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _seterrormode(int _Mode) __attribute__ ((__deprecated__));
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _sleep(unsigned long _Duration) __attribute__ ((__deprecated__));
# 680 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  char *__attribute__((__cdecl__)) ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  char *__attribute__((__cdecl__)) itoa(int _Val,char *_DstBuf,int _Radix) ;
  char *__attribute__((__cdecl__)) ltoa(long _Val,char *_DstBuf,int _Radix) ;
  int __attribute__((__cdecl__)) putenv(const char *_EnvString) ;



  void __attribute__((__cdecl__)) swab(char *_Buf1,char *_Buf2,int _SizeInBytes) ;


  char *__attribute__((__cdecl__)) ultoa(unsigned long _Val,char *_Dstbuf,int _Radix) ;
  _onexit_t __attribute__((__cdecl__)) onexit(_onexit_t _Func);





  typedef struct { __extension__ long long quot, rem; } lldiv_t;

  __extension__ lldiv_t __attribute__((__cdecl__)) lldiv(long long, long long);

  __extension__ long long __attribute__((__cdecl__)) llabs(long long);




  __extension__ long long __attribute__((__cdecl__)) strtoll(const char * __restrict__, char ** __restrict, int);
  __extension__ unsigned long long __attribute__((__cdecl__)) strtoull(const char * __restrict__, char ** __restrict__, int);


  __extension__ long long __attribute__((__cdecl__)) atoll (const char *);
# 735 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
}


#pragma pack(pop)


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/stdlib_s.h" 1 3








# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 1 3
# 30 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 1 3
# 31 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 2 3
# 10 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/stdlib_s.h" 2 3
# 741 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 1 3
# 11 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 46 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
  typedef struct _heapinfo {
    int *_pentry;
    size_t _size;
    int _useflag;
  } _HEAPINFO;


  extern unsigned int _amblksiz;
# 103 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
void * __mingw_aligned_malloc (size_t _Size, size_t _Alignment);
void __mingw_aligned_free (void *_Memory);
void * __mingw_aligned_offset_realloc (void *_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
void * __mingw_aligned_realloc (void *_Memory, size_t _Size, size_t _Offset);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _resetstkoflw (void);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _set_malloc_crt_max_wait(unsigned long _NewValue);

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _expand(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _msize(void *_Memory);






  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _get_sbh_threshold(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_sbh_threshold(size_t _NewValue);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_amblksiz(size_t _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_amblksiz(size_t *_Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapadd(void *_Memory,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapchk(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapmin(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapset(unsigned int _Fill);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapwalk(_HEAPINFO *_EntryInfo);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _heapused(size_t *_Used,size_t *_Commit);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_heap_handle(void);
# 144 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
  static __inline void *_MarkAllocaS(void *_Ptr,unsigned int _Marker) {
    if(_Ptr) {
      *((unsigned int*)_Ptr) = _Marker;
      _Ptr = (char*)_Ptr + 16;
    }
    return _Ptr;
  }
# 163 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
  static __inline void __attribute__((__cdecl__)) _freea(void *_Memory) {
    unsigned int _Marker;
    if(_Memory) {
      _Memory = (char*)_Memory - 16;
      _Marker = *(unsigned int *)_Memory;
      if(_Marker==0xDDDD) {
 free(_Memory);
      }





    }
  }
# 206 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
}


#pragma pack(pop)
# 742 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 2 3
# 76 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/std_abs.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/std_abs.h" 3
# 46 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/std_abs.h" 3
extern "C++"
{
namespace std
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }







  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
# 107 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/std_abs.h" 3
}
}
# 78 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 2 3
# 121 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
extern "C++"
{
namespace std
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
namespace __gnu_cxx
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/string_conversions.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwchar" 3
# 43 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/string_conversions.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 3
# 96 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;


  using ::gets;

  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 3
namespace __gnu_cxx
{
# 175 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/string_conversions.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cerrno" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cerrno" 3
# 45 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/string_conversions.h" 2 3

namespace __gnu_cxx
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*_errno())) { (*_errno()) = 0; }
 ~_Save_errno() { if ((*_errno()) == 0) (*_errno()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*_errno()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6401 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 2 3

namespace std
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}






# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/functional_hash.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/functional_hash.h" 3



namespace std
{
# 49 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type ;
      typedef _Arg argument_type ;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };
# 187 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 6627 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 2 3

namespace std
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };
# 6740 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.h" 3
}
# 53 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\string" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.tcc" 1 3
# 43 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.tcc" 3



namespace std
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 if (true)
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 if (false)
   {
     _M_dispose();
                            ;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid"));


 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 if (true)
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 if (false)
   {
     _M_dispose();
                            ;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1155 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   if (true)
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   if (false)
     {
       __in._M_setstate(__ios_base::badbit);
                              ;
     }
   if (false)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1607 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_string.tcc" 3
  extern template class basic_string<char>;







  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);



  extern template class basic_string<wchar_t>;





  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\string" 2 3
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 2 3


namespace std
{
# 62 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    locale() throw();
# 126 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 483 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   if (true)
     { delete this; }
   if (false)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 641 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 668 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 682 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 699 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 718 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 732 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 761 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 775 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 788 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.tcc" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.tcc" 3

namespace std
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      if (true)
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      if (false)
 {
   _M_impl->_M_remove_reference();
                          ;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      if (true)
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      if (false)
 {
   __tmp->_M_remove_reference();
                          ;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      if (true)
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      if (false)
 {
   delete [] __c;
                          ;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 852 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_classes.h" 2 3
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 2 3




# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\system_error" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\system_error" 3






# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/error_constants.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/error_constants.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cerrno" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cerrno" 3
# 35 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/error_constants.h" 2 3

namespace std
{




  enum class errc
    {
      address_family_not_supported = 102,
      address_in_use = 100,
      address_not_available = 101,
      already_connected = 113,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,

      bad_message = 104,

      broken_pipe = 32,
      connection_aborted = 106,
      connection_already_in_progress = 103,
      connection_refused = 107,
      connection_reset = 108,
      cross_device_link = 18,
      destination_address_required = 109,
      device_or_resource_busy = 16,
      directory_not_empty = 41,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 38,
      function_not_supported = 40,
      host_unreachable = 110,

      identifier_removed = 111,

      illegal_byte_sequence = 42,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 115,
      network_down = 116,
      network_reset = 117,
      network_unreachable = 118,
      no_buffer_space = 119,

      no_child_process = 10,


      no_link = 121,

      no_lock_available = 39,

      no_message_available = 120,




      no_protocol_option = 123,

      no_space_on_device = 28,


      no_stream_resources = 124,

      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 128,

      not_a_stream = 125,

      not_connected = 126,
      not_enough_memory = 12,

      not_supported = 129,

      operation_canceled = 105,
      operation_in_progress = 112,

      operation_not_permitted = 1,

      operation_not_supported = 130,

      operation_would_block = 140,


      owner_dead = 133,

      permission_denied = 13,
      protocol_error = 134,
      protocol_not_supported = 135,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 36,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,

      state_not_recoverable = 127,


      stream_timeout = 137,


      text_file_busy = 139,


      timed_out = 138,

      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 114,

      value_too_large = 132,

      wrong_protocol_type = 136
   };


}
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\system_error" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdexcept" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdexcept" 3




namespace std
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\system_error" 2 3

namespace std
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };
# 71 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\system_error" 3
  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 110 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std
{





  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };
# 415 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\system_error" 3
}
# 47 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 2 3


namespace std
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 2147483647,
      _S_ios_fmtflags_min = ~2147483647
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 2147483647,
      _S_ios_openmode_min = ~2147483647
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 2147483647,
      _S_ios_iostate_min = ~2147483647
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
  class ios_base
  {
# 246 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
  public:
# 255 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;



    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 489 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 506 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 518 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

                                                             ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
                                                                ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 631 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 647 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 664 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 690 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 741 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 753 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 764 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 775 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 794 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    static int
    xalloc() throw();
# 810 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 831 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 848 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 862 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ios" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3








namespace std
{




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 121 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
        advance(istreambuf_iterator<_CharT2>&, _Distance);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 215 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 232 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 245 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 257 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 269 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 290 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 304 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 322 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 344 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 363 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 378 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 403 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 430 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 456 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 470 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 488 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 504 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 515 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 535 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 551 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 561 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 582 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual void
      imbue(const locale& __loc __attribute__ ((__unused__)))
      { }
# 597 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 608 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 620 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 633 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual int
      sync() { return 0; }
# 655 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 671 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 693 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 706 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 730 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual int_type
      pbackfail(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 748 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 774 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      virtual int_type
      overflow(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 790 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 3
      [[__deprecated__("stossc is deprecated, use sbumpc instead")]]

      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);





}


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/streambuf.tcc" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/streambuf.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 863 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\streambuf" 2 3
# 44 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ios" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwctype" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwctype" 3
# 50 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwctype" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wctype.h" 1 3
# 15 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wctype.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 174 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\wctype.h" 3
  typedef wchar_t wctrans_t;
  wint_t __attribute__((__cdecl__)) towctrans(wint_t,wctrans_t);
  wctrans_t __attribute__((__cdecl__)) wctrans(const char *);
  wctype_t __attribute__((__cdecl__)) wctype(const char *);


}


#pragma pack(pop)
# 51 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwctype" 2 3
# 80 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cctype" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cctype" 3
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/ctype_base.h" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/ctype_base.h" 3
namespace std
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = 1 << 0;
    static const mask lower = 1 << 1;
    static const mask alpha = 1 << 2;
    static const mask digit = 1 << 3;
    static const mask xdigit = 1 << 4;
    static const mask space = 1 << 5;
    static const mask print = 1 << 6;
    static const mask graph = (1 << 2) | (1 << 3) | (1 << 9);
    static const mask cntrl = 1 << 8;
    static const mask punct = 1 << 9;
    static const mask alnum = (1 << 2) | (1 << 3);

    static const mask blank = 1 << 10;

  };


}
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 2 3






# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/streambuf_iterator.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/streambuf_iterator.h" 3




namespace std
{
# 49 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
 advance(istreambuf_iterator<_CharT2>&, _Distance);

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {
 int_type __c = _M_get();
# 139 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/streambuf_iterator.h" 3
 return traits_type::to_char_type(__c);
      }


      istreambuf_iterator&
      operator++()
      {



                        ;

 _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {



                        ;

 istreambuf_iterator __old = *this;
 __old._M_c = _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 int_type __ret = _M_c;
 if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
   _M_sbuf = 0;
 return __ret;
      }

      bool
      _M_at_eof() const
      { return _S_is_eof(_M_get()); }

      static bool
      _S_is_eof(int_type __c)
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(__c, __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, __eof)
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   __first._M_c = __eof;
 }

      return __first;
    }

  template<typename _CharT, typename _Distance>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        void>::__type
    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)
    {
      if (__n == 0)
 return;

                               ;


                           ;

      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      streambuf_type* __sb = __i._M_sbuf;
      while (__n > 0)
 {
   streamsize __size = __sb->egptr() - __sb->gptr();
   if (__size > __n)
     {
       __sb->__safe_gbump(__n);
       break;
     }

   __sb->__safe_gbump(__size);
   __n -= __size;
   if (traits_type::eq_int_type(__sb->underflow(), __eof))
     {


                      ;
       break;
     }
 }

      __i._M_c = __eof;
    }




}
# 49 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 2 3

namespace std
{
# 71 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 930 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 963 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1013 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1030 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1046 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1063 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1083 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1106 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1133 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1159 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1185 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1218 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1229 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1253 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1272 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1290 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1308 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1325 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1342 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1358 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1375 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1395 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1417 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1440 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1466 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { }
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/ctype_inline.h" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/ctype_inline.h" 3
namespace std
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }


  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }


}
# 1539 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 2 3

namespace std
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1669 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1707 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1721 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1735 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1748 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1779 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1792 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1805 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1822 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1834 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1847 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1860 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1873 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}
# 1951 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1972 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1998 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2035 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2095 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2138 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2211 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2274 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2292 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2313 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2331 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2373 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2436 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2461 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { }
# 2509 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2567 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.tcc" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.tcc" 3

namespace std
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     if (true)
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     if (false)
       {
  delete __tmp;
                         ;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      if (true)
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      if (false)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
                          ;
 }
    }
# 139 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __num_traits::__is_signed)
   ? -static_cast<__unsigned_type>(__num_traits::__min)
   : __num_traits::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative && __num_traits::__is_signed)
       __v = __num_traits::__min;
     else
       __v = __num_traits::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1206 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2656 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/locale_facets.h" 2 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 2 3



namespace std
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
                          ;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.tcc" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/basic_ios.h" 2 3
# 45 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ios" 2 3
# 39 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 2 3


namespace std
{
# 57 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      __ostream_type&
      flush();
# 357 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      pos_type
      tellp();
# 368 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 425 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 444 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 454 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 473 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 495 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 537 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 588 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 600 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 674 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ostream.tcc" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/ostream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     if (true)
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
                         ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   if (true)
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   if (true)
     { _M_write(__s, __n); }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      if (true)
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (true)
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      if (false)
 {
   this->_M_setstate(ios_base::badbit);
                          ;
 }
      if (false)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   if (true)
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   if (false)
     {
       __out._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 694 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ostream" 2 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iostream" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3




namespace std
{
# 57 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      int_type
      get();
# 315 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      int_type
      peek();
# 485 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      unget();
# 555 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      int
      sync();
# 570 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      pos_type
      tellg();
# 585 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/istream.tcc" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/istream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 if (true)
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 if (false)
   {
     __in._M_setstate(ios_base::badbit);
                            ;
   }
 if (false)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     if (true)
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     if (false)
       {
  this->_M_setstate(ios_base::badbit);
                         ;
       }
     if (false)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   if (true)
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::failbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
          if (false)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   if (true)
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   if (false)
     {
       this->_M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   if (true)
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   if (true)
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   if (false)
     {
       __in._M_setstate(ios_base::badbit);
                              ;
     }
   if (false)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\istream" 2 3
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iostream" 2 3

namespace std
{
# 60 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 2 "firmware/myproject.cpp" 2

# 1 "firmware/myproject.h" 1



# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h" 1








# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_common.h" 1
# 41 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_common.h"
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_decl.h" 1
# 54 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_decl.h"
enum ap_q_mode {
  AP_RND,
  AP_RND_ZERO,
  AP_RND_MIN_INF,
  AP_RND_INF,
  AP_RND_CONV,
  AP_TRN,
  AP_TRN_ZERO,
};
# 76 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_decl.h"
enum ap_o_mode {
  AP_SAT,
  AP_SAT_ZERO,
  AP_SAT_SYM,
  AP_WRAP,
  AP_WRAP_SM,
};
# 133 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_decl.h"
template <int _AP_W, bool _AP_S>
struct ap_int_base;

template <int _AP_W>
struct ap_int;

template <int _AP_W>
struct ap_uint;

template <int _AP_W, bool _AP_S>
struct ap_range_ref;

template <int _AP_W, bool _AP_S>
struct ap_bit_ref;

template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref;

template <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed_base;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_ufixed;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref;


enum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };
# 187 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_decl.h"
typedef signed long long ap_slong;
typedef unsigned long long ap_ulong;


enum {
  _AP_SIZE_char = 8,
  _AP_SIZE_short = sizeof(short) * 8,
  _AP_SIZE_int = sizeof(int) * 8,
  _AP_SIZE_long = sizeof(long) * 8,
  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8
};
# 42 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_common.h" 2
# 164 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_common.h"
enum { CHAR_IS_SIGNED = (char)-1 < 0 };


namespace _ap_type {
template <typename _Tp>
struct is_signed {
  static const bool value = _Tp(-1) < _Tp(1);
};

template <typename _Tp>
struct is_integral {
  static const bool value = false;
};





template <> struct is_integral<bool> { static const bool value = true; };
template <> struct is_integral<char> { static const bool value = true; };
template <> struct is_integral<signed char> { static const bool value = true; };
template <> struct is_integral<unsigned char> { static const bool value = true; };
template <> struct is_integral<short> { static const bool value = true; };
template <> struct is_integral<unsigned short> { static const bool value = true; };
template <> struct is_integral<int> { static const bool value = true; };
template <> struct is_integral<unsigned int> { static const bool value = true; };
template <> struct is_integral<long> { static const bool value = true; };
template <> struct is_integral<unsigned long> { static const bool value = true; };
template <> struct is_integral<ap_slong> { static const bool value = true; };
template <> struct is_integral<ap_ulong> { static const bool value = true; };


template <bool, typename _Tp = void>
struct enable_if {};

template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};
}
# 507 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_common.h"
template <int _AP_N, bool _AP_S>
struct ssdm_int;

template <int _AP_N>
struct ssdm_int<_AP_N, true> {
  typedef int __attribute__((bitwidth(_AP_N))) DataType;
  int V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, true>() = default;
                inline __attribute__((always_inline)) ssdm_int<_AP_N, true>(int o __attribute__((bitwidth(_AP_N)))):V(o){};
};

template <int _AP_N>
struct ssdm_int<_AP_N, false> {
  typedef unsigned __attribute__((bitwidth(_AP_N))) DataType;
  unsigned V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, false>() = default;
                inline __attribute__((always_inline)) ssdm_int<_AP_N, false>(unsigned o __attribute__((bitwidth(_AP_N)))):V(o){};
};
# 575 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_common.h"
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/autopilot_ssdm_bits.h" 1
# 576 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_common.h" 2

extern "C" void _ssdm_string2bits(...);
# 587 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_common.h"
static inline unsigned char guess_radix(const char* s) {
  unsigned char rd = 10;
  const char* p = s;

  if (p[0] == '-' || p[0] == '+') ++p;

  if (p[0] == '0') {
    if (p[1] == 'b' || p[1] == 'B') {
      rd = 2;
    } else if (p[1] == 'o' || p[1] == 'O') {
      rd = 8;
    } else if (p[1] == 'x' || p[1] == 'X') {
      rd = 16;
    } else if (p[1] == 'd' || p[1] == 'D') {
      rd = 10;
    }
  }
  return rd;
}







typedef __fp16 half;
# 710 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_common.h"
inline __attribute__((always_inline)) ap_ulong doubleToRawBits(double pf) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned int floatToRawBits(float pf) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned short halfToRawBits(half pf) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__D = pf;
  return LD.__L;



}


inline __attribute__((always_inline)) double rawBitsToDouble(ap_ulong pi) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) float rawBitsToFloat(unsigned long pi) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) half rawBitsToHalf(unsigned short pi) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__L = pi;
  return LD.__D;






}
# 10 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h" 1
# 16 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h" 1
# 11 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h"
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h" 1
# 56 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_N, bool _AP_S>
struct retval;


template <int _AP_N>
struct retval<_AP_N, true> {
  typedef ap_slong Type;
};

template <int _AP_N>
struct retval<_AP_N, false> {
  typedef ap_ulong Type;
};


template <>
struct retval<1, true> {
  typedef signed char Type;
};

template <>
struct retval<1, false> {
  typedef unsigned char Type;
};


template <>
struct retval<2, true> {
  typedef short Type;
};

template <>
struct retval<2, false> {
  typedef unsigned short Type;
};


template <>
struct retval<3, true> {
  typedef long Type;
};

template <>
struct retval<3, false> {
  typedef unsigned long Type;
};

template <>
struct retval<4, true> {
  typedef long Type;
};

template <>
struct retval<4, false> {
  typedef unsigned long Type;
};




template <int _AP_W2, bool _AP_S2>
struct _ap_int_factory;
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };

template <int _AP_W, bool _AP_S>
struct ap_int_base : public ssdm_int<_AP_W, _AP_S> {
 static_assert(_AP_W > 0, "ap_int_base bitwidth must be positive");

 private:
                inline __attribute__((always_inline)) __attribute__((nodebug)) int countLeadingOnes() const {




    return 0;

  }

 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;







  typedef typename retval<(((_AP_W + 7) / 8) > (8) ? ((_AP_W + 7) / 8) : (8)), _AP_S>::Type RetType;

  static const int width = _AP_W;
  static const bool sign_flag = _AP_S;

  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };


    typedef ap_int_base<mult_w, mult_s> mult_base;
    typedef ap_int_base<plus_w, plus_s> plus_base;
    typedef ap_int_base<minus_w, minus_s> minus_base;
    typedef ap_int_base<logic_w, logic_s> logic_base;
    typedef ap_int_base<div_w, div_s> div_base;
    typedef ap_int_base<mod_w, mod_s> mod_base;
    typedef ap_int_base<_AP_W, _AP_S> arg1_base;

    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;
    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;
    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;
    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;
    typedef typename _ap_int_factory<div_w, div_s>::type div;
    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;
    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;
    typedef bool reduce;
  };





  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base() = default;


  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op.V) {
    Base::V = op.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }
# 220 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const bool op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const signed char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const unsigned char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const short op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const unsigned short op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const int op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const unsigned int op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const long op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const unsigned long op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_slong op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_ulong op):Base(op) { Base::V = op; }




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(half op) {
    ap_int_base<_AP_W, _AP_S> t((float)op);
    Base::V = t.V;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(float op) {
    const int BITS = 23 + 8 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = floatToRawBits(op);
    bool is_neg = ({ __typeof__(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<8 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 23, BITS - 2); __Result__; });
    exp = exp - ((1 << (8 - 1)) - 1);

    ap_int_base<23 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 23 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23); __Result__; });


    if ((reg.V & 0x7ffffffful) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 23 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 23 + 2) {
          ap_int_base<23 + 2, true> man_shift;
          man_shift.V = (man.V >> sh_amt);






          Base::V = man_shift.V;
        } else {



            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {



          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(double op) {
    const int BITS = 52 + 11 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = doubleToRawBits(op);
    bool is_neg = ({ __typeof__(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<11 + 1, true> exp, bias = ((1 << (11 - 1)) - 1);
    exp.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, BITS - 2); __Result__; });
    exp = exp - bias;

    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(reg.V)>::type __Result__ = 0; __typeof__(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });


    if ((reg.V & 0x7fffffffffffffffull) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 52 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 52 + 2) {
          ap_int_base<23 + 2, true> man_shift;
          man_shift.V = (man.V >> sh_amt);






          Base::V = man_shift.V;
        } else {



           Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {



          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    op.checkOverflowCsimFix(_AP_W, _AP_S);
    Base::V = op.to_ap_int_base().V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = (ref.get()).V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = ref.operator bool();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {
    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,
                      false>
        tmp = ref.get();
    Base::V = tmp.V;
  }
# 399 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const char* s) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(const char* s, signed char rd) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = (val.get()).V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = val.operator bool();
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base read() volatile {

    ap_int_base ret;
    ret.V = Base::V;
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {

    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }


  ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) = default;
# 493 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(bool op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(signed char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(unsigned char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(unsigned short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(unsigned int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(unsigned long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(ap_slong op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(ap_ulong op) { Base::V = op; return *this; }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (bool)op2;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
    return *this;
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {
    Base::V = op2.get().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = (bool)op;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
    return *this;
  }





                inline __attribute__((always_inline)) __attribute__((nodebug)) operator RetType() const { return (RetType)(Base::V); }




                inline __attribute__((always_inline)) __attribute__((nodebug)) bool to_bool() const { return (bool)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) char to_char() const { return (char)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) signed char to_schar() const { return (signed char)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned char to_uchar() const { return (unsigned char)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) short to_short() const { return (short)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned short to_ushort() const { return (unsigned short)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) int to_int() const { return (int)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned to_uint() const { return (unsigned)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) long to_long() const { return (long)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned long to_ulong() const { return (unsigned long)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_slong to_int64() const { return (ap_slong)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) half to_half() const { return (float)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) float to_float() const { return (float)(Base::V); }
                inline __attribute__((always_inline)) __attribute__((nodebug)) double to_double() const { return (double)(Base::V); }
# 598 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const volatile { return _AP_W; }
                inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return _AP_W; }


                inline __attribute__((always_inline)) __attribute__((nodebug)) bool iszero() const { return Base::V == 0; }


                inline __attribute__((always_inline)) __attribute__((nodebug)) bool is_zero() const { return Base::V == 0; }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool sign() const {
    if (_AP_S &&
        ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }))
      return true;
    else
      return false;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void clear(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void invert(int i) {
                                                           ;
    bool val = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    if (val)
      Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    else
      Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool test(int i) const {
                                                           ;
    return ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& get() { return *this; }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(int i, bool v) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& lrotate(int n) {
                                                              ;


    __typeof__(Base::V) l_p = Base::V << n;
    __typeof__(Base::V) r_p = Base::V >> (_AP_W - n);
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& rrotate(int n) {
                                                              ;


    __typeof__(Base::V) l_p = Base::V << (_AP_W - n);
    __typeof__(Base::V) r_p = Base::V >> n;
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& reverse() {
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void set_bit(int i, bool v) {
    Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) bool get_bit(int i) const {
    return (bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void b_not() { Base::V = ~Base::V; }

  template<typename T>
                inline __attribute__((always_inline)) __attribute__((nodebug)) void checkOverflowBaseC(T val) {
# 769 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
    (void)val;

    return;
  }

                inline __attribute__((always_inline)) __attribute__((nodebug)) bool checkOverflowCsim(int _ap_w2, bool _ap_s2,
          bool print = true) const {
# 819 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
      (void)_ap_w2;
      (void)_ap_s2;
      (void)print;

      return 0;
  }
# 853 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator *=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V *= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator +=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V += op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator -=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V -= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator /=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V /= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator %=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V %= op2.V; return *this; }
# 871 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator &=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V &= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator |=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V |= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator ^=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V ^= op2.V; return *this; }





  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator++() {
    operator+=((ap_int_base<1, false>)1);
    return *this;
  }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator--() {
    operator-=((ap_int_base<1, false>)1);
    return *this;
  }




  inline __attribute__((always_inline)) __attribute__((nodebug)) const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {
    ap_int_base t = *this;
    operator+=((ap_int_base<1, false>)1);
    return t;
  }
  inline __attribute__((always_inline)) __attribute__((nodebug)) const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {
    ap_int_base t = *this;
    operator-=((ap_int_base<1, false>)1);
    return t;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }


                inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<1, false>::minus operator-() const {
    return ap_int_base<1, false>(0) - *this;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!() const { return Base::V == 0; }





                inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator~() const {
    ap_int_base<_AP_W, _AP_S> r(0);
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>(sh);
    } else
      return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r(0);
    r.V = Base::V << op2.to_uint();
    return r;
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<(sh);
    }
    return operator>>(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r(0);
    r.V = Base::V >> op2.to_uint();
    return r;
  }
# 982 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>=(sh);
    } else
      return operator<<=(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V <<= op2.to_uint();
    return *this;
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ __typeof__(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<=(sh);
    }
    return operator>>=(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V >>= op2.to_uint();
    return *this;
  }
# 1031 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V == op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return !(Base::V == op2.V);
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V < op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V >= op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V > op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V <= op2.V;
  }




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }
# 1140 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W, _AP_S> operator[](int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W, _AP_S> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator[](int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());
    return br.to_bool();
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W, _AP_S> bit(int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W, _AP_S> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool bit(int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {
    return bit(index.to_int());
  }
# 1207 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
                inline __attribute__((always_inline)) __attribute__((nodebug)) int countLeadingZeros() const {

    return __fpga_ctlz(this->V);



  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator&(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this & a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator|(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this | a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator^(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this ^ a2.get();
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W3, false>& val) {
    Base::V = val.V;
  }





  inline __attribute__((always_inline)) __attribute__((nodebug)) bool and_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool nand_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool or_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool nor_reduce() const { return !(({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); })); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool xor_reduce() const { return ({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool xnor_reduce() const {
    return !(({ __typeof__(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
  }
# 1416 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string(signed char rd = 2, bool sign = _AP_S) const {
    (void)(rd);
    (void)(sign);
    return 0;
  }

};
# 1477 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base ret(0); ret.V = lhs.V * rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base ret(0); ret.V = lhs.V + rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base ret(0); ret.V = lhs.V - rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V & rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V | rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V ^ rhs.V; return ret; }
# 1496 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::div_base ret(0); ret.V = op.V / op2.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mod_base ret(0); ret.V = op.V % op2.V; return ret; }
# 1524 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) PTR_TYPE* operator +(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) PTR_TYPE* operator -(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 - i_op; }
# 1553 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator *(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator *(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator /(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator /(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator +(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator +(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator -(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float operator -(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator *(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator *(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator /(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator /(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator +(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator +(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator -(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double operator -(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1578 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator *(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator *(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator /(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator /(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator +(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator +(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator -(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half operator -(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1610 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op * ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op + ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op - ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op / ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op % ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op & ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op | ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op ^ ap_int_base<1, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op * ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op + ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op - ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op / ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op % ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op & ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op | ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op ^ ap_int_base<8, CHAR_IS_SIGNED>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op * ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op + ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op - ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op / ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op % ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op & ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op | ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op ^ ap_int_base<8, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op * ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op + ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op - ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op / ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op % ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op & ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op | ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op ^ ap_int_base<8, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op * ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op + ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op - ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op / ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op % ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op & ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op | ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op ^ ap_int_base<_AP_SIZE_short, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op * ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op + ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op - ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op / ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op % ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op & ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op | ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op ^ ap_int_base<_AP_SIZE_short, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op * ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op + ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op - ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op / ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op % ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op & ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op | ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op ^ ap_int_base<_AP_SIZE_int, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op * ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op + ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op - ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op / ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op % ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op & ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op | ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op ^ ap_int_base<_AP_SIZE_int, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op * ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op + ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op - ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op / ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op % ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op & ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op | ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op ^ ap_int_base<_AP_SIZE_long, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op * ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op + ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op - ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op / ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op % ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op & ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op | ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op ^ ap_int_base<_AP_SIZE_long, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, false>(i_op); }
# 1649 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
# 1673 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
# 1704 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op += ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op -= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op *= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op /= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op %= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op &= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op |= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op ^= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >>= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <<= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op += ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op -= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op *= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op /= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op %= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op &= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op |= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op ^= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >>= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <<= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op += ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op -= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op *= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op /= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op %= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op &= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op |= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op ^= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >>= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <<= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op += ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op -= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op *= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op /= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op %= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op &= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op |= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op ^= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >>= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <<= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op += ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op -= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op *= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op /= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op %= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op &= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op |= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op ^= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >>= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <<= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op += ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op -= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op *= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op /= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op %= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op &= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op |= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op ^= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >>= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <<= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op += ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op -= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op *= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op /= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op %= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op &= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op |= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op ^= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >>= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <<= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op += ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op -= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op *= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op /= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op %= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op &= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op |= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op ^= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >>= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <<= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op += ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op -= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op *= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op /= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op %= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op &= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op |= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op ^= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >>= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <<= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op += ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op -= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op *= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op /= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op %= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op &= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op |= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op ^= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >>= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <<= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1737 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half& operator +=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half& operator -=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half& operator *=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) half& operator /=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float& operator +=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float& operator -=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float& operator *=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) float& operator /=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double& operator +=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double& operator -=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double& operator *=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) double& operator /=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 /= op_rt; }
# 1765 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1802 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; }
# 1832 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<_AP_W2, false>(op2); }
# 1863 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator +=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator -=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator *=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator /=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator %=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator >>=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator <<=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1895 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator &=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator |=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W1, _AP_S1>& operator ^=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1914 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_int_base<_AP_W2, false>()); }
# 1941 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) + op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) - op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) * op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) / op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) % op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) & op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) | op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) ^ op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >> op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) << op2; }
# 1972 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator +=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator -=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator *=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator /=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator %=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator >>=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator <<=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 2004 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator &=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator |=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref<_AP_W1, _AP_S1>& operator ^=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 2023 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 == ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) == op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 != ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) != op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 > ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) > op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >= op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 < ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) < op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) <= op2; }
# 2130 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_base.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 == op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() == op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 != op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() != op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 > op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() > op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 >= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() >= op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 < op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() < op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 <= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() <= op2; }
# 12 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h" 1
# 27 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
  enum {
    _AP_WR = _AP_W1 + _AP_W2,
  };

  _AP_T1& mbv1;
  _AP_T2& mbv2;

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)
      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> Part1;
    Part1.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(Part1);
    ap_int_base<_AP_W2, false> Part2;
    Part2.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(Part2);
    return *this;
  }
# 70 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(bool val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(signed char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(unsigned char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(unsigned short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(unsigned int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(unsigned long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(ap_slong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(ap_ulong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(half val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(float val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(double val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }





  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }
  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((const ap_int_base<_AP_W3, false>)(val));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&
          val) {
    return operator=(val.to_ap_int_base());
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref& operator=(
      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((ap_ulong)(bool)(val));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_int_base<_AP_WR, false>() const { return get(); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_ulong() const { return get().to_uint64(); }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                       ap_range_ref<_AP_W3, _AP_S3> >
  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_range_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {

    ap_int_base<_AP_W3, _AP_S3> op(a2);
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >
  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(
        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      _AP_WR, ap_concat_ref, _AP_W3,
      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
  operator,(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, _AP_W3,
        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<
            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_WR, ap_concat_ref, 1,
                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>
                    &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, 1,
        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(
            a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator&(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() & a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator|(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() | a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator^(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() ^ a2;
  }
# 258 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_WR, false> get() const {
    ap_int_base<_AP_WR, false> tmpVal(0);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W2, false> v2(mbv2);
    ap_int_base<_AP_W1, false> v1(mbv1);
    tmpVal.V = ({ typename _ap_type::remove_const<__typeof__(tmpVal.V)>::type __Result__ = 0; __typeof__(tmpVal.V) __Val2__ = tmpVal.V; __typeof__(v2.V) __Repl2__ = v2.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, W_ref2 - 1); __Result__; });
    tmpVal.V =
        ({ typename _ap_type::remove_const<__typeof__(tmpVal.V)>::type __Result__ = 0; __typeof__(tmpVal.V) __Val2__ = tmpVal.V; __typeof__(v1.V) __Repl2__ = v1.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    return tmpVal;
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W3, false>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> tmpVal1;
    tmpVal1.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(tmpVal1);
    ap_int_base<_AP_W2, false> tmpVal2;
    tmpVal2.V = ({ typename _ap_type::remove_const<__typeof__(vval.V)>::type __Result__ = 0; __typeof__(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(tmpVal2);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return mbv1.length() + mbv2.length(); }
};




template <int _AP_W, bool _AP_S>
struct ap_range_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_ulong() const { return to_uint64(); }
# 339 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(bool val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(signed char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(unsigned char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(unsigned short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(unsigned int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(unsigned long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(ap_slong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(ap_ulong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(half val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(float val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(double val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const ap_range_ref& val) {
    return operator=((const ap_int_base<_AP_W, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    return operator=(val.to_ap_int_base());
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug))
  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >
  operator,(ap_int_base<_AP_W, _AP_S>& a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                         ap_int_base<_AP_W, _AP_S> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      _AP_W, ap_range_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, ap_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop == hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop < hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop <= hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<=(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= op2.V;
    return *this;
  };



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned to_uint() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (unsigned)(({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned long to_ulong() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (unsigned long)(({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ulong to_uint64() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (ap_ulong)(({ typename _ap_type::remove_const<__typeof__(t.V)>::type __Result__ = 0; __typeof__(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool and_reduce() const {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_676_1: for (unsigned i = low; i != high+1; ++i) {

#pragma HLS unroll

 ret &= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool or_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_690_1: for (unsigned i = low; i != high+1; ++i) {

#pragma HLS unroll

 ret |= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool xor_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_704_1: for (unsigned i = low; i != high+1; ++i) {

#pragma HLS unroll

 ret ^= ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }
# 720 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string(signed char radix = 2) const {
    (void)(radix);
    return 0;
  }

};
# 760 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int d_index;

 public:

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool to_bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
# 798 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(bool val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(signed char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(unsigned char val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(short val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(unsigned short val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(int val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(unsigned int val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(long val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(unsigned long val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(ap_slong val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(ap_ulong val) { d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
# 820 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(half val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(float val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(double val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(val.V != 0));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_int_base<_AP_W2, false>)val);
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(const ap_bit_ref& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      1, ap_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        1, ap_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() != op.get();
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool get() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool get() { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  template <int _AP_W3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W3, false>& val) {
    operator=(val);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator~() const {
    bool bit = ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return 1; }

  template <typename _RT>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator&=(const _RT& r) {
    operator=(get() & ap_int_base<1, false>(r));
    return *this;
  }

  template <typename _RT>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator|=(const _RT& r) {
    operator=(get() | ap_int_base<1, false>(r));
    return *this;
  }

  template <typename _RT>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_bit_ref& operator^=(const _RT& r) {
    operator=(get() ^ ap_int_base<1, false>(r));
    return *this;
  }





  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string() const { return 0; }

};
# 1036 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }






template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1095 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::div operator /(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::div operator /(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::div operator /(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
# 1118 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
# 1146 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())+( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())-( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())*( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())/( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())%( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())&( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())|( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())^( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())>>( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())<<( rhs.operator ap_int_base<_AP_W2, false>()); }
# 1195 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::plus operator +( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::minus operator -( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mult operator *( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::div operator /( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mod operator %( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator &( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator |( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator ^( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator >>( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator <<( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
# 1342 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 1, false> operator,( bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 1, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 1, false> operator,( bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op2); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op1); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<8 + 1, false> operator,( unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + 8, false> operator,( unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_short + 1, false> operator,( short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_short, false> operator,( short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_short + 1, false> operator,( unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_short, false> operator,( unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_int + 1, false> operator,( int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_int, false> operator,( int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_int + 1, false> operator,( unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_int, false> operator,( unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_long + 1, false> operator,( long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_long, false> operator,( long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_long + 1, false> operator,( unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_long, false> operator,( unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
# 1366 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_ref.h"
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }

template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
# 13 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h" 2




template <int _AP_W>
struct ap_int : ap_int_base<_AP_W, true> {
  static_assert(_AP_W > 0, "ap_int bitwidth must be positive");

  typedef ap_int_base<_AP_W, true> Base;

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int() = default;
  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_int<_AP_W2>& op): Base((ap_int_base<_AP_W2, true>)op){



    op.checkOverflowCsim(_AP_W, true);

    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const volatile ap_int<_AP_W2>& op) {
    const_cast<const ap_int<_AP_W2>& >(op).checkOverflowCsim(_AP_W, true);
    Base::V = op.V;
  }

  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_uint<_AP_W2>& op): Base((ap_int_base<_AP_W2, false>)op){



    op.checkOverflowCsim(_AP_W, true);

    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const volatile ap_uint<_AP_W2>& op) {
    const_cast<const ap_uint<_AP_W2>& >(op).checkOverflowCsim(_AP_W, true);
    Base::V = op.V;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned V __attribute__((bitwidth(_AP_W))), bool raw): Base(0) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op) {

  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}







  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(bool val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(signed char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(short val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned short val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(int val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned int val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(long val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned long val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(ap_slong val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(ap_ulong val):Base(val){ this->checkOverflowBaseC(val); }

                ap_int(double val) : Base(val) {}
                ap_int(float val) : Base(val) {}
  ap_int(half val) : Base(val) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const char* s, signed char rd) : Base(s, rd) {}




  ap_int &operator=(const ap_int<_AP_W> &op2) = default;
# 163 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int& operator=(const volatile ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_int<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const volatile ap_int<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

};




template <int _AP_W>
struct ap_uint : ap_int_base<_AP_W, false> {
  static_assert(_AP_W > 0, "ap_uint bitwidth must be positive");

  typedef ap_int_base<_AP_W, false> Base;

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint() = default;
  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_uint<_AP_W2>& op):Base((ap_int_base<_AP_W2, false>)op) {
    op.checkOverflowCsim(_AP_W, false);

  }

  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_int<_AP_W2>& op):Base((ap_int_base<_AP_W2, true>)op) {
    op.checkOverflowCsim(_AP_W, false);

  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const volatile ap_uint<_AP_W2>& op) {
    const_cast<const ap_uint<_AP_W2>& >(op).checkOverflowCsim(_AP_W, false);
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const volatile ap_int<_AP_W2>& op) {
    const_cast<const ap_int<_AP_W2>& >(op).checkOverflowCsim(_AP_W, false);
    Base::V = op.V;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned V __attribute__((bitwidth(_AP_W))), bool raw):Base(0) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op) {

  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}






  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(bool val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(signed char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(short val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned short val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(int val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned int val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(long val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned long val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(ap_slong val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(ap_ulong val):Base(val) { this->checkOverflowBaseC(val); }

                ap_uint(double val) : Base(val) {}
                ap_uint(float val) : Base(val) {}
  ap_uint(half val) : Base(val) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const char* s, signed char rd) : Base(s, rd) {}





  ap_uint &operator=(const ap_uint<_AP_W> &op2) = default;
# 321 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_uint<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const volatile ap_uint<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

};
# 356 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h"
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_special.h" 1
# 20 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 48 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_special.h"
template <int _AP_W>
class complex<ap_int<_AP_W> > {
 public:
  typedef ap_int<_AP_W> _Tp;
  typedef _Tp value_type;




  __attribute__((nodebug)) complex() = default;


  __attribute__((nodebug)) complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  __attribute__((nodebug)) complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  __attribute__((nodebug)) const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  __attribute__((nodebug)) void real(_Tp __val) { _M_real = __val; }

  __attribute__((nodebug)) void imag(_Tp __val) { _M_imag = __val; }



  __attribute__((nodebug)) complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 181 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_int_special.h"
template <int _AP_W>
inline __attribute__((nodebug)) bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W>
inline __attribute__((nodebug)) bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W>
inline __attribute__((nodebug)) bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W>
inline __attribute__((nodebug)) bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 357 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h" 2
# 17 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h" 2
# 87 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
template <int _AP_W2, int _AP_I2, bool _AP_S2>
struct _ap_fixed_factory;
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, true> {
  typedef ap_fixed<_AP_W2, _AP_I2> type;
};
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, false> {
  typedef ap_ufixed<_AP_W2, _AP_I2> type;
};
# 108 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct ap_fixed_base : ssdm_int<_AP_W, _AP_S> {
 static_assert(_AP_W > 0, "ap_fixed_base bitwidth must be positive");

 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;
  static const int width = _AP_W;
  static const int iwidth = _AP_I;
  static const ap_q_mode qmode = _AP_Q;
  static const ap_o_mode omode = _AP_O;


  template <int _AP_W2, int _AP_I2, bool _AP_S2>
  struct RType {
    enum {
      _AP_F = _AP_W - _AP_I,
      F2 = _AP_W2 - _AP_I2,
      mult_w = _AP_W + _AP_W2,
      mult_i = _AP_I + _AP_I2,
      mult_s = _AP_S || _AP_S2,
      plus_w = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
               1 + ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      plus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1 +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      minus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,

      div_w = _AP_S2 + _AP_W + ((F2) > (0) ? (F2) : (0)),



      div_i = _AP_S2 + _AP_I + F2,
      div_s = _AP_S || _AP_S2,
      logic_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      logic_i = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };

    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;
    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;

    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;
    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;
    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;
    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;
    typedef ap_fixed_base<div_w, div_i, div_s> div_base;
    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;

    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;
    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;
    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;
    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;
    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;
    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;
  };

 private:
# 297 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
                      inline __attribute__((always_inline)) __attribute__((nodebug)) void report() {}




                      inline __attribute__((always_inline)) __attribute__((nodebug)) void overflow_adjust(bool underflow, bool overflow, bool lD,
                              bool sign) {
    if (!underflow && !overflow) return;
    if (_AP_O == AP_WRAP) {
      if (_AP_N == 0) return;
      if (_AP_S) {


        Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        if (_AP_N > 1) {

          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
      } else {

        ap_int_base<_AP_W, false> mask(-1);
        Base::V =
            ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 1); __Result__; });
      }
    } else if (_AP_O == AP_SAT_ZERO) {
      Base::V = 0;
    } else if (_AP_O == AP_WRAP_SM && _AP_S) {
      bool Ro = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      if (_AP_N == 0) {
        if (lD != Ro) {
          Base::V = ~Base::V;
          Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(lD) __Repl2__ = !!lD; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        }
      } else {
        if (_AP_N == 1 && sign != Ro) {
          Base::V = ~Base::V;
        } else if (_AP_N > 1) {
          bool lNo = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - _AP_N); __Result__; });
          if (lNo == sign) Base::V = ~Base::V;
          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
        Base::V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __typeof__(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
      }
    } else {
      if (_AP_S) {
        if (overflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          Base::V = ~Base::V;
        } else if (underflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          if (_AP_O == AP_SAT_SYM) Base::V |= 1;
        }
      } else {
        if (overflow)
          Base::V = ~(ap_int_base<_AP_W, false>(0).V);
        else if (underflow)
          Base::V = 0;
      }
    }
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool quantization_adjust(bool qb, bool r, bool s) {
    bool carry = (bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    if (_AP_Q == AP_TRN) return false;
    if (_AP_Q == AP_RND_ZERO)
      qb &= s || r;
    else if (_AP_Q == AP_RND_MIN_INF)
      qb &= r;
    else if (_AP_Q == AP_RND_INF)
      qb &= !s || r;
    else if (_AP_Q == AP_RND_CONV)
      qb &= ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 0); __Result__; }) || r;
    else if (_AP_Q == AP_TRN_ZERO)
      qb = s && (qb || r);
    Base::V += qb;
    return carry && (!(bool)({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }));
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) int countLeadingOnes() const {




    return 0;

  }

 public:



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base() = default;


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.V) {

    operator=(op);



    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op.V) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp(0);
    tmp.V = op.V;

    operator=(tmp);



    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }
# 460 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const char* s) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const char* s, signed char rd) {
    __typeof__(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    *this = ((bool)op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (bool(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }
# 528 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const bool x) { ap_fixed_base<(1), (1), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const char x) { ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const signed char x) { ap_fixed_base<(8), (8), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const unsigned char x) { ap_fixed_base<(8), (8), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const unsigned short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const unsigned int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const unsigned long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_slong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(const ap_ulong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)> tmp; tmp.V = x; *this = tmp; }







          __attribute__((nodebug)) ap_fixed_base(double d) {
    ap_int_base<64, false> ireg;
    ireg.V = doubleToRawBits(d);
    bool isneg = ({ __typeof__(ireg.V) __Val2__ = ireg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 63); __Result__; });

    ap_int_base<11 + 1, true> exp, bias = ((1 << (11 - 1)) - 1);
    ap_int_base<11, false> exp_tmp;
    exp_tmp.V = ({ typename _ap_type::remove_const<__typeof__(ireg.V)>::type __Result__ = 0; __typeof__(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, 52 + 11 - 1); __Result__; });
    exp = exp_tmp - bias;
    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<__typeof__(ireg.V)>::type __Result__ = 0; __typeof__(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });


    (static_cast<void>(0));

    man.V = ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __typeof__(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });
    if (isneg) man = -man;
    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {
      Base::V = 0;
    } else {
      int _AP_W2 = 52 + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,
          F2 = _AP_W2 - _AP_I2;
      bool _AP_S2 = true,
           QUAN_INC = F2 > _AP_F &&
                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));
      bool carry = false;

      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
      if (F2 == _AP_F)
        Base::V = man.V;
      else if (F2 > _AP_F) {
        if (sh_amt < 52 + 2)
          Base::V = man.V >> sh_amt;
        else {
          Base::V = isneg ? -1 : 0;
        }
        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {
          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)({ __typeof__(man.V) __Val2__ = man.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

          bool r =
              (F2 > _AP_F + 1)
                  ? ({ typename _ap_type::remove_const<__typeof__(man.V)>::type __Result__ = 0; __typeof__(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, (F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1)); __Result__; }) != 0


                  : false;
          carry = quantization_adjust(qb, r, isneg);
        }
      } else {
        Base::V = man.V;
        if (sh_amt < _AP_W)
          Base::V = Base::V << sh_amt;
        else
          Base::V = 0;
      }

      if ((_AP_O != AP_WRAP || _AP_N != 0) &&
          ((!_AP_S && _AP_S2) ||
           _AP_I - _AP_S <
               _AP_I2 - _AP_S2 +
                   (QUAN_INC ||
                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) {
        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;
        bool neg_src = isneg;
        bool lD = false;
        int pos1 = F2 - _AP_F + _AP_W;
        int pos2 = F2 - _AP_F + _AP_W + 1;
        bool newsignbit = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
        if (pos1 < _AP_W2 && pos1 >= 0)

          lD = (man.V >> pos1) & 1;
        if (pos1 < _AP_W2) {
          bool Range1_all_ones = true;
          bool Range1_all_zeros = true;
          bool Range2_all_ones = true;
          ap_int_base<52 + 2, false> Range2;
          ap_int_base<52 + 2, false> all_ones(-1);

          if (pos2 >= 0 && pos2 < _AP_W2) {


            Range2.V = man.V;
            Range2.V >>= pos2;
            Range2_all_ones = Range2 == (all_ones >> pos2);
          } else if (pos2 < 0)
            Range2_all_ones = false;
          if (pos1 >= 0 && pos2 < _AP_W2) {
            Range1_all_ones = Range2_all_ones && lD;
            Range1_all_zeros = !Range2.V && !lD;
          } else if (pos2 == _AP_W2) {
            Range1_all_ones = lD;
            Range1_all_zeros = !lD;
          } else if (pos1 < 0) {
            Range1_all_zeros = !man.V;
            Range1_all_ones = false;
          }

          deleted_zeros =
              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
          deleted_ones =
              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
          neg_src = isneg && !(carry && Range1_all_ones);
        } else
          neg_src = isneg && newsignbit;
        bool neg_trg = _AP_S && newsignbit;
        bool overflow = (neg_trg || !deleted_zeros) && !isneg;
        bool underflow = (!neg_trg || !deleted_ones) && neg_src;
        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
          underflow |=
              neg_src &&
              (_AP_W > 1 ? ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                         : true);
        overflow_adjust(underflow, overflow, lD, neg_src);
      }
    }
    report();
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }
# 802 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {

    const int _AP_F = _AP_W - _AP_I;
    const int F2 = _AP_W2 - _AP_I2;
    const int QUAN_INC =
          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));

    if (!op) Base::V = 0;
    bool carry = false;
    bool signbit = ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    bool isneg = signbit && _AP_S2;
    if (F2 == _AP_F)
      Base::V = op.V;
    else if (F2 > _AP_F) {
      unsigned int sh_amt = F2 - _AP_F;

      if (sh_amt < _AP_W2) {
        Base::V = op.V >> sh_amt;
      } else {
        Base::V = isneg ? -1 : 0;
      }
      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {

        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });
        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };

        bool r = (F2 > _AP_F + 1) ? (({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, hi); __Result__; }) != 0) : false;
        carry = quantization_adjust(qb, r, isneg);
      }
    } else {
      unsigned sh_amt = _AP_F - F2;

      if (sh_amt < _AP_W) {
        if (_AP_W > _AP_W2) {

          Base::V = op.V;
          Base::V <<= sh_amt;
        } else {

          Base::V = op.V << sh_amt;
        }
      } else {
        Base::V = 0;
      }
    }

    if ((_AP_O != AP_WRAP || _AP_N != 0) &&
        ((!_AP_S && _AP_S2) ||
         _AP_I - _AP_S <
             _AP_I2 - _AP_S2 +
                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) {
      bool deleted_zeros = _AP_S2 ? true : !carry;
      bool deleted_ones = true;
      bool neg_src = isneg;
      bool newsignbit = ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };
      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? ({ __typeof__(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), pos1); __Result__; })
                                             : false;
      if (pos1 < _AP_W2) {
        bool Range1_all_ones = true;
        bool Range1_all_zeros = true;
        bool Range2_all_ones = true;
        ap_int_base<_AP_W2, false> all_ones(-1);

        if (pos2 < _AP_W2 && pos2 >= 0) {
          ap_int_base<_AP_W2, false> Range2(0);
          Range2.V = ({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos2, _AP_W2 - 1); __Result__; });
          Range2_all_ones = Range2 == (all_ones >> pos2);
        } else if (pos2 < 0) {
          Range2_all_ones = false;
        }

        if (pos1 >= 0 && pos2 < _AP_W2) {
          ap_int_base<_AP_W2, false> Range1(0);
          Range1.V = ({ typename _ap_type::remove_const<__typeof__(op.V)>::type __Result__ = 0; __typeof__(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, _AP_W2 - 1); __Result__; });
          Range1_all_ones = Range1 == (all_ones >> pos1);
          Range1_all_zeros = !Range1.V;
        } else if (pos2 == _AP_W2) {
          Range1_all_ones = lD;
          Range1_all_zeros = !lD;
        } else if (pos1 < 0) {
          Range1_all_zeros = !op.V;
          Range1_all_ones = false;
        }

        deleted_zeros =
            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
        deleted_ones =
            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
        neg_src = isneg && !(carry && Range1_all_ones);
      } else
        neg_src = isneg && newsignbit;
      bool neg_trg = _AP_S && newsignbit;
      bool overflow = (neg_trg || !deleted_zeros) && !isneg;
      bool underflow = (!neg_trg || !deleted_ones) && neg_src;
      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
        underflow |=
            neg_src &&
            (_AP_W > 1 ? ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                       : true);

      overflow_adjust(underflow, overflow, lD, neg_src);
    }
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator=(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));
    return *this;
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& setBits(ap_ulong bv) {

    Base::V = bv;
    return *this;
  }


  static inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base bitsToFixed(ap_ulong bv) {

    ap_fixed_base t;

    t.V = bv;



    return t;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) void checkOverflowCsimFix(int _ap_w2, bool _ap_s2) const {
# 974 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
      (void)_ap_w2;
      (void)_ap_s2;

      return;
  }





                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> to_ap_int_base(
      bool Cnative = true) const {
    ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> ret(0);
    if (_AP_I == 0) {
      ret.V = 0;
    } else if (_AP_I > 0 && _AP_I <= _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_I, _AP_W - 1); __Result__; });
    } else if (_AP_I > _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 1); __Result__; });
      ret.V <<= (_AP_I - _AP_W);
    }
# 1003 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
    if (Cnative && _AP_I < _AP_W) {

      if (_AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }) && (_AP_I < _AP_W) &&
          (({ typename _ap_type::remove_const<__typeof__(Base::V)>::type __Result__ = 0; __typeof__(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1); __Result__; }) != (unsigned long)0))


        ret = ret + 1;
    } else {

    }
    return ret;
  };

 public:
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_int_base<_AP_W2, _AP_S2>() const {
    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) char to_char() const { return to_ap_int_base().to_char(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int to_int() const { return to_ap_int_base().to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned to_uint() const { return to_ap_int_base().to_uint(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_slong to_int64() const { return to_ap_int_base().to_int64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int<_AP_I> to_ap_int() const { return ap_int<_AP_I>(to_ap_int_base()); }



  inline __attribute__((always_inline)) __attribute__((nodebug)) double to_double() const {




    enum { BITS = 52 + 11 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp(0);
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1 << (11 - 1)) - 1);
    int lsb_index = _AP_W - l - 1 - 52;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    ap_ulong m = 0;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))
                           : (ap_ulong)(tmp.V << (1 - lsb_index));
    } else {
      m = (ap_ulong)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;


    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 52 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52 + 11 - 1); __Result__; });


    return rawBitsToDouble(m);
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) float to_float() const {




    enum { BITS = 23 + 8 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1 << (8 - 1)) - 1);
    int lsb_index = _AP_W - l - 1 - 23;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned long m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))
                           : (unsigned long)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned long)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 23 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23 + 8 - 1); __Result__; });

    return rawBitsToFloat(m);
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) half to_half() const {




    enum { BITS = 10 + 5 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1 << (5 - 1)) - 1);
    int lsb_index = _AP_W - l - 1 - 10;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<__typeof__(tmp.V)>::type __Result__ = 0; __typeof__(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ __typeof__(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned short m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))
                           : (unsigned short)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned short)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ __typeof__(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 10 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<__typeof__(m)>::type __Result__ = 0; __typeof__(m) __Val2__ = m; __typeof__(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 10, 10 + 5 - 1); __Result__; });

    return rawBitsToHalf(m);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) operator long double() const { return (long double)to_double(); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator double() const { return to_double(); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator float() const { return to_float(); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator half() const { return to_half(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator bool() const { return (bool)Base::V != 0; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator char() const { return (char)to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator signed char() const { return (signed char)to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator unsigned char() const { return (unsigned char)to_uint(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator short() const { return (short)to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator unsigned short() const { return (unsigned short)to_uint(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator int() const { return to_int(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator unsigned int() const { return to_uint(); }



                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator long() const { return (long)to_int64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator unsigned long() const { return (unsigned long)to_uint64(); }






                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_ulong() const { return to_uint64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_slong() const { return to_int64(); }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return _AP_W; };
# 1232 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
                      inline __attribute__((always_inline)) __attribute__((nodebug)) int countLeadingZeros() const {


    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return t.V == 0 ? _AP_W : __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return t.V == 0 ? _AP_W : __builtin_ctzll(t.V);
    } else {
      enum {__N = (_AP_W + 63) / 64};
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      VITIS_LOOP_1248_1: for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.range(0, 63) = this->range(_AP_W - i * 64 - 64, _AP_W - i * 64 - 1);
        NZeros += hitNonZero ? 0 : (t.V == 0 ? 64 : __builtin_clzll(t.V));
        hitNonZero |= (t != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        t.range(63 - (_AP_W - 1) % 64, 63) = this->range(0, (_AP_W - 1) % 64);
        NZeros += t.V == 0 ? _AP_W % 64 : __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r(0), t(0);
    r.V = Base::V;
    t.V = op2.V;
    r.V *= op2.V;
    return r;
  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;
# 1302 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
        ap_fixed_base<_AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)),_AP_I, _AP_S> t(*this);



        r.V = t.V / op2.V;
# 1335 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
    return r;
  }
# 1350 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::plus_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V + rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::minus_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V - rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V & rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V | rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V ^ rhs.V; return ret; }
# 1368 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator *=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator *(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator /=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator /(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator +=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator +(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator -=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator -(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator &=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator &(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator |=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator |(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator ^=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator ^(op2); return *this; }





  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator++() {
    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator--() {
    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) const ap_fixed_base operator++(int) {
    ap_fixed_base r(*this);
    operator++();
    return r;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) const ap_fixed_base operator--(int) {
    ap_fixed_base r(*this);
    operator--();
    return r;
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type operator+() { return *this; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) typename _ap_fixed_factory<_AP_W + 1, _AP_I + 1, true>::type operator-() const {
    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);
    r.V = -r.V;
    return r;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {
    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);
    r.V = -r.V;
    return r;
  }



                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!() const { return Base::V == (unsigned long)0; }




                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {
    ap_fixed_base<_AP_W, _AP_I, _AP_S> r(0);
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_SHIFT>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {
    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r(0);
    r.V = Base::V;
    return r;
  }

  template <int _AP_SHIFT>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {
    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r(0);
    r.V = Base::V;
    return r;
  }





                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(unsigned int sh) const {
    ap_fixed_base r(0);
    r.V = Base::V << sh;
# 1486 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
    return r;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(unsigned int sh) const {
    ap_fixed_base r(0);
    r.V = Base::V >> sh;
# 1508 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
    return r;
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(int sh) const {
    ap_fixed_base r(0);
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator>>(ush);
    } else {
      return operator<<(ush);
    }
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(int sh) const {
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator<<(ush);
    } else {
      return operator>>(ush);
    }
  }


  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {


    int sh = op2.to_int();
    return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    int sh = op2.to_int();
    return operator>>(sh);
  }


  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator>>(sh);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator<<(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator<<(op2.to_ap_int_base());
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base operator>>(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator>>(op2.to_ap_int_base());
  }





                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator<<=(const int sh) {
    *this = operator<<(sh);
    return *this;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator<<=(const unsigned int sh) {
    *this = operator<<(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator<<=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }


                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator>>=(const int sh) {
    *this = operator>>(sh);
    return *this;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator>>=(const unsigned int sh) {
    *this = operator>>(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base& operator>>=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }
# 1652 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V > op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V < op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V >= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V <= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V == op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V != op2.V; return false; }





  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >(double d) const { return to_double() > d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <(double d) const { return to_double() < d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=(double d) const { return to_double() >= d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=(double d) const { return to_double() <= d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==(double d) const { return to_double() == d; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=(double d) const { return to_double() != d; }


  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator[](unsigned index) const {
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool bit(unsigned index) const {
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(
      const ap_int_base<_AP_W2, true>& index) {
    (static_cast<void>(0));

    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        this, index.to_int() + _AP_W - _AP_I);
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool get_bit(int index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index + _AP_W - _AP_I); __Result__; });

  }
# 1738 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
  template <int _AP_W2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool get_bit(const ap_int_base<_AP_W2, true>& index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ __typeof__(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index.to_int() + _AP_W - _AP_I); __Result__; });

  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,
                                                                      int Lo) {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      int Hi, int Lo) const {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        const_cast<ap_fixed_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool is_zero() const { return Base::V == (unsigned long)0; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) bool is_neg() const {
    if (_AP_S && ({ __typeof__(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; })) return true;
    return false;
  }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int wl() const { return _AP_W; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int iwl() const { return _AP_I; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_q_mode q_mode() const { return _AP_Q; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_o_mode o_mode() const { return _AP_O; }

                      inline __attribute__((always_inline)) __attribute__((nodebug)) int n_bits() const { return _AP_N; }
# 1921 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string(unsigned char radix = 2, bool sign = _AP_S) const {
    (void)(radix);
    (void)(sign);
    return 0;
  }

};

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void b_not(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
  ret.V = ~op.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void b_and(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V & op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void b_or(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V | op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void b_xor(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V ^ op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void neg(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,
                _AP_N2>
      t(0);
  t.V = -op.V;
  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void lshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F2 = _AP_W2 - _AP_I2,
    _AP_I3 = ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)),
    _AP_W3 = _AP_I3 + F2,
  };

  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t(0);
  t.V = op.V;
  t.V <<= i;

  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) void rshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F = _AP_W - _AP_I,
    F2 = _AP_W2 - _AP_I2,
    F3 = ((F) > (F2) ? (F) : (F2)),
    _AP_W3 = _AP_I2 + F3,
    sh = F - F2,
  };

  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t(0);
  t.V = op.V;
  if (sh >= 0)
    t.V <<= (int) sh;
  t.V >>= i;

  ret = t;
}
# 2373 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ==(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator !=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator !=(op); }
# 2461 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::plus operator +( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::minus operator -( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::mult operator *( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::div operator /( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator &( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator |( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator ^( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator +=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator +=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator -=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator -=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator *=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator *=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator /=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator /=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator &=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator &=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator |=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator |=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W2, _AP_S2>& operator ^=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator ^=(op.to_ap_int_base()); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ==(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ==(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator !=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <=(op); }




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator==(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator!=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>=(op1);
}
# 11 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_ref.h" 1
# 25 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int d_index;

 public:
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref(
      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {






  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) operator bool() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }



  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(bool val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
    return *this;
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(const af_bit_ref& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=(val != 0);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));
  }




  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,
                                                                        op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<
      1, af_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        1, af_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() != op.get();
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator~() const {
    bool bit = ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) bool get() const { return ({ __typeof__(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const { return 1; }





  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string() const { return 0; }

};
# 212 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref(
      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}




  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {
# 242 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_ref.h"
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {
# 254 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_ref.h"
  }
# 266 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const bool val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const unsigned char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_slong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_ulong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const half val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const float val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const double val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }



  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }



  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(const af_range_ref& val) {
    ap_int_base<_AP_W, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) af_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);
    return operator=(tmp);
  }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator==(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator!=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator<=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator>=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator<(op2));
  }





  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug))
      ap_concat_ref<_AP_W, af_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_ulong() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret.to_uint64();
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> to_ap_int_base() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) char to_char() const {
    return (char)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned to_uint() const {
    return (unsigned)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned long to_ulong() const {
    return (unsigned long)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ulong to_uint64() const {
    return (ap_ulong)(({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }



  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<__typeof__(d_bv.V)>::type __Result__ = 0; __typeof__(d_bv.V) __Val2__ = d_bv.V; __typeof__(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }
# 615 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_ref.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) char* to_string(signed char rd = 2) const {
     (void)(rd);
    return 0;
  }

};
# 679 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
# 725 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) __attribute__((nodebug)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<1, false>(op); }
# 12 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h" 2





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
  static_assert(_AP_W > 0, "ap_fixed bitwidth must be positive");

  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed() = default;


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                      _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                               _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 68 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 103 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}





                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(bool v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(signed char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(ap_slong v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const char* s, signed char rd) : Base(s, rd) {}







  ap_fixed &
  operator=(const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;
# 170 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed& operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }
};





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
  static_assert(_AP_W > 0, "ap_ufixed bitwidth must be positive");

  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed() = default;


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                       _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                                _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 241 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 273 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}




                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(bool v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(signed char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(ap_slong v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}



  ap_ufixed &
  operator=(const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;
# 331 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed& operator=(
      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                                 _AP_N>& op) volatile {
    Base::V = op.V;
  }
};
# 369 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h"
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_special.h" 1
# 20 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 48 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  __attribute__((nodebug)) complex() = default;


  __attribute__((nodebug)) complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  __attribute__((nodebug)) complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const __attribute__((nodebug)) _Tp& real() const { return _M_real; }
  const __attribute__((nodebug)) _Tp& imag() const { return _M_imag; }







  __attribute__((nodebug)) void real(_Tp __val) { _M_real = __val; }

  __attribute__((nodebug)) void imag(_Tp __val) { _M_imag = __val; }



  __attribute__((nodebug)) complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator=(const complex<_Up> &__z) {
    auto tmp1 = __z;
    complex<_Tp> tmp2 = {tmp1.real(), tmp1.imag()};
    *this = tmp2;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 190 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  __attribute__((nodebug)) complex() = default;


  __attribute__((nodebug)) complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  __attribute__((nodebug)) complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const __attribute__((nodebug)) _Tp& real() const { return _M_real; }
  const __attribute__((nodebug)) _Tp& imag() const { return _M_imag; }







  __attribute__((nodebug)) void real(_Tp __val) { _M_real = __val; }

  __attribute__((nodebug)) void imag(_Tp __val) { _M_imag = __val; }



  __attribute__((nodebug)) complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator=(const complex<_Up> &__z) {
    auto tmp1 = __z;
    complex<_Tp> tmp2 = {tmp1.real(), tmp1.imag()};
    *this = tmp2;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 323 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\etc/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 370 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_fixed.h" 2
# 5 "firmware/myproject.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h" 1
# 6 "firmware/myproject.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\hls_stream.h" 1
# 12 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\hls_stream.h"
# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot/hls_stream_39.h" 1
# 23 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot/hls_stream_39.h"
namespace hls {
# 49 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot/hls_stream_39.h"
template<typename __STREAM_T__, int DEPTH=0>
class stream;

template<typename __STREAM_T__>
class stream<__STREAM_T__, 0>
{
  public:
    using value_type = __STREAM_T__;

    inline __attribute__((always_inline)) __attribute__((nodebug)) stream() {
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) stream(const char* name) {
      (void)(name);
    }


  private:
    inline __attribute__((always_inline)) __attribute__((nodebug)) stream(const stream< __STREAM_T__ >& chn):V(chn.V) {
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) stream& operator= (const stream< __STREAM_T__ >& chn) {
        V = chn.V;
        return *this;
    }

  public:

    inline __attribute__((always_inline)) __attribute__((nodebug)) void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }


  public:

    inline __attribute__((always_inline)) __attribute__((nodebug)) bool empty() const {
        return !__fpga_fifo_not_empty(&V);
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) bool full() const {
        return !__fpga_fifo_not_full(&V);
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) void read(__STREAM_T__& dout) {
        __fpga_fifo_pop(&V, &dout);
    }


    inline __attribute__((noinline)) __attribute__((nodebug)) bool read_dep(__STREAM_T__& dout, volatile bool flag) {
        __fpga_fifo_pop(&V, &dout);
        return flag;
    }

    inline __attribute__((always_inline)) __attribute__((nodebug)) __STREAM_T__ read() {
        __STREAM_T__ tmp;
        read(tmp);
        return tmp;
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) bool read_nb(__STREAM_T__& dout) {
        __STREAM_T__ tmp;

        if (__fpga_fifo_nb_pop(&V, &tmp)) {
            dout = tmp;
            return true;
        } else {
            return false;
        }
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) void write(const __STREAM_T__& din) {
        __fpga_fifo_push(&V, &din);
    }


    inline __attribute__((noinline)) __attribute__((nodebug)) bool write_dep(const __STREAM_T__& din, volatile bool flag) {
        __fpga_fifo_push(&V, &din);
        return flag;
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) bool write_nb(const __STREAM_T__& din) {
        return __fpga_fifo_nb_push(&V, &din);
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned size() const {
        return __fpga_fifo_size(&V);
    }


    inline __attribute__((always_inline)) __attribute__((nodebug)) unsigned capacity() const {
        return __fpga_fifo_capacity(&V);
    }


    void set_name(const char* name) { (void)(name); }

  public:
    __STREAM_T__ V __attribute__((no_ctor));
};

template<typename __STREAM_T__, int DEPTH>
class stream : public stream<__STREAM_T__, 0> {
  public:
    inline __attribute__((always_inline)) __attribute__((nodebug)) stream() {
#pragma HLS stream variable=this depth=DEPTH
 }

    inline __attribute__((always_inline)) __attribute__((nodebug)) stream(const char* name) {
#pragma HLS stream variable=this depth=DEPTH
 (void)(name);
    }
};
}
# 13 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\hls_stream.h" 2
# 7 "firmware/myproject.h" 2

# 1 "firmware/defines.h" 1




# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h" 1
# 6 "firmware/defines.h" 2
# 1 "firmware/nnet_utils/nnet_types.h" 1



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 1 3
# 17 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 1 3
# 36 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;
# 51 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 3
using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 18 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 2 3



extern "C" {
# 45 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 3
extern void __attribute__((__cdecl__))
_wassert(const wchar_t *_Message,const wchar_t *_File,unsigned _Line);
extern void __attribute__((__cdecl__))
_assert (const char *_Message, const char *_File, unsigned _Line);


}
# 5 "firmware/nnet_utils/nnet_types.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstddef" 1 3
# 43 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstddef" 3







# 1 "C:\\Xilinx\\Vitis\\2024.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stddef.h" 1 3
# 51 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstddef" 2 3


namespace std
{

  using ::max_align_t;
}
# 6 "firmware/nnet_utils/nnet_types.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 3
# 7 "firmware/nnet_utils/nnet_types.h" 2

namespace nnet {


template <typename T, unsigned N> struct array {
    typedef T value_type;
    static const unsigned size = N;

    T data[N];

    T &operator[](size_t pos) { return data[pos]; }

    const T &operator[](size_t pos) const { return data[pos]; }

    array &operator=(const array &other) {
        if (&other == this)
            return *this;

        ({ bool _AssertPred = N == other.size && "Array sizes must match."; __builtin_assume(_AssertPred); });

        VITIS_LOOP_27_1: for (unsigned i = 0; i < N; i++) {
#pragma HLS UNROLL
 data[i] = other[i];
        }
        return *this;
    }
};


template <typename T, unsigned N, T (*func)(T)> class lookup_table {
  public:
    lookup_table(T from, T to) : range_start(from), range_end(to), base_div(ap_uint<16>(N) / T(to - from)) {
        T step = (range_end - range_start) / ap_uint<16>(N);
        VITIS_LOOP_40_1: for (size_t i = 0; i < N; i++) {
            T num = range_start + ap_uint<16>(i) * step;
            T sample = func(num);
            samples[i] = sample;
        }
    }

    T operator()(T n) const {
        int index = (n - range_start) * base_div;
        if (index < 0)
            index = 0;
        else if (index > N - 1)
            index = N - 1;
        return samples[index];
    }

  private:
    T samples[N];
    const T range_start, range_end;
    ap_fixed<20, 16> base_div;
};

}
# 7 "firmware/defines.h" 2

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 3
# 9 "firmware/defines.h" 2
# 20 "firmware/defines.h"
typedef ap_fixed<16,6> input_t;
typedef ap_fixed<16,6> model_default_t;
typedef ap_fixed<16,6> layer2_t;
typedef ap_uint<1> layer2_index;
typedef ap_fixed<16,6> layer3_t;
typedef ap_fixed<18,8> dense_relu_table_t;
typedef ap_fixed<16,6> layer4_t;
typedef ap_uint<1> layer4_index;
typedef ap_fixed<16,6> layer5_t;
typedef ap_fixed<18,8> dense_1_relu_table_t;
typedef ap_fixed<16,6> result_t;
typedef ap_uint<1> layer6_index;
# 9 "firmware/myproject.h" 2



__attribute__((sdx_kernel("myproject", 0))) void myproject(
    input_t input_1[100],
    result_t layer6_out[4]
);
# 4 "firmware/myproject.cpp" 2
# 1 "firmware/parameters.h" 1




# 1 "C:/Xilinx/Vitis/2024.2/common/technology/autopilot\\ap_int.h" 1
# 6 "firmware/parameters.h" 2

# 1 "firmware/nnet_utils/nnet_code_gen.h" 1



# 1 "firmware/nnet_utils/nnet_conv1d_latency.h" 1



# 1 "firmware/nnet_utils/nnet_common.h" 1




# 1 "firmware/nnet_utils/nnet_helpers.h" 1




# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\algorithm" 1 3
# 59 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\algorithm" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\utility" 1 3
# 59 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\utility" 3
# 69 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\utility" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_relops.h" 1 3
# 67 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_relops.h" 3
namespace std
{


  namespace rel_ops
  {
# 85 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\utility" 2 3








namespace std
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };
# 144 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\utility" 3
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }
# 289 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\utility" 3
  template<size_t... _Indexes> struct _Index_tuple { };
# 298 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {

      template<typename, size_t... _Indices>
        using _IdxTuple = _Index_tuple<_Indices...>;

      using __type = __make_integer_seq<_IdxTuple, size_t, _Num>;



    };
# 394 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\utility" 3
}
# 61 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\algorithm" 2 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 1 3
# 59 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
# 60 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/algorithmfwd.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/algorithmfwd.h" 3








namespace std
{
# 195 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);
# 224 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/algorithmfwd.h" 3
  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>

    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>

    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>

    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>

    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>

    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>

    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>

    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>

    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>

    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>

    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>

    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>

    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>

    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>

    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 565 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 594 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);



  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>

    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>

    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>

    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>

    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);



}
# 61 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 1 3
# 62 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
namespace std
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare& __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return std::__is_heap_until(__first, __n, __comp) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __n, __cmp) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      return std::__is_heap(__first, std::move(__comp),
       std::distance(__first, __last));
    }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare& __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 152 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;
                                                     ;
                                                  ;

      __gnu_cxx::__ops::_Iter_less_val __comp;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }
# 187 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                                  ;
                                                               ;

      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 269 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                         ;
                                                     ;
                                                     ;
                                              ;

      if (__last - __first > 1)
 {
   --__last;
   __gnu_cxx::__ops::_Iter_less_iter __comp;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 302 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                                  ;
                                                         ;
                                                           ;

      if (__last - __first > 1)
 {
   typedef __decltype(__comp) _Cmp;
   __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
   --__last;
   std::__pop_heap(__first, __last, __last, __cmp);
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 358 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__make_heap(__first, __last, __comp);
    }
# 384 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                                  ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__make_heap(__first, __last, __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 420 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;
                                              ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__sort_heap(__first, __last, __comp);
    }
# 447 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                                  ;
                                                           ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__sort_heap(__first, __last, __cmp);
    }
# 475 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last), __comp);
    }
# 503 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {



                                                     ;
                                                                  ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
    }
# 527 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 540 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    {



                                                     ;
                                                                  ;

      const auto __dist = std::distance(__first, __last);
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __dist, __cmp) == __dist;
    }



}
# 62 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tempbuf.h" 1 3
# 60 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tempbuf.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_construct.h" 1 3
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_construct.h" 3
namespace std
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 87 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }
# 233 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_construct.h" 3
}
# 61 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tempbuf.h" 2 3

namespace std
{
# 83 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   if (true)
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      if (true)
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      if (false)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
                          ;
 }
    }


}
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 2 3



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/uniform_int_dist.h" 1 3
# 35 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/uniform_int_dist.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 1 3
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
# 158 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
namespace std
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 382 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1593 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435e-38F; }

      static constexpr float
      max() noexcept { return 3.40282347e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282347e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209290e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return 2.2250738585072014e-308; }

      static constexpr double
      max() noexcept { return 1.7976931348623157e+308; }


      static constexpr double
      lowest() noexcept { return -1.7976931348623157e+308; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return 2.2204460492503131e-16; }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return 4.9406564584124654e-324; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 2.2250738585072014e-308L; }

      static constexpr long double
      max() noexcept { return 1.7976931348623157e+308L; }


      static constexpr long double
      lowest() noexcept { return -1.7976931348623157e+308L; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 2.2204460492503131e-16L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 4.9406564584124654e-324L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 36 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/uniform_int_dist.h" 2 3

namespace std
{


  namespace __detail
  {

    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      }
  }






  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument must be an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
                                 ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

 friend bool
 operator!=(const param_type& __p1, const param_type& __p2)
 { return !(__p1 == __p2); }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 264 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 348 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }




}
# 67 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 2 3




namespace std
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, (void) ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 202 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 423 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 471 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 506 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 523 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 541 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 556 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {




                                                     ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 580 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      if (__first == __last)
 return true;
      ++__first;
      return std::none_of(__first, __last, __pred);
    }
# 601 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {






                                                     ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 668 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 700 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 734 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 797 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {





      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 825 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {
# 840 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 894 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 927 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 993 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1023 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {






                                                     ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {




      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1178 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1205 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1432 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1469 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1546 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1649 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1735 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1755 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                     ;
                                                     ;
                                                                   ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1784 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1809 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                     ;
                                                                  ;
                                                                   ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2021 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {





                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2075 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




                                                                  ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2105 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {





                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2176 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {






                                                                  ;
                                                                  ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2212 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {







                    ;

                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2245 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {




                                                                  ;
                                                                  ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2278 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {





                    ;

                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2572 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {





                                                  ;
                                                 ;
                                                     ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2613 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {






                                                               ;
                                                              ;
                                                                  ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result));


    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2785 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2824 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
# 2838 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2868 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
# 2884 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2903 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2952 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;
                                                     ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2984 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;
                                                                  ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3052 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;
                                                     ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3084 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;
                                                                  ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3134 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3168 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3207 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3221 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3250 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3274 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3299 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _Tp>

    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {



      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3320 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>

    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>

    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3400 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator>

    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3428 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>

    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>

    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>

    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>

    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>

    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>

    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>

    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3540 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {






                                                       ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3571 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {






                                                       ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3767 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _IntType, typename _UniformRandomBitGenerator>
    pair<_IntType, _IntType>
    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
      _UniformRandomBitGenerator&& __g)
    {
      _IntType __x
 = uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
      return std::make_pair(__x / __b1, __x % __b1);
    }
# 3789 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {



                                                     ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;

      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
 _Gen;
      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
 __uc_type;

      const __uc_type __urngrange = __g.max() - __g.min();
      const __uc_type __urange = __uc_type(__last - __first);

      if (__urngrange / __urange >= __urange)

      {
 _RandomAccessIterator __i = __first + 1;





 if ((__urange % 2) == 0)
 {
   __distr_type __d{0, 1};
   std::iter_swap(__i++, __first + __d(__g));
 }





 while (__i != __last)
 {
   const __uc_type __swap_range = __uc_type(__i - __first) + 1;

   const pair<__uc_type, __uc_type> __pospos =
     __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

   std::iter_swap(__i++, __first + __pospos.first);
   std::iter_swap(__i++, __first + __pospos.second);
 }

 return;
      }

      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }
# 3874 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 3895 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3919 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3950 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3990 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4022 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4047 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 4072 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 4095 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4135 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4174 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4209 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4242 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4290 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4327 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4360 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4392 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4424 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4455 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __gen();
      return __first;
    }
# 4491 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4531 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4564 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4599 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4639 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4672 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {





                                                       ;
                                                      ;
                                                     ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4710 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {






                                                       ;
                                                      ;
                                                                  ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4746 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {





                                                    ;
                                                   ;
                                                     ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4785 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {






                                                    ;
                                                   ;
                                                                  ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4822 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4852 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






                                                     ;
                                                                  ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4913 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
# 4930 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4963 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
# 4980 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5027 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                                     ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 5061 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






                                                     ;
                                                                  ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5130 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
# 5150 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5180 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
# 5200 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5251 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
# 5269 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5300 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
# 5318 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5373 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
# 5391 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5424 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
# 5442 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5503 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
# 5523 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                ;
                                                                ;
                                                        ;
                                                        ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5554 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
# 5575 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
                                                                             ;
                                                                             ;
                                                                     ;
                                                                     ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>

    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5607 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator>

    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5632 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>

    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>

    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5671 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator>

    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
                                                     ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5696 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>

    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;
                                                                  ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 5841 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_algo.h" 3
}
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\algorithm" 2 3
# 6 "firmware/nnet_utils/nnet_helpers.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 1 3
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/codecvt.h" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/codecvt.h" 3

namespace std
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 273 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 467 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/codecvt.h" 3
  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;





}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 3
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/basic_file.h" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/basic_file.h" 3


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++io.h" 1 3
# 35 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++io.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdio" 3
# 36 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++io.h" 2 3


namespace std
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/basic_file.h" 2 3



namespace std
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();


      __basic_file(__basic_file&& __rv, __c_lock* = 0) noexcept
      : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created)
      {
 __rv._M_cfile = nullptr;
 __rv._M_cfile_created = false;
      }

      __basic_file& operator=(const __basic_file&) = delete;
      __basic_file& operator=(__basic_file&&) = delete;

      void
      swap(__basic_file& __f) noexcept
      {
 std::swap(_M_cfile, __f._M_cfile);
 std::swap(_M_cfile_created, __f._M_cfile_created);
      }


      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 43 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 2 3




namespace std
{
# 79 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {

      template<typename _Tp>
 using __chk_state = __and_<is_copy_assignable<_Tp>,
       is_copy_constructible<_Tp>,
       is_default_constructible<_Tp>>;

      static_assert(__chk_state<typename _Traits::state_type>::value,
      "state_type must be CopyAssignable, CopyConstructible"
      " and DefaultConstructible");

      static_assert(is_same<typename _Traits::pos_type,
       fpos<typename _Traits::state_type>>::value,
      "pos_type must be fpos<state_type>");

    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 155 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();


      basic_filebuf(const basic_filebuf&) = delete;
      basic_filebuf(basic_filebuf&&);





      virtual
      ~basic_filebuf()
      { this->close(); }


      basic_filebuf& operator=(const basic_filebuf&) = delete;
      basic_filebuf& operator=(basic_filebuf&&);
      void swap(basic_filebuf&);






      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 304 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 314 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 344 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 376 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 396 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 442 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
 const bool __testin = _M_mode & ios_base::in;
 const bool __testout = (_M_mode & ios_base::out
    || _M_mode & ios_base::app);

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 475 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 502 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 512 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 528 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 552 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      basic_ifstream(const basic_ifstream&) = delete;

      basic_ifstream(basic_ifstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __istream_type::set_rdbuf(&_M_filebuf); }
# 566 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      ~basic_ifstream()
      { }




      basic_ifstream&
      operator=(const basic_ifstream&) = delete;

      basic_ifstream&
      operator=(basic_ifstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ifstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 598 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 624 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 644 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 677 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 700 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 727 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 737 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 754 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 778 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      basic_ofstream(const basic_ofstream&) = delete;

      basic_ofstream(basic_ofstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __ostream_type::set_rdbuf(&_M_filebuf); }
# 792 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      ~basic_ofstream()
      { }




      basic_ofstream&
      operator=(const basic_ofstream&) = delete;

      basic_ofstream&
      operator=(basic_ofstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ofstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 824 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 850 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 870 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 903 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 926 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 954 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }






      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 1000 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      basic_fstream(const basic_fstream&) = delete;

      basic_fstream(basic_fstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __iostream_type::set_rdbuf(&_M_filebuf); }
# 1014 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      ~basic_fstream()
      { }




      basic_fstream&
      operator=(const basic_fstream&) = delete;

      basic_fstream&
      operator=(basic_fstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_fstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 1046 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 1072 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1093 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1128 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };



  template <class _CharT, class _Traits>
    inline void
    swap(basic_filebuf<_CharT, _Traits>& __x,
  basic_filebuf<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ifstream<_CharT, _Traits>& __x,
  basic_ifstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ofstream<_CharT, _Traits>& __x,
  basic_ofstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_fstream<_CharT, _Traits>& __x,
  basic_fstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }



}


# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/fstream.tcc" 1 3
# 38 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/fstream.tcc" 3




namespace std
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(512),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }


  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf(basic_filebuf&& __rhs)
    : __streambuf_type(__rhs),
    _M_lock(), _M_file(std::move(__rhs._M_file), &_M_lock),
    _M_mode(std::__exchange(__rhs._M_mode, ios_base::openmode(0))),
    _M_state_beg(std::move(__rhs._M_state_beg)),
    _M_state_cur(std::move(__rhs._M_state_cur)),
    _M_state_last(std::move(__rhs._M_state_last)),
    _M_buf(std::__exchange(__rhs._M_buf, nullptr)),
    _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)),
    _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)),
    _M_reading(std::__exchange(__rhs._M_reading, false)),
    _M_writing(std::__exchange(__rhs._M_writing, false)),
    _M_pback(__rhs._M_pback),
    _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)),
    _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)),
    _M_pback_init(std::__exchange(__rhs._M_pback_init, false)),
    _M_codecvt(__rhs._M_codecvt),
    _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)),
    _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)),
    _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)),
    _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr))
    {
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>&
    basic_filebuf<_CharT, _Traits>::
    operator=(basic_filebuf&& __rhs)
    {
      this->close();
      __streambuf_type::operator=(__rhs);
      _M_file.swap(__rhs._M_file);
      _M_mode = std::__exchange(__rhs._M_mode, ios_base::openmode(0));
      _M_state_beg = std::move(__rhs._M_state_beg);
      _M_state_cur = std::move(__rhs._M_state_cur);
      _M_state_last = std::move(__rhs._M_state_last);
      _M_buf = std::__exchange(__rhs._M_buf, nullptr);
      _M_buf_size = std::__exchange(__rhs._M_buf_size, 1);
      _M_buf_allocated = std::__exchange(__rhs._M_buf_allocated, false);
      _M_ext_buf = std::__exchange(__rhs._M_ext_buf, nullptr);
      _M_ext_buf_size = std::__exchange(__rhs._M_ext_buf_size, 0);
      _M_ext_next = std::__exchange(__rhs._M_ext_next, nullptr);
      _M_ext_end = std::__exchange(__rhs._M_ext_end, nullptr);
      _M_reading = std::__exchange(__rhs._M_reading, false);
      _M_writing = std::__exchange(__rhs._M_writing, false);
      _M_pback_cur_save = std::__exchange(__rhs._M_pback_cur_save, nullptr);
      _M_pback_end_save = std::__exchange(__rhs._M_pback_end_save, nullptr);
      _M_pback_init = std::__exchange(__rhs._M_pback_init, false);
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
      return *this;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    swap(basic_filebuf& __rhs)
    {
      __streambuf_type::swap(__rhs);
      _M_file.swap(__rhs._M_file);
      std::swap(_M_mode, __rhs._M_mode);
      std::swap(_M_state_beg, __rhs._M_state_beg);
      std::swap(_M_state_cur, __rhs._M_state_cur);
      std::swap(_M_state_last, __rhs._M_state_last);
      std::swap(_M_buf, __rhs._M_buf);
      std::swap(_M_buf_size, __rhs._M_buf_size);
      std::swap(_M_buf_allocated, __rhs._M_buf_allocated);
      std::swap(_M_ext_buf, __rhs._M_ext_buf);
      std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size);
      std::swap(_M_ext_next, __rhs._M_ext_next);
      std::swap(_M_ext_end, __rhs._M_ext_end);
      std::swap(_M_reading, __rhs._M_reading);
      std::swap(_M_writing, __rhs._M_writing);
      std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save);
      std::swap(_M_pback_end_save, __rhs._M_pback_end_save);
      std::swap(_M_pback_init, __rhs._M_pback_init);
    }


  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 if (true)
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 if (false)
   {
     _M_file.close();
                            ;
   }
 if (false)
   { __testfail = true; }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();



   const bool __testbinary = _M_mode & ios_base::binary;
   if (__check_facet(_M_codecvt).encoding() >= 0
       && __testbinary)



     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid"));


   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file"));

     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file"));

   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file"));

 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));


   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));

     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
   if (overflow() == traits_type::eof())
     return __ret;
   _M_set_buffer(-1);
   _M_writing = false;
 }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
   && __testin)
 {

   const streamsize __avail = this->egptr() - this->gptr();
   if (__avail != 0)
     {
       traits_type::copy(__s, this->gptr(), __avail);
       __s += __avail;
       this->setg(this->eback(), this->gptr() + __avail, this->egptr());
       __ret += __avail;
       __n -= __avail;
     }



   streamsize __len;
   for (;;)
     {
       __len = _M_file.xsgetn(reinterpret_cast<char*>(__s), __n);
       if (__len == -1)
  __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file"));

       if (__len == 0)
  break;

       __n -= __len;
       __ret += __len;
       if (__n == 0)
  break;

       __s += __len;
     }

   if (__n == 0)
     {

       _M_reading = true;
     }
   else if (__len == 0)
     {



       _M_set_buffer(-1);
       _M_reading = false;
     }
 }
      else
 __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__check_facet(_M_codecvt).always_noconv()
   && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 785 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

       off_type __file_off = _M_file.seekoff(0, ios_base::cur);
       if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 1170 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\fstream" 2 3
# 7 "firmware/nnet_utils/nnet_helpers.h" 2

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\map" 1 3
# 59 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\map" 3

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 1 3
# 62 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3







# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/aligned_buffer.h" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {





      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };
# 89 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/aligned_buffer.h" 3
  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
    {
      typename
 std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };


}
# 70 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 2 3





namespace std
{
# 99 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };


  template<typename _Key_compare>
    struct _Rb_tree_key_compare
    {
      _Key_compare _M_key_compare;

      _Rb_tree_key_compare()
      noexcept(is_nothrow_default_constructible<_Key_compare>::value)

      : _M_key_compare()
      { }

      _Rb_tree_key_compare(const _Key_compare& __comp)
      : _M_key_compare(__comp)
      { }



      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;

      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)
 noexcept(is_nothrow_copy_constructible<_Key_compare>::value)
      : _M_key_compare(__x._M_key_compare)
      { }

    };


  struct _Rb_tree_header
  {
    _Rb_tree_node_base _M_header;
    size_t _M_node_count;

    _Rb_tree_header() noexcept
    {
      _M_header._M_color = _S_red;
      _M_reset();
    }


    _Rb_tree_header(_Rb_tree_header&& __x) noexcept
    {
      if (__x._M_header._M_parent != nullptr)
 _M_move_data(__x);
      else
 {
   _M_header._M_color = _S_red;
   _M_reset();
 }
    }


    void
    _M_move_data(_Rb_tree_header& __from)
    {
      _M_header._M_color = __from._M_header._M_color;
      _M_header._M_parent = __from._M_header._M_parent;
      _M_header._M_left = __from._M_header._M_left;
      _M_header._M_right = __from._M_header._M_right;
      _M_header._M_parent->_M_parent = &_M_header;
      _M_node_count = __from._M_node_count;

      __from._M_reset();
    }

    void
    _M_reset()
    {
      _M_header._M_parent = 0;
      _M_header._M_left = &_M_header;
      _M_header._M_right = &_M_header;
      _M_node_count = 0;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
# 231 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
      __gnu_cxx::__aligned_membuf<_Val> _M_storage;

      _Val*
      _M_valptr()
      { return _M_storage._M_ptr(); }

      const _Val*
      _M_valptr() const
      { return _M_storage._M_ptr(); }

    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it) noexcept
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
        const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
        const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
    _Rb_tree_node_base* __x,
    _Rb_tree_node_base* __p,
    _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();
# 442 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Rb_tree_node<_Val> >::other _Node_allocator;

      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;


      static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
   "comparison object must be invocable with two arguments of key type");
# 462 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;

    private:


      struct _Reuse_or_alloc_node
      {
 _Reuse_or_alloc_node(_Rb_tree& __t)
   : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
 {
   if (_M_root)
     {
       _M_root->_M_parent = 0;

       if (_M_nodes->_M_left)
  _M_nodes = _M_nodes->_M_left;
     }
   else
     _M_nodes = 0;
 }


 _Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;


 ~_Reuse_or_alloc_node()
 { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg)

   {
     _Link_type __node = static_cast<_Link_type>(_M_extract());
     if (__node)
       {
  _M_t._M_destroy_node(__node);
  _M_t._M_construct_node(__node, std::forward<_Arg>(__arg));
  return __node;
       }

     return _M_t._M_create_node(std::forward<_Arg>(__arg));
   }

      private:
 _Base_ptr
 _M_extract()
 {
   if (!_M_nodes)
     return _M_nodes;

   _Base_ptr __node = _M_nodes;
   _M_nodes = _M_nodes->_M_parent;
   if (_M_nodes)
     {
       if (_M_nodes->_M_right == __node)
  {
    _M_nodes->_M_right = 0;

    if (_M_nodes->_M_left)
      {
        _M_nodes = _M_nodes->_M_left;

        while (_M_nodes->_M_right)
   _M_nodes = _M_nodes->_M_right;

        if (_M_nodes->_M_left)
   _M_nodes = _M_nodes->_M_left;
      }
  }
       else
  _M_nodes->_M_left = 0;
     }
   else
     _M_root = 0;

   return __node;
 }

 _Base_ptr _M_root;
 _Base_ptr _M_nodes;
 _Rb_tree& _M_t;
      };



      struct _Alloc_node
      {
 _Alloc_node(_Rb_tree& __t)
   : _M_t(__t) { }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg) const

   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }

      private:
 _Rb_tree& _M_t;
      };

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator() noexcept
      { return this->_M_impl; }

      const _Node_allocator&
      _M_get_Node_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }

      void
      _M_put_node(_Link_type __p) noexcept
      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
# 630 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
      template<typename... _Args>
 void
 _M_construct_node(_Link_type __node, _Args&&... __args)
 {
   if (true)
     {
       ::new(__node) _Rb_tree_node<_Val>;
       _Alloc_traits::construct(_M_get_Node_allocator(),
           __node->_M_valptr(),
           std::forward<_Args>(__args)...);
     }
   if (false)
     {
       __node->~_Rb_tree_node<_Val>();
       _M_put_node(__node);
                              ;
     }
 }

      template<typename... _Args>
 _Link_type
 _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   _M_construct_node(__tmp, std::forward<_Args>(__args)...);
   return __tmp;
 }

      void
      _M_destroy_node(_Link_type __p) noexcept
      {
 _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
 __p->~_Rb_tree_node<_Val>();
      }


      void
      _M_drop_node(_Link_type __p) noexcept
      {
 _M_destroy_node(__p);
 _M_put_node(__p);
      }

      template<typename _NodeGen>
 _Link_type
 _M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
 {
   _Link_type __tmp = __node_gen(*__x->_M_valptr());
   __tmp->_M_color = __x->_M_color;
   __tmp->_M_left = 0;
   __tmp->_M_right = 0;
   return __tmp;
 }

    protected:




      template<typename _Key_compare,
        bool = __is_pod(_Key_compare)>

 struct _Rb_tree_impl
 : public _Node_allocator
 , public _Rb_tree_key_compare<_Key_compare>
 , public _Rb_tree_header
 {
   typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;

   _Rb_tree_impl()
     noexcept(is_nothrow_default_constructible<_Node_allocator>::value && is_nothrow_default_constructible<_Base_key_compare>::value)


   : _Node_allocator()
   { }

   _Rb_tree_impl(const _Rb_tree_impl& __x)
   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
   , _Base_key_compare(__x._M_key_compare)
   { }






   _Rb_tree_impl(_Rb_tree_impl&&) = default;

   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)
   { }

 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root() noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost() noexcept
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const noexcept
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost() noexcept
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const noexcept
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin() noexcept
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const noexcept
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Base_ptr
      _M_end() noexcept
      { return &this->_M_impl._M_header; }

      _Const_Base_ptr
      _M_end() const noexcept
      { return &this->_M_impl._M_header; }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return *__x->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 832 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);

    private:

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);

      iterator
      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);

      template<typename _Arg>
 iterator
 _M_insert_lower(_Base_ptr __y, _Arg&& __v);

      template<typename _Arg>
 iterator
 _M_insert_equal_lower(_Arg&& __x);

      iterator
      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);

      iterator
      _M_insert_equal_lower_node(_Link_type __z);
# 883 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
      template<typename _NodeGen>
 _Link_type
 _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen&);

      template<typename _NodeGen>
 _Link_type
 _M_copy(const _Rb_tree& __x, _NodeGen& __gen)
 {
   _Link_type __root = _M_copy(__x._M_begin(), _M_end(), __gen);
   _M_leftmost() = _S_minimum(__root);
   _M_rightmost() = _S_maximum(__root);
   _M_impl._M_node_count = __x._M_impl._M_node_count;
   return __root;
 }

      _Link_type
      _M_copy(const _Rb_tree& __x)
      {
 _Alloc_node __an(*this);
 return _M_copy(__x, __an);
      }

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

    public:




      _Rb_tree() = default;


      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl)
      {
 if (__x._M_root() != 0)
   _M_root() = _M_copy(__x);
      }


      _Rb_tree(const allocator_type& __a)
      : _M_impl(_Compare(), _Node_allocator(__a))
      { }

      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
      {
 if (__x._M_root() != nullptr)
   _M_root() = _M_copy(__x);
      }

      _Rb_tree(_Rb_tree&&) = default;

      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
      : _Rb_tree(std::move(__x), _Node_allocator(__a))
      { }

      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);


      ~_Rb_tree() noexcept
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_header._M_left); }

      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_header); }

      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      bool
      empty() const noexcept
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const noexcept
      { return _M_impl._M_node_count; }

      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }

      void
      swap(_Rb_tree& __t)
      noexcept(__is_nothrow_swappable<_Compare>::value);



      template<typename _Arg>
 pair<iterator, bool>
 _M_insert_unique(_Arg&& __x);

      template<typename _Arg>
 iterator
 _M_insert_equal(_Arg&& __x);

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename... _Args>
 pair<iterator, bool>
 _M_emplace_unique(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_equal(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
# 1103 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
      template<typename _InputIterator>
 void
 _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
 void
 _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:



      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      {
                                      ;
 const_iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result._M_const_cast();
      }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      {
                                      ;
 iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result;
      }
# 1159 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
      size_type
      erase(const key_type& __x);




      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      {
 _M_erase_aux(__first, __last);
 return __last._M_const_cast();
      }
# 1181 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear() noexcept
      {
 _M_erase(_M_begin());
 _M_impl._M_reset();
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;
# 1341 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
      bool
      __rb_verify() const;


      _Rb_tree&
      operator=(_Rb_tree&&)
      noexcept(_Alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_Compare>::value);

      template<typename _Iterator>
 void
 _M_assign_unique(_Iterator, _Iterator);

      template<typename _Iterator>
 void
 _M_assign_equal(_Iterator, _Iterator);

    private:

      void
      _M_move_data(_Rb_tree& __x, std::true_type)
      { _M_impl._M_move_data(__x._M_impl); }



      void
      _M_move_data(_Rb_tree&, std::false_type);


      void
      _M_move_assign(_Rb_tree&, std::true_type);



      void
      _M_move_assign(_Rb_tree&, std::false_type);
# 1544 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
    {
      using __eq = typename _Alloc_traits::is_always_equal;
      if (__x._M_root() != nullptr)
 _M_move_data(__x, __eq());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, std::false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 _M_move_data(__x, std::true_type());
      else
 {
   _Alloc_node __an(*this);
   auto __lbd =
     [&__an](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __an(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, true_type)
    {
      clear();
      if (__x._M_root() != nullptr)
 _M_move_data(__x, std::true_type());
      std::__alloc_on_move(_M_get_Node_allocator(),
      __x._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 return _M_move_assign(__x, true_type{});



      _Reuse_or_alloc_node __roan(*this);
      _M_impl._M_reset();
      if (__x._M_root() != nullptr)
 {
   auto __lbd =
     [&__roan](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __roan(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
   __x.clear();
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(_Rb_tree&& __x)
    noexcept(_Alloc_traits::_S_nothrow_move()
      && is_nothrow_move_assignable<_Compare>::value)
    {
      _M_impl._M_key_compare = std::move(__x._M_impl._M_key_compare);
      _M_move_assign(__x, __bool_constant<_Alloc_traits::_S_nothrow_move()>());
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_unique(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __roan);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_equal(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __roan);
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree& __x)
    {
      if (this != &__x)
 {


   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       auto& __this_alloc = this->_M_get_Node_allocator();
       auto& __that_alloc = __x._M_get_Node_allocator();
       if (!_Alloc_traits::_S_always_equal()
    && __this_alloc != __that_alloc)
  {


    clear();
    std::__alloc_on_copy(__this_alloc, __that_alloc);
  }
     }


   _Reuse_or_alloc_node __roan(*this);
   _M_impl._M_reset();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     _M_root() = _M_copy(__x, __roan);
 }

      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_(_Base_ptr __x, _Base_ptr __p,

   _Arg&& __v,



   _NodeGen& __node_gen)
      {
 bool __insert_left = (__x != 0 || __p == _M_end()
         || _M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key(__p)));

 _Link_type __z = __node_gen(std::forward<_Arg>(__v));

 _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
          this->_M_impl._M_header);
 ++_M_impl._M_node_count;
 return iterator(__z);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_lower(_Base_ptr __p, _Arg&& __v)



    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal_lower(_Arg&& __v)



    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, std::forward<_Arg>(__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
    typename _Compare, typename _Alloc>
    template<typename _NodeGen>
      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
      _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
      {

 _Link_type __top = _M_clone_node(__x, __node_gen);
 __top->_M_parent = __p;

 if (true)
   {
     if (__x->_M_right)
       __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);
     __p = __top;
     __x = _S_left(__x);

     while (__x != 0)
       {
  _Link_type __y = _M_clone_node(__x, __node_gen);
  __p->_M_left = __y;
  __y->_M_parent = __p;
  if (__x->_M_right)
    __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);
  __p = __y;
  __x = _S_left(__x);
       }
   }
 if (false)
   {
     _M_erase(__top);
                            ;
   }
 return __top;
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_drop_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x);
       _Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
     iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x);
       _Const_Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
     const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree& __t)
    noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     _M_impl._M_move_data(__t._M_impl);
 }
      else if (__t._M_root() == 0)
 __t._M_impl._M_move_data(_M_impl);
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
   std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
 }

      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);

      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
    __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_unique(_Arg&& __v)



    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 {
   _Alloc_node __an(*this);
   return _Res(_M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v), __an),
        true);
 }

      return _Res(iterator(__res.first), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal(_Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      _Alloc_node __an(*this);
      return _M_insert_(__res.first, __res.second,
   std::forward<_Arg>(__v), __an);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_unique_(const_iterator __position,

   _Arg&& __v,



   _NodeGen& __node_gen)
    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v),
     __node_gen);
      return iterator(__res.first);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_equal_(const_iterator __position,

         _Arg&& __v,



         _NodeGen& __node_gen)
      {
 pair<_Base_ptr, _Base_ptr> __res
   = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

 if (__res.second)
   return _M_insert_(__res.first, __res.second,
       std::forward<_Arg>(__v),
       __node_gen);

 return _M_insert_equal_lower(std::forward<_Arg>(__v));
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_S_key(__z),
            _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _S_key(__z)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower_node(_Link_type __z)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower_node(__y, __z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator, bool>
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_unique(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 if (true)
   {
     typedef pair<iterator, bool> _Res;
     auto __res = _M_get_insert_unique_pos(_S_key(__z));
     if (__res.second)
       return _Res(_M_insert_node(__res.first, __res.second, __z), true);

     _M_drop_node(__z);
     return _Res(iterator(__res.first), false);
   }
 if (false)
   {
     _M_drop_node(__z);
                            ;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_equal(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 if (true)
   {
     auto __res = _M_get_insert_equal_pos(_S_key(__z));
     return _M_insert_node(__res.first, __res.second, __z);
   }
 if (false)
   {
     _M_drop_node(__z);
                            ;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 if (true)
   {
     auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     _M_drop_node(__z);
     return iterator(__res.first);
   }
 if (false)
   {
     _M_drop_node(__z);
                            ;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 if (true)
   {
     auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     return _M_insert_equal_lower_node(__z);
   }
 if (false)
   {
     _M_drop_node(__z);
                            ;
   }
      }


  template<typename _Key, typename _Val, typename _KoV,
    typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KoV,
    typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_drop_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   _M_erase_aux(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      _M_erase_aux(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
         const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }
# 2628 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_tree.h" 3
}
# 61 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\map" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 1 3
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 3






# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\array" 1 3
# 33 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\array" 3
# 43 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\array" 3
namespace std
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


                           iterator
      begin() noexcept
      { return iterator(data()); }

                           const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

                           iterator
      end() noexcept
      { return iterator(data() + _Nm); }

                           const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

                           reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

                           const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

                           reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

                           const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

                           const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

                           const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

                           const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

                           const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


                           reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

                           reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)"),

     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)"),

        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

                           reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

                           reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

                           pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

                           const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };
# 250 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\array" 3
  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline






    void

    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }
# 305 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\array" 3
  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }


}

namespace std
{





  template<typename _Tp>
    struct tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    struct tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/uses_allocator.h" 1 3
# 35 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/uses_allocator.h" 3
namespace std
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

                    constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;







  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };







  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };
# 156 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/uses_allocator.h" 3
  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      __uses_allocator_construct_impl(__use_alloc<_Tp, _Alloc, _Args...>(__a),
          __ptr, std::forward<_Args>(__args)...);
    }


}
# 41 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/invoke.h" 1 3
# 34 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/invoke.h" 3







namespace std
{
# 52 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


}
# 42 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 2 3

namespace std
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 176 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && (_TC<(sizeof...(_UElements)==1), _Elements...>::
     template _NotSameTuple<_UElements...>()),
                      _Elements...>;



      template<typename... _UElements> using _TMCT =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && !is_same<tuple<_Elements...>,
      tuple<_UElements...>>::value,
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements>
 typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements), tuple&>::type
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };
# 889 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 3
  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&) { }
      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&, const tuple&) { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<typename decay<_U1>::type,
         allocator_arg_t>::value,
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
# 1278 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 3
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type&&>(std::get<__i>(__t));
    }
# 1382 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 3
  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline





    void

    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1632 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 3
  struct _Swallow_assign
  {
    template<class _Tp>
                           const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



                    constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }
# 1712 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\tuple" 3
}
# 64 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 2 3


namespace std
{



  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class multimap;
# 98 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:
# 122 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      static_assert(is_same<typename _Alloc::value_type, value_type>::value,
   "std::map must have the same value_type as its allocator");


    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
# 183 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      map() = default;







      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 205 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      map(const map&) = default;







      map(map&&) = default;
# 226 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      map(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      explicit
      map(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      map(const map& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      map(map&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      map(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last,
     const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
 { _M_t._M_insert_unique(__first, __last); }
# 270 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
# 287 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
 { _M_t._M_insert_unique(__first, __last); }







      ~map() = default;
# 316 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      map&
      operator=(const map&) = default;


      map&
      operator=(map&&) = default;
# 334 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      map&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_unique(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }






      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 489 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))

   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
         std::tuple<const key_type&>(__k),
         std::tuple<>());



 return (*__i).second;
      }


      mapped_type&
      operator[](key_type&& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
     std::forward_as_tuple(std::move(__k)),
     std::tuple<>());
 return (*__i).second;
      }
# 534 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 572 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
# 602 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
# 800 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }




      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_t._M_insert_unique(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value,
        pair<iterator, bool>>
 insert(_Pair&& __x)
 { return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }
# 827 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      void
      insert(std::initializer_list<value_type> __list)
      { insert(__list.begin(), __list.end()); }
# 856 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_unique_(__position, __x); }




      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_unique_(__position, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 insert(const_iterator __position, _Pair&& __x)
 {
   return _M_t._M_emplace_hint_unique(__position,
          std::forward<_Pair>(__x));
 }
# 889 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
# 1029 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 1066 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 1086 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 1120 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      void
      swap(map& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 1167 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 1192 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 1213 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 1237 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 1262 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 1282 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
# 1302 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 1331 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 1360 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
# 1377 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 1432 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 1449 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
       const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
       const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1515 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_map.h" 3
}
# 62 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\map" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 1 3
# 64 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
namespace std
{



  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class map;
# 96 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:
# 121 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      static_assert(is_same<typename _Alloc::value_type, value_type>::value,
   "std::multimap must have the same value_type as its allocator");


    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
# 180 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      multimap() = default;







      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 202 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      multimap(const multimap&) = default;
# 211 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      multimap(multimap&&) = default;
# 223 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      multimap(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      explicit
      multimap(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      multimap(const multimap& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      multimap(multimap&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      multimap(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last,
   const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
 { _M_t._M_insert_equal(__first, __last); }
# 266 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_equal(__first, __last); }
# 282 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
 { _M_t._M_insert_equal(__first, __last); }







      ~multimap() = default;
# 311 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap&) = default;


      multimap&
      operator=(multimap&&) = default;
# 329 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_equal(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }




      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 487 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
# 514 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
# 536 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }




      iterator
      insert(value_type&& __x)
      { return _M_t._M_insert_equal(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 insert(_Pair&& __x)
 { return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
# 575 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_equal_(__position, __x); }




      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_equal_(__position, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __position, _Pair&& __x)
 {
   return _M_t._M_emplace_hint_equal(__position,
         std::forward<_Pair>(__x));
 }
# 609 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_equal(__first, __last); }
# 622 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 699 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 736 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 757 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 794 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 840 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 864 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 882 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 906 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 931 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 951 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
# 971 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 998 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 1025 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
# 1042 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 1096 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 1113 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
  multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1179 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_multimap.h" 3
}
# 63 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\map" 2 3
# 9 "firmware/nnet_utils/nnet_helpers.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\math.h" 1 3
# 36 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\math.h" 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3





# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 1 3
# 11 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3




struct _exception;

#pragma pack(push,_CRT_PACKING)
# 77 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
extern "C++" {
template <typename type1, typename type2> struct __mingw_types_compatible_p {
  static const bool result = false;
};

template <typename type1> struct __mingw_types_compatible_p<type1, type1> {
 static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<const type1, type1> {
  static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<type1, const type1> {
  static const bool result = true;
};
}
# 111 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
extern "C" {







  typedef union __mingw_dbl_type_t {
    double x;
    unsigned long long val;
    __extension__ struct {
      unsigned int low, high;
    } lh;
  } __mingw_dbl_type_t;

  typedef union __mingw_flt_type_t {
    float x;
    unsigned int val;
  } __mingw_flt_type_t;

  typedef union __mingw_ldbl_type_t
  {
    long double x;
    __extension__ struct {
      unsigned int low, high;
      int sign_exponent : 16;
      int res1 : 16;
      int res0 : 32;
    } lh;
  } __mingw_ldbl_type_t;

  typedef union __mingw_fp_types_t
  {
    long double *ld;
    double *d;
    float *f;
    __mingw_ldbl_type_t *ldt;
    __mingw_dbl_type_t *dt;
    __mingw_flt_type_t *ft;
  } __mingw_fp_types_t;




  extern double * __imp__HUGE;
# 168 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  struct _exception {
    int type;
    const char *name;
    double arg1;
    double arg2;
    double retval;
  };

  void __mingw_raise_matherr (int typ, const char *name, double a1, double a2,
         double rslt);
  void __mingw_setusermatherr (int (__attribute__((__cdecl__)) *)(struct _exception *));
  __attribute__ ((__dllimport__)) void __setusermatherr(int (__attribute__((__cdecl__)) *)(struct _exception *));



  double __attribute__((__cdecl__)) sin(double _X);
  double __attribute__((__cdecl__)) cos(double _X);
  double __attribute__((__cdecl__)) tan(double _X);
  double __attribute__((__cdecl__)) sinh(double _X);
  double __attribute__((__cdecl__)) cosh(double _X);
  double __attribute__((__cdecl__)) tanh(double _X);
  double __attribute__((__cdecl__)) asin(double _X);
  double __attribute__((__cdecl__)) acos(double _X);
  double __attribute__((__cdecl__)) atan(double _X);
  double __attribute__((__cdecl__)) atan2(double _Y,double _X);
  double __attribute__((__cdecl__)) exp(double _X);
  double __attribute__((__cdecl__)) log(double _X);
  double __attribute__((__cdecl__)) log10(double _X);
  double __attribute__((__cdecl__)) pow(double _X,double _Y);
  double __attribute__((__cdecl__)) sqrt(double _X);
  double __attribute__((__cdecl__)) ceil(double _X);
  double __attribute__((__cdecl__)) floor(double _X);


  extern float __attribute__((__cdecl__)) fabsf (float x);
  extern long double __attribute__((__cdecl__)) fabsl (long double);
  extern double __attribute__((__cdecl__)) fabs (double _X);
# 243 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  double __attribute__((__cdecl__)) ldexp(double _X,int _Y);
  double __attribute__((__cdecl__)) frexp(double _X,int *_Y);
  double __attribute__((__cdecl__)) modf(double _X,double *_Y);
  double __attribute__((__cdecl__)) fmod(double _X,double _Y);

  void __attribute__((__cdecl__)) sincos (double __x, double *p_sin, double *p_cos);
  void __attribute__((__cdecl__)) sincosl (long double __x, long double *p_sin, long double *p_cos);
  void __attribute__((__cdecl__)) sincosf (float __x, float *p_sin, float *p_cos);
# 372 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
typedef float float_t;
typedef double double_t;
# 407 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
  extern int __attribute__((__cdecl__)) __fpclassifyf (float);
  extern int __attribute__((__cdecl__)) __fpclassify (double);
# 520 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern int __attribute__((__cdecl__)) __isnan (double);
  extern int __attribute__((__cdecl__)) __isnanf (float);
  extern int __attribute__((__cdecl__)) __isnanl (long double);
# 607 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern int __attribute__((__cdecl__)) __signbit (double);
  extern int __attribute__((__cdecl__)) __signbitf (float);
  extern int __attribute__((__cdecl__)) __signbitl (long double);
# 664 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern float __attribute__((__cdecl__)) sinf(float _X);
  extern long double __attribute__((__cdecl__)) sinl(long double);

  extern float __attribute__((__cdecl__)) cosf(float _X);
  extern long double __attribute__((__cdecl__)) cosl(long double);

  extern float __attribute__((__cdecl__)) tanf(float _X);
  extern long double __attribute__((__cdecl__)) tanl(long double);
  extern float __attribute__((__cdecl__)) asinf(float _X);
  extern long double __attribute__((__cdecl__)) asinl(long double);

  extern float __attribute__((__cdecl__)) acosf (float);
  extern long double __attribute__((__cdecl__)) acosl (long double);

  extern float __attribute__((__cdecl__)) atanf (float);
  extern long double __attribute__((__cdecl__)) atanl (long double);

  extern float __attribute__((__cdecl__)) atan2f (float, float);
  extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


  extern float __attribute__((__cdecl__)) sinhf(float _X);



  extern long double __attribute__((__cdecl__)) sinhl(long double);

  extern float __attribute__((__cdecl__)) coshf(float _X);



  extern long double __attribute__((__cdecl__)) coshl(long double);

  extern float __attribute__((__cdecl__)) tanhf(float _X);



  extern long double __attribute__((__cdecl__)) tanhl(long double);



  extern double __attribute__((__cdecl__)) acosh (double);
  extern float __attribute__((__cdecl__)) acoshf (float);
  extern long double __attribute__((__cdecl__)) acoshl (long double);


  extern double __attribute__((__cdecl__)) asinh (double);
  extern float __attribute__((__cdecl__)) asinhf (float);
  extern long double __attribute__((__cdecl__)) asinhl (long double);


  extern double __attribute__((__cdecl__)) atanh (double);
  extern float __attribute__((__cdecl__)) atanhf (float);
  extern long double __attribute__((__cdecl__)) atanhl (long double);



  extern float __attribute__((__cdecl__)) expf(float _X);



  extern long double __attribute__((__cdecl__)) expl(long double);


  extern double __attribute__((__cdecl__)) exp2(double);
  extern float __attribute__((__cdecl__)) exp2f(float);
  extern long double __attribute__((__cdecl__)) exp2l(long double);



  extern double __attribute__((__cdecl__)) expm1(double);
  extern float __attribute__((__cdecl__)) expm1f(float);
  extern long double __attribute__((__cdecl__)) expm1l(long double);


  extern float frexpf(float _X,int *_Y);



  extern long double __attribute__((__cdecl__)) frexpl(long double,int *);




  extern int __attribute__((__cdecl__)) ilogb (double);
  extern int __attribute__((__cdecl__)) ilogbf (float);
  extern int __attribute__((__cdecl__)) ilogbl (long double);


  extern float __attribute__((__cdecl__)) ldexpf(float _X,int _Y);



  extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


  extern float __attribute__((__cdecl__)) logf (float);
  extern long double __attribute__((__cdecl__)) logl(long double);


  extern float __attribute__((__cdecl__)) log10f (float);
  extern long double __attribute__((__cdecl__)) log10l(long double);


  extern double __attribute__((__cdecl__)) log1p(double);
  extern float __attribute__((__cdecl__)) log1pf(float);
  extern long double __attribute__((__cdecl__)) log1pl(long double);


  extern double __attribute__((__cdecl__)) log2 (double);
  extern float __attribute__((__cdecl__)) log2f (float);
  extern long double __attribute__((__cdecl__)) log2l (long double);


  extern double __attribute__((__cdecl__)) logb (double);
  extern float __attribute__((__cdecl__)) logbf (float);
  extern long double __attribute__((__cdecl__)) logbl (long double);
# 863 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern float __attribute__((__cdecl__)) modff (float, float*);
  extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


  extern double __attribute__((__cdecl__)) scalbn (double, int);
  extern float __attribute__((__cdecl__)) scalbnf (float, int);
  extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

  extern double __attribute__((__cdecl__)) scalbln (double, long);
  extern float __attribute__((__cdecl__)) scalblnf (float, long);
  extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



  extern double __attribute__((__cdecl__)) cbrt (double);
  extern float __attribute__((__cdecl__)) cbrtf (float);
  extern long double __attribute__((__cdecl__)) cbrtl (long double);


  extern double __attribute__((__cdecl__)) hypot (double, double) ;
  extern float __attribute__((__cdecl__)) hypotf (float x, float y);



  extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


  extern float __attribute__((__cdecl__)) powf(float _X,float _Y);



  extern long double __attribute__((__cdecl__)) powl (long double, long double);


  extern float __attribute__((__cdecl__)) sqrtf (float);
  extern long double sqrtl(long double);


  extern double __attribute__((__cdecl__)) erf (double);
  extern float __attribute__((__cdecl__)) erff (float);
  extern long double __attribute__((__cdecl__)) erfl (long double);


  extern double __attribute__((__cdecl__)) erfc (double);
  extern float __attribute__((__cdecl__)) erfcf (float);
  extern long double __attribute__((__cdecl__)) erfcl (long double);


  extern double __attribute__((__cdecl__)) lgamma (double);
  extern float __attribute__((__cdecl__)) lgammaf (float);
  extern long double __attribute__((__cdecl__)) lgammal (long double);

  extern int signgam;


  extern double __attribute__((__cdecl__)) tgamma (double);
  extern float __attribute__((__cdecl__)) tgammaf (float);
  extern long double __attribute__((__cdecl__)) tgammal (long double);


  extern float __attribute__((__cdecl__)) ceilf (float);
  extern long double __attribute__((__cdecl__)) ceill (long double);


  extern float __attribute__((__cdecl__)) floorf (float);
  extern long double __attribute__((__cdecl__)) floorl (long double);


  extern double __attribute__((__cdecl__)) nearbyint ( double);
  extern float __attribute__((__cdecl__)) nearbyintf (float);
  extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

__extension__ long long __attribute__((__cdecl__)) llrint (double);
__extension__ long long __attribute__((__cdecl__)) llrintf (float);
__extension__ long long __attribute__((__cdecl__)) llrintl (long double);
# 1030 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern double __attribute__((__cdecl__)) round (double);
  extern float __attribute__((__cdecl__)) roundf (float);
  extern long double __attribute__((__cdecl__)) roundl (long double);


  extern long __attribute__((__cdecl__)) lround (double);
  extern long __attribute__((__cdecl__)) lroundf (float);
  extern long __attribute__((__cdecl__)) lroundl (long double);
  __extension__ long long __attribute__((__cdecl__)) llround (double);
  __extension__ long long __attribute__((__cdecl__)) llroundf (float);
  __extension__ long long __attribute__((__cdecl__)) llroundl (long double);



  extern double __attribute__((__cdecl__)) trunc (double);
  extern float __attribute__((__cdecl__)) truncf (float);
  extern long double __attribute__((__cdecl__)) truncl (long double);


  extern float __attribute__((__cdecl__)) fmodf (float, float);
  extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


  extern double __attribute__((__cdecl__)) remainder (double, double);
  extern float __attribute__((__cdecl__)) remainderf (float, float);
  extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


  extern double __attribute__((__cdecl__)) remquo(double, double, int *);
  extern float __attribute__((__cdecl__)) remquof(float, float, int *);
  extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


  extern double __attribute__((__cdecl__)) copysign (double, double);
  extern float __attribute__((__cdecl__)) copysignf (float, float);
  extern long double __attribute__((__cdecl__)) copysignl (long double, long double);
# 1087 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern double __attribute__((__cdecl__)) nan(const char *tagp);
  extern float __attribute__((__cdecl__)) nanf(const char *tagp);
  extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
# 1098 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern double __attribute__((__cdecl__)) nextafter (double, double);
  extern float __attribute__((__cdecl__)) nextafterf (float, float);
  extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


  extern double __attribute__((__cdecl__)) nexttoward (double, long double);
  extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
  extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



  extern double __attribute__((__cdecl__)) fdim (double x, double y);
  extern float __attribute__((__cdecl__)) fdimf (float x, float y);
  extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







  extern double __attribute__((__cdecl__)) fmax (double, double);
  extern float __attribute__((__cdecl__)) fmaxf (float, float);
  extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


  extern double __attribute__((__cdecl__)) fmin (double, double);
  extern float __attribute__((__cdecl__)) fminf (float, float);
  extern long double __attribute__((__cdecl__)) fminl (long double, long double);



  extern double __attribute__((__cdecl__)) fma (double, double, double);
  extern float __attribute__((__cdecl__)) fmaf (float, float, float);
  extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
# 1181 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _copysignf (float _Number,float _Sign);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _chgsignf (float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _logbf(float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _nextafterf(float _X,float _Y);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finitef(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnanf(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclassf(float _X);
# 1576 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
}




#pragma pack(pop)
# 46 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 2 3
# 77 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
extern "C++"
{
namespace std
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 0x0400 : 0x4000; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1889 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
}





}
# 37 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 10 "firmware/nnet_utils/nnet_helpers.h" 2

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 1 3
# 12 "firmware/nnet_utils/nnet_helpers.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\vector" 1 3
# 59 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\vector" 3




# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_uninitialized.h" 1 3
# 67 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_uninitialized.h" 3
namespace std
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   if (true)
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__result, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 113 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 179 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 242 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur, __alloc);
                          ;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 378 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
                          ;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
                          ;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      if (true)
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
                          ;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      if (true)
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      if (false)
 {
   std::_Destroy(__first2, __mid2, __alloc);
                          ;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   if (true)
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   if (false)
     {
       std::_Destroy(__first, __cur);
                              ;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur);
                          ;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      if (false)
 {
   std::_Destroy(__result, __cur);
                          ;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 810 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }

  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 883 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_uninitialized.h" 3
}
# 64 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\vector" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 1 3
# 74 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
namespace std
{




  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
# 231 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      {
 _M_deallocate(_M_impl._M_start,
        _M_impl._M_end_of_storage - _M_impl._M_start);
      }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 338 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 351 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::vector must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
   "std::vector must have the same value_type as its allocator");



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 414 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 427 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 458 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 476 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 515 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 541 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 565 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      ~vector() noexcept
      {
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
                                      ;
      }
# 581 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 595 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 616 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 635 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 652 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 680 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 823 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 843 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 875 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 914 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 929 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
                                  ;
 return *(this->_M_impl._M_start + __n);
      }
# 947 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
                                  ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
      }

    public:
# 978 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 996 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
                              ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
                              ;
 return *begin();
      }





      reference
      back() noexcept
      {
                              ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
                              ;
 return *(end() - 1);
      }
# 1054 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 1073 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
                                   ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
                                   ;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args);
# 1111 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
                              ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                                 ;
      }
# 1133 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1149 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1179 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1196 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1221 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1263 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1315 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1342 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1366 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {


                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   if (true)
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   if (false)
     {
       _M_deallocate(__result, __n);
                              ;
     }
 }
# 1419 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
 {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   if (true) {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } if (false) {
     clear();
                            ;
   }
 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1502 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1589 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *reinterpret_cast<_Tp*>(&__buf); }

      private:
 pointer
 _M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 if (size_type __n = this->_M_impl._M_finish - __pos)
   {
     std::_Destroy(__pos, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     this->_M_impl._M_finish = __pos;
                                       ;
   }
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__to_address(__ptr); }
# 1729 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
    };
# 1751 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1768 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



}
# 65 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\vector" 2 3
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_bvector.h" 1 3
# 64 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_bvector.h" 3
namespace std
{



  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
     || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_type * __v,
   unsigned int __first, unsigned int __last, bool __x)
  {
    const _Bit_type __fmask = ~0ul << __first;
    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
    const _Bit_type __mask = __fmask & __lmask;

    if (__x)
      *__v |= __mask;
    else
      *__v &= ~__mask;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 _Bit_type* __first_p = __first._M_p;
 if (__first._M_offset != 0)
   __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);

 __builtin_memset(__first_p, __x ? ~0 : 0,
    (__last._M_p - __first_p) * sizeof(_Bit_type));

 if (__last._M_offset != 0)
   __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
      }
    else if (__first._M_offset != __last._M_offset)
      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl_data
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish)
 , _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_reset(); }

 void
 _M_move_data(_Bvector_impl_data&& __x) noexcept
 {
   this->_M_start = __x._M_start;
   this->_M_finish = __x._M_finish;
   this->_M_end_of_storage = __x._M_end_of_storage;
   __x._M_reset();
 }


 void
 _M_reset() noexcept
 {
   _M_start = _M_finish = _Bit_iterator();
   _M_end_of_storage = _Bit_pointer();
 }
      };

      struct _Bvector_impl
 : public _Bit_alloc_type, public _Bvector_impl_data
 {
 public:
   _Bvector_impl() noexcept(is_nothrow_default_constructible<_Bit_alloc_type>::value)

   : _Bit_alloc_type()
   { }

   _Bvector_impl(const _Bit_alloc_type& __a) noexcept
   : _Bit_alloc_type(__a)
   { }


 _Bvector_impl(_Bvector_impl&&) = default;


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (this->_M_end_of_storage)
     return std::__addressof(this->_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return this->_M_impl; }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }


      _Bvector_base() = default;




      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&&) = default;


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_reset();
   }
      }


      void
      _M_move_data(_Bvector_base&& __x) noexcept
      { _M_impl._M_move_data(std::move(__x._M_impl)); }


      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };



}




namespace std
{
# 587 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_bvector.h" 3
  template<typename _Alloc>
    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
    {
      typedef _Bvector_base<_Alloc> _Base;
      typedef typename _Base::_Bit_pointer _Bit_pointer;
      typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


      friend struct std::hash<vector>;


    public:
      typedef bool value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Bit_reference reference;
      typedef bool const_reference;
      typedef _Bit_reference* pointer;
      typedef const bool* const_pointer;
      typedef _Bit_iterator iterator;
      typedef _Bit_const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_S_nword;
      using _Base::_M_get_Bit_allocator;

    public:

      vector() = default;




      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }


      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : vector(__n, false, __a)
      { }

      vector(size_type __n, const bool& __value,
      const allocator_type& __a = allocator_type())





      : _Base(__a)
      {
 _M_initialize(__n);
 _M_initialize_value(__value);
      }

      vector(const vector& __x)
      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }


      vector(vector&&) = default;

      vector(vector&& __x, const allocator_type& __a)
      noexcept(_Bit_alloc_traits::_S_always_equal())
      : _Base(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_move_data(std::move(__x));
 else
   {
     _M_initialize(__x.size());
     _M_copy_aligned(__x.begin(), __x.end(), begin());
     __x.clear();
   }
      }

      vector(const vector& __x, const allocator_type& __a)
      : _Base(__a)
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }

      vector(initializer_list<bool> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_initialize_range(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 710 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_bvector.h" 3
      ~vector() noexcept { }

      vector&
      operator=(const vector& __x)
      {
 if (&__x == this)
   return *this;

 if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
   {
     if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
       {
  this->_M_deallocate();
  std::__alloc_on_copy(_M_get_Bit_allocator(),
         __x._M_get_Bit_allocator());
  _M_initialize(__x.size());
       }
     else
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
   }

 if (__x.size() > capacity())
   {
     this->_M_deallocate();
     _M_initialize(__x.size());
   }
 this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
        begin());
 return *this;
      }


      vector&
      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
      {
 if (_Bit_alloc_traits::_S_propagate_on_move_assign()
     || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
   {
     this->_M_deallocate();
     this->_M_move_data(std::move(__x));
     std::__alloc_on_move(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
   }
 else
   {
     if (__x.size() > capacity())
       {
  this->_M_deallocate();
  _M_initialize(__x.size());
       }
     this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
            begin());
     __x.clear();
   }
 return *this;
      }

      vector&
      operator=(initializer_list<bool> __l)
      {
 this->assign (__l.begin(), __l.end());
 return *this;
      }






      void
      assign(size_type __n, const bool& __x)
      { _M_fill_assign(__n, __x); }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 801 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_bvector.h" 3
      void
      assign(initializer_list<bool> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }


      iterator
      begin() noexcept
      { return this->_M_impl._M_start; }

      const_iterator
      begin() const noexcept
      { return this->_M_impl._M_start; }

      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }

      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }


      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }

      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      size_type
      size() const noexcept
      { return size_type(end() - begin()); }

      size_type
      max_size() const noexcept
      {
 const size_type __isize =
   __gnu_cxx::__numeric_traits<difference_type>::__max
   - int(_S_word_bit) + 1;
 const size_type __asize
   = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
 return (__asize <= __isize / int(_S_word_bit)
  ? __asize * int(_S_word_bit) : __isize);
      }

      size_type
      capacity() const noexcept
      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
    - begin()); }

      bool
      empty() const noexcept
      { return begin() == end(); }

      reference
      operator[](size_type __n)
      {
 return *iterator(this->_M_impl._M_start._M_p
    + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

      const_reference
      operator[](size_type __n) const
      {
 return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
      }

    public:
      reference
      at(size_type __n)
      { _M_range_check(__n); return (*this)[__n]; }

      const_reference
      at(size_type __n) const
      { _M_range_check(__n); return (*this)[__n]; }

      void
      reserve(size_type __n)
      {
 if (__n > max_size())
   __throw_length_error(("vector::reserve"));
 if (capacity() < __n)
   _M_reallocate(__n);
      }

      reference
      front()
      { return *begin(); }

      const_reference
      front() const
      { return *begin(); }

      reference
      back()
      { return *(end() - 1); }

      const_reference
      back() const
      { return *(end() - 1); }






      void
      data() noexcept { }

      void
      push_back(bool __x)
      {
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(end(), __x);
      }

      void
      swap(vector& __x) noexcept
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);
 _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
      }


      static void
      swap(reference __x, reference __y) noexcept
      {
 bool __tmp = __x;
 __x = __y;
 __y = __tmp;
      }

      iterator

      insert(const_iterator __position, const bool& __x = bool())



      {
 const difference_type __n = __position - begin();
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
     && __position == end())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(__position._M_const_cast(), __x);
 return begin() + __n;
      }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position,
        _InputIterator __first, _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1017 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_bvector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const bool& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }







      iterator
      insert(const_iterator __p, initializer_list<bool> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }


      void
      pop_back()
      { --this->_M_impl._M_finish; }

      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }

      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

      void
      resize(size_type __new_size, bool __x = bool())
      {
 if (__new_size < size())
   _M_erase_at_end(begin() + difference_type(__new_size));
 else
   insert(end(), __new_size - size(), __x);
      }


      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }


      void
      flip() noexcept
      {
 _Bit_type * const __end = this->_M_impl._M_end_addr();
 for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
   *__p = ~*__p;
      }

      void
      clear() noexcept
      { _M_erase_at_end(begin()); }


      template<typename... _Args>



 void

 emplace_back(_Args&&... __args)
 {
   push_back(bool(__args...));



 }

      template<typename... _Args>
 iterator
 emplace(const_iterator __pos, _Args&&... __args)
 { return insert(__pos, bool(__args...)); }


    protected:

      iterator
      _M_copy_aligned(const_iterator __first, const_iterator __last,
        iterator __result)
      {
 _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
 return std::copy(const_iterator(__last._M_p, 0), __last,
    iterator(__q, 0));
      }

      void
      _M_initialize(size_type __n)
      {
 if (__n)
   {
     _Bit_pointer __q = this->_M_allocate(__n);
     this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
     this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
   }
 else
   {
     this->_M_impl._M_end_of_storage = _Bit_pointer();
     this->_M_impl._M_start = iterator(0, 0);
   }
 this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);

      }

      void
      _M_initialize_value(bool __x)
      {
 if (_Bit_type* __p = this->_M_impl._M_start._M_p)
   __builtin_memset(__p, __x ? ~0 : 0,
      (this->_M_impl._M_end_addr() - __p)
      * sizeof(_Bit_type));
      }

      void
      _M_reallocate(size_type __n);


      bool
      _M_shrink_to_fit();






      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
 {
   _M_initialize(static_cast<size_type>(__n));
   _M_initialize_value(__x);
 }

      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 { _M_initialize_range(__first, __last,
         std::__iterator_category(__first)); }

      template<typename _InputIterator>
 void
 _M_initialize_range(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }

      template<typename _ForwardIterator>
 void
 _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   _M_initialize(__n);
   std::copy(__first, __last, this->_M_impl._M_start);
 }
# 1203 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/stl_bvector.h" 3
      void
      _M_fill_assign(size_t __n, bool __x)
      {
 if (__n > size())
   {
     _M_initialize_value(__x);
     insert(end(), __n - size(), __x);
   }
 else
   {
     _M_erase_at_end(begin() + __n);
     _M_initialize_value(__x);
   }
      }

      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag)
 {
   iterator __cur = begin();
   for (; __first != __last && __cur != end(); ++__cur, ++__first)
     *__cur = *__first;
   if (__first == __last)
     _M_erase_at_end(__cur);
   else
     insert(end(), __first, __last);
 }

      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len < size())
     _M_erase_at_end(std::copy(__first, __last, begin()));
   else
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
 }





      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
 { _M_fill_insert(__pos, __n, __x); }

      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_insert_range(__pos, __first, __last,
     std::__iterator_category(__first)); }

      void
      _M_fill_insert(iterator __position, size_type __n, bool __x);

      template<typename _InputIterator>
 void
 _M_insert_range(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     {
       __pos = insert(__pos, *__first);
       ++__pos;
     }
 }

      template<typename _ForwardIterator>
 void
 _M_insert_range(iterator __position, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);

      void
      _M_insert_aux(iterator __position, bool __x);

      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      void
      _M_erase_at_end(iterator __pos)
      { this->_M_impl._M_finish = __pos; }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);
  };



}



namespace std
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\vector" 2 3



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/vector.tcc" 1 3
# 59 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/vector.tcc" 3
namespace std
{



  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
                                ;
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
                                   ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
                                   ;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);



      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
                                   ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
                                   ;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                                      ;
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
                                ;

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   const size_type __add = __n - size();
                                     ;
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __add, __val, _M_get_Tp_allocator());
                                     ;
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                                  ;
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     const size_type __attribute__((__unused__)) __n = __len - size();
                                     ;
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
                                     ;
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
                                   ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
                                   ;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
                                     ;
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
                                     ;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
                                    ;
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1)));
      ++this->_M_impl._M_finish;
                                    ;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);





      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      pointer __old_start = this->_M_impl._M_start;
      pointer __old_finish = this->_M_impl._M_finish;
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      if (true)
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (__old_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

   ++__new_finish;

   __new_finish
     = std::__uninitialized_move_if_noexcept_a
     (__position.base(), __old_finish,
      __new_finish, _M_get_Tp_allocator());
 }
      if (false)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
                          ;
 }
                                   ;
      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      _M_deallocate(__old_start,
      this->_M_impl._M_end_of_storage - __old_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
                                    ;
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
                                    ;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
                                    ;
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
                                                    ;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
                                              ;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       if (true)
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       if (false)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
                           ;
  }
                                    ;
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   const size_type __size = size();
   size_type __navail = size_type(this->_M_impl._M_end_of_storage
      - this->_M_impl._M_finish);

   if (__size > max_size() || __navail > max_size() - __size)
     __builtin_unreachable();

   if (__navail >= __n)
     {
                                       ;
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
                                       ;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       pointer __new_start(this->_M_allocate(__len));
       pointer __destroy_from = pointer();
       if (true)
  {
    std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
    __destroy_from = __new_start + __size;
    std::__uninitialized_move_if_noexcept_a(
        this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());
  }
       if (false)
  {
    if (__destroy_from)
      std::_Destroy(__destroy_from, __destroy_from + __n,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
                           ;
  }
                                    ;
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
                                   ;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 if (__pos == end())
   {
     for (; __first != __last; ++__first)
       insert(end(), *__first);
   }
 else if (__first != __last)
   {
     vector __tmp(__first, __last, _M_get_Tp_allocator());
     insert(__pos,
     std::make_move_iterator(__tmp.begin()),
     std::make_move_iterator(__tmp.end()));
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
                                      ;
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
                                      ;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
                                      ;
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
                                                      ;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
                                                ;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  if (true)
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  if (false)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
                             ;
    }
                               ;
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      if (true)
 {
   _M_reallocate(size());
   return true;
 }
      if (false)
 { return false; }
    }




}



namespace std
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\vector" 2 3
# 13 "firmware/nnet_utils/nnet_helpers.h" 2

namespace nnet {
# 252 "firmware/nnet_utils/nnet_helpers.h"
template <class src_T, class dst_T, size_t OFFSET, size_t SIZE> void copy_data(std::vector<src_T> src, dst_T dst[SIZE]) {
    typename std::vector<src_T>::const_iterator in_begin = src.cbegin() + OFFSET;
    typename std::vector<src_T>::const_iterator in_end = in_begin + SIZE;
    std::copy(in_begin, in_end, dst);
}

template <class src_T, class dst_T, size_t OFFSET, size_t SIZE>
void copy_data(std::vector<src_T> src, hls::stream<dst_T> &dst) {
    typename std::vector<src_T>::const_iterator in_begin = src.cbegin() + OFFSET;
    typename std::vector<src_T>::const_iterator in_end = in_begin + SIZE;

    size_t i_pack = 0;
    dst_T dst_pack;
    VITIS_LOOP_265_1: for (typename std::vector<src_T>::const_iterator i = in_begin; i != in_end; ++i) {
        dst_pack[i_pack++] = typename dst_T::value_type(*i);
        if (i_pack == dst_T::size) {
            i_pack = 0;
            dst.write(dst_pack);
        }
    }
}

template <class src_T, class dst_T, size_t OFFSET, size_t SIZE> void copy_data_axi(std::vector<src_T> src, dst_T dst[SIZE]) {
    VITIS_LOOP_275_1: for (auto i = 0; i < SIZE; i++)
        if (i == SIZE - 1) {
            dst[i].data = src[i];
            dst[i].last = 1;
        } else {
            dst[i].data = src[i];
            dst[i].last = 0;
        }
}

template <class res_T, size_t SIZE> void print_result(res_T result[SIZE], std::ostream &out, bool keep = false) {
    VITIS_LOOP_286_1: for (int i = 0; i < SIZE; i++) {
        out << result[i] << " ";
    }
    out << std::endl;
}

template <class res_T, size_t SIZE> void print_result(hls::stream<res_T> &result, std::ostream &out, bool keep = false) {
    VITIS_LOOP_293_1: for (int i = 0; i < SIZE / res_T::size; i++) {
        res_T res_pack = result.read();
        VITIS_LOOP_295_2: for (int j = 0; j < res_T::size; j++) {
            out << res_pack[j] << " ";
        }
        if (keep)
            result.write(res_pack);
    }
    out << std::endl;
}

template <class data_T, size_t SIZE> void fill_zero(data_T data[SIZE]) { std::fill_n(data, SIZE, 0.); }

template <class data_T, size_t SIZE> void fill_zero(hls::stream<data_T> &data) {
    VITIS_LOOP_307_1: for (int i = 0; i < SIZE / data_T::size; i++) {
        data_T data_pack;
        VITIS_LOOP_309_2: for (int j = 0; j < data_T::size; j++) {
            data_pack[j] = 0.;
        }
        data.write(data_pack);
    }
}

template <class dataType, unsigned int nrows> int read_file_1D(const char *filename, dataType data[nrows]) {
    FILE *fp;
    fp = fopen(filename, "r");
    if (fp == 0) {
        return -1;
    }

    float newval;
    VITIS_LOOP_324_1: for (int ii = 0; ii < nrows; ii++) {
        if (fscanf(fp, "%f\n", &newval) != 0) {
            data[ii] = newval;
        } else {
            return -2;
        }
    }
    fclose(fp);
    return 0;
}

template <class dataType, unsigned int nrows, unsigned int ncols>
int read_file_2D(const char *filename, dataType data[nrows][ncols]) {
    FILE *fp;
    fp = fopen(filename, "r");
    if (fp == 0) {
        return -1;
    }

    float newval;
    VITIS_LOOP_344_1: for (int ii = 0; ii < nrows; ii++) {
        VITIS_LOOP_345_2: for (int jj = 0; jj < ncols; jj++) {
            if (fscanf(fp, "%f\n", &newval) != 0) {
                data[ii][jj] = newval;
            } else {
                return -2;
            }
        }
    }
    fclose(fp);
    return 0;
}

template <class in_T, class out_T, int N_IN> void change_type(hls::stream<in_T> &in, hls::stream<out_T> &out) {
    in_T datareg;
    hls::stream<out_T> input_trunc;
    VITIS_LOOP_360_1: for (int ii = 0; ii < N_IN; ii++) {
        out << (out_T)in.read();
    }
}

template <class data_T, int N_IN> void hls_stream_debug(hls::stream<data_T> &data, hls::stream<data_T> &res) {
    data_T datareg;
    VITIS_LOOP_367_1: for (int ii = 0; ii < N_IN; ii++) {
        datareg = data.read();
        std::cout << "[" << ii << "]: " << datareg << std::endl;
        res << datareg;
    }
}

constexpr int ceillog2(int x) { return (x <= 2) ? 1 : 1 + ceillog2((x + 1) / 2); }

constexpr int floorlog2(int x) { return (x < 2) ? 0 : 1 + floorlog2(x / 2); }

constexpr int pow2(int x) { return x == 0 ? 1 : 2 * pow2(x - 1); }

}
# 6 "firmware/nnet_utils/nnet_common.h" 2
# 23 "firmware/nnet_utils/nnet_common.h"
namespace nnet {


enum io_type { io_parallel = 0, io_stream };
enum strategy { latency, resource, resource_unrolled };
# 37 "firmware/nnet_utils/nnet_common.h"
template <class T, int N, class Op> T reduce(const T *x, Op op) {
    static constexpr int leftN = pow2(floorlog2(N - 1)) > 0 ? pow2(floorlog2(N - 1)) : 0;
    static constexpr int rightN = N - leftN > 0 ? N - leftN : 0;
    if (N == 1) {
        return x[0];
    }
    if (N == 2) {
        return op(x[0], x[1]);
    }
    return op(reduce<T, leftN, Op>(x, op), reduce<T, rightN, Op>(x + leftN, op));
}

template <class T> class Op_add {
  public:
    T operator()(T a, T b) { return a + b; }
};

template <class T> class Op_and {
  public:
    T operator()(T a, T b) { return a && b; }
};

template <class T> class Op_or {
  public:
    T operator()(T a, T b) { return a || b; }
};

template <class T> class Op_max {
  public:
    T operator()(T a, T b) { return a >= b ? a : b; }
};

template <class T> class Op_min {
  public:
    T operator()(T a, T b) { return a <= b ? a : b; }
};

}
# 5 "firmware/nnet_utils/nnet_conv1d_latency.h" 2
# 1 "firmware/nnet_utils/nnet_mult.h" 1







# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\math.h" 1 3
# 9 "firmware/nnet_utils/nnet_mult.h" 2

namespace nnet {

namespace product {






class Product {};

template <class x_T, class w_T> class both_binary : public Product {
  public:
    static x_T product(x_T a, w_T w) {

#pragma HLS INLINE
 return a == w;
    }
};

template <class x_T, class w_T> class weight_binary : public Product {
  public:
    static auto product(x_T a, w_T w) -> decltype(-a) {

#pragma HLS INLINE
 if (w == 0)
            return -a;
        else
            return a;
    }
};

template <class x_T, class w_T> class data_binary : public Product {
  public:
    static auto product(x_T a, w_T w) -> decltype(-w) {

#pragma HLS INLINE
 if (a == 0)
            return -w;
        else
            return w;
    }
};

template <class x_T, class w_T> class weight_ternary : public Product {
  public:
    static auto product(x_T a, w_T w) -> decltype(-a) {

#pragma HLS INLINE
 if (w == 0)
            return 0;
        else if (w == -1)
            return -a;
        else
            return a;
    }
};

template <class x_T, class w_T> class mult : public Product {
  public:
    static auto product(x_T a, w_T w) -> decltype(a * w) {

#pragma HLS INLINE
 return a * w;
    }
};

template <class x_T, class w_T> class weight_exponential : public Product {
  public:
    using r_T = ap_fixed<2 * (decltype(w_T::weight)::width + x_T::width), (decltype(w_T::weight)::width + x_T::width)>;
    static r_T product(x_T a, w_T w) {

#pragma HLS INLINE


 r_T y = static_cast<r_T>(a) << w.weight;


        return w.sign == 1 ? y : static_cast<r_T>(-y);
    }
};

}

template <class data_T, class res_T, typename CONFIG_T>
inline typename std::enable_if<std::is_same<data_T, ap_uint<1>>::value &&
                                   std::is_same<typename CONFIG_T::weight_t, ap_uint<1>>::value,
                               ap_int<nnet::ceillog2(CONFIG_T::n_in) + 2>>::type
cast(typename CONFIG_T::accum_t x) {
    return (ap_int<nnet::ceillog2(CONFIG_T::n_in) + 2>)(x - CONFIG_T::n_in / 2) * 2;
}

template <class data_T, class res_T, typename CONFIG_T>
inline typename std::enable_if<
    std::is_same<data_T, ap_uint<1>>::value && !std::is_same<typename CONFIG_T::weight_t, ap_uint<1>>::value, res_T>::type
cast(typename CONFIG_T::accum_t x) {
    return (res_T)x;
}

template <class data_T, class res_T, typename CONFIG_T>
inline typename std::enable_if<(!std::is_same<data_T, ap_uint<1>>::value), res_T>::type cast(typename CONFIG_T::accum_t x) {
    return (res_T)x;
}

}
# 6 "firmware/nnet_utils/nnet_conv1d_latency.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
# 7 "firmware/nnet_utils/nnet_conv1d_latency.h" 2

namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void conv_1d_latency_cl(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan],
                        res_T res[CONFIG_T::out_width * CONFIG_T::n_filt],
                        typename CONFIG_T::weight_t weights[CONFIG_T::filt_width * CONFIG_T::n_chan * CONFIG_T::n_filt],
                        typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {
    constexpr unsigned mult_n_in = CONFIG_T::filt_width * CONFIG_T::n_chan;
    constexpr unsigned mult_n_out = CONFIG_T::n_filt;

    data_T data_buf[CONFIG_T::n_pixels][mult_n_in];
#pragma HLS ARRAY_PARTITION variable=data_buf complete dim=0

 typename CONFIG_T::accum_t mult[mult_n_in * mult_n_out];
#pragma HLS ARRAY_PARTITION variable=mult complete

 typename CONFIG_T::accum_t acc[mult_n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete

#pragma HLS ARRAY_PARTITION variable=weights complete
#pragma HLS ARRAY_PARTITION variable=biases complete


#pragma HLS ALLOCATION operation instances=mul limit=CONFIG_T::mult_config::multiplier_limit

PartitionLoop:
    for (int i_part = 0; i_part < CONFIG_T::n_partitions; i_part++) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor rewind

 CONFIG_T::template fill_buffer<data_T, CONFIG_T>::fill_buffer(data, data_buf, i_part);

    PixelLoop:
        for (unsigned i_pxl = 0; i_pxl < CONFIG_T::n_pixels; i_pxl++) {
#pragma HLS UNROLL

 data_T cache;


        Product1:
            for (int i_in = 0; i_in < mult_n_in; i_in++) {
#pragma HLS UNROLL
 cache = data_buf[i_pxl][i_in];
            Product2:
                for (int i_out = 0; i_out < mult_n_out; i_out++) {
#pragma HLS UNROLL
 mult[i_in * mult_n_out + i_out] =
                        CONFIG_T::mult_config::template product<data_T, typename CONFIG_T::mult_config::weight_t>::product(
                            cache, weights[i_in * mult_n_out + i_out]);
                }
            }


        ResetAccum:
            for (int i_acc = 0; i_acc < mult_n_out; i_acc++) {
#pragma HLS UNROLL
 acc[i_acc] = (typename CONFIG_T::accum_t)biases[i_acc];
            }


        Accum1:
            for (int i_in = 0; i_in < mult_n_in; i_in++) {
#pragma HLS UNROLL
 Accum2:
                for (int i_out = 0; i_out < mult_n_out; i_out++) {
#pragma HLS UNROLL
 acc[i_out] += mult[i_in * mult_n_out + i_out];
                }
            }


        Result:
            for (int i_res = 0; i_res < mult_n_out; i_res++) {
#pragma HLS UNROLL
 res[i_part * CONFIG_T::n_pixels * mult_n_out + i_pxl * mult_n_out + i_res] =
                    cast<data_T, res_T, typename CONFIG_T::mult_config>(acc[i_res]);
            }
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void pointwise_conv_1d_latency_cl(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan / CONFIG_T::reuse_factor],
                                  res_T res[CONFIG_T::out_width * CONFIG_T::n_filt / CONFIG_T::reuse_factor],
                                  typename CONFIG_T::weight_t weights[CONFIG_T::n_chan * CONFIG_T::n_filt],
                                  typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {
    ({ bool _AssertPred = CONFIG_T::filt_width == 1; __builtin_assume(_AssertPred); });

    typename CONFIG_T::accum_t mult[CONFIG_T::out_width * CONFIG_T::n_filt * CONFIG_T::n_chan / CONFIG_T::reuse_factor];
    typename CONFIG_T::accum_t acc[CONFIG_T::out_width / CONFIG_T::reuse_factor][CONFIG_T::n_filt];

#pragma HLS ARRAY_PARTITION variable=mult complete dim=0
#pragma HLS ARRAY_PARTITION variable=acc complete dim=0


#pragma HLS function_instantiate variable=weights,biases


#pragma HLS PIPELINE II=CONFIG_T::reuse_factor
#pragma HLS ARRAY_PARTITION variable=weights complete dim=0
#pragma HLS ARRAY_PARTITION variable=biases complete dim=0


#pragma HLS ALLOCATION operation instances=mul limit=CONFIG_T::mult_config::multiplier_limit


ConvOut:
    for (int ii = 0; ii < CONFIG_T::out_width / CONFIG_T::reuse_factor; ii++) {
    ConvFilt:
        for (int ff = 0; ff < CONFIG_T::n_filt; ff++) {
        ConvChan:
            for (int cc = 0; cc < CONFIG_T::n_chan; cc++) {
#pragma HLS UNROLL
 int index_mult = ii * CONFIG_T::n_filt * CONFIG_T::n_chan + ff * CONFIG_T::n_chan + cc;
                int index_weight = cc * CONFIG_T::n_filt + ff;
                int index_data = (ii * CONFIG_T::stride_width - CONFIG_T::pad_left) * CONFIG_T::n_chan + cc;

                if ((ii * CONFIG_T::stride_width) < CONFIG_T::pad_left ||
                    (ii * CONFIG_T::stride_width) >= (CONFIG_T::pad_left + CONFIG_T::in_width)) {
                    mult[index_mult] = 0;
                } else {
                    mult[index_mult] = CONFIG_T::mult_config::template product<data_T, typename CONFIG_T::weight_t>::product(
                        data[index_data], weights[index_weight]);
                }
            }
        }
    }


    VITIS_LOOP_136_1: for (int ii = 0; ii < CONFIG_T::out_width / CONFIG_T::reuse_factor; ii++) {
        VITIS_LOOP_137_2: for (int ff = 0; ff < CONFIG_T::n_filt; ff++) {
#pragma HLS UNROLL
 acc[ii][ff] = biases[ff];
        }
    }


AccumOut:
    for (int ii = 0; ii < CONFIG_T::out_width / CONFIG_T::reuse_factor; ii++) {
    AccumFilt:
        for (int ff = 0; ff < CONFIG_T::n_filt; ff++) {

        AccumChan:
            for (int cc = 0; cc < CONFIG_T::n_chan; cc++) {
                int index_mult = ii * CONFIG_T::n_filt * CONFIG_T::n_chan + ff * CONFIG_T::n_chan + cc;
                acc[ii][ff] += mult[index_mult];
            }
        }
    }


    VITIS_LOOP_158_3: for (int ii = 0; ii < CONFIG_T::out_width / CONFIG_T::reuse_factor; ii++) {
        VITIS_LOOP_159_4: for (int ff = 0; ff < CONFIG_T::n_filt; ff++) {
#pragma HLS UNROLL
 res[ii * CONFIG_T::n_filt + ff] = cast<data_T, res_T, typename CONFIG_T::mult_config>(acc[ii][ff]);
        }
    }
}

}
# 5 "firmware/nnet_utils/nnet_code_gen.h" 2




# 1 "firmware/nnet_utils/nnet_function_stubs.h" 1
# 10 "firmware/nnet_utils/nnet_function_stubs.h"
namespace nnet {

template <class data_T, typename CONFIG_T> class FillConv1DBuffer {
  public:
    static void fill_buffer(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan],
                            data_T buffer[CONFIG_T::n_pixels][CONFIG_T::filt_width * CONFIG_T::n_chan],
                            const unsigned partition) {

    }
};

template <class data_T, typename CONFIG_T> class FillConv2DBuffer {
  public:
    static void
    fill_buffer(data_T data[CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::n_chan],
                data_T buffer[CONFIG_T::n_pixels][CONFIG_T::filt_height * CONFIG_T::filt_width * CONFIG_T::n_chan],
                const unsigned partition) {

    }
};

template <class data_T, class res_T, typename CONFIG_T> class DenseKernel {
  public:
    static void dense(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                      typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                      typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    }
};

template <class data_T, class res_T, typename CONFIG_T> class DepthwiseDenseKernel {
  public:
    static void dense(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                      typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                      typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    }
};

template <class data_T, class res_T, typename CONFIG_T> class Conv1DKernel {
  public:
    static void conv(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan], res_T res[CONFIG_T::out_width * CONFIG_T::n_filt],
                     typename CONFIG_T::weight_t weights[CONFIG_T::n_chan * CONFIG_T::n_filt],
                     typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {

    }
};

}
# 10 "firmware/nnet_utils/nnet_code_gen.h" 2


namespace nnet {

template <class data_T, class res_T, typename CONFIG_T> class PointwiseConv1D {
  public:
    static void pointwise_conv(data_T data[CONFIG_T::in_width * CONFIG_T::n_chan],
                               res_T res[CONFIG_T::out_width * CONFIG_T::n_filt],
                               typename CONFIG_T::weight_t weights[CONFIG_T::n_chan * CONFIG_T::n_filt],
                               typename CONFIG_T::bias_t biases[CONFIG_T::n_filt]) {

    }
};



}
# 8 "firmware/parameters.h" 2


# 1 "firmware/nnet_utils/nnet_activation.h" 1





# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
# 7 "firmware/nnet_utils/nnet_activation.h" 2

namespace nnet {

struct activ_config {

    static const unsigned n_in = 10;


    static const unsigned table_size = 1024;


    static const unsigned io_type = io_parallel;
    static const unsigned reuse_factor = 1;


    typedef ap_fixed<18, 8> table_t;
};




template <class data_T, class res_T, typename CONFIG_T> void linear(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 VITIS_LOOP_31_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        res[ii] = data[ii];
    }
}




template <class data_T, class res_T, typename CONFIG_T> void relu(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    VITIS_LOOP_43_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > 0)
            res[ii] = datareg;
        else
            res[ii] = 0;
    }
}

template <class data_T, class res_T, int MAX_INT, typename CONFIG_T>
void relu_max(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    VITIS_LOOP_57_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg < 0)
            res[ii] = 0;
        else if (datareg > MAX_INT)
            res[ii] = MAX_INT;
        else
            res[ii] = datareg;
    }
}

template <class data_T, class res_T, typename CONFIG_T> void relu6(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    relu_max<data_T, res_T, 6, CONFIG_T>(data, res);
}

template <class data_T, class res_T, typename CONFIG_T> void relu1(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    relu_max<data_T, res_T, 1, CONFIG_T>(data, res);
}




inline float sigmoid_fcn_float(float input) { return 1.0 / (1 + std::exp(-input)); }

template <typename CONFIG_T, int N_TABLE> void init_sigmoid_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    VITIS_LOOP_84_1: for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 8.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = sigmoid_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void sigmoid(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t sigmoid_table[CONFIG_T::table_size];




    if (!initialized) {
        init_sigmoid_table<CONFIG_T, CONFIG_T::table_size>(sigmoid_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 int data_round;
    int index;
    VITIS_LOOP_114_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_round = data[ii] * CONFIG_T::table_size / 16;
        index = data_round + 8 * CONFIG_T::table_size / 16;
        if (index < 0)
            index = 0;
        if (index > CONFIG_T::table_size - 1)
            index = CONFIG_T::table_size - 1;
        res[ii] = (res_T)sigmoid_table[index];
    }
}





enum class softmax_implementation { latency = 0, legacy = 1, stable = 2, argmax = 3 };

inline float exp_fcn_float(float input) { return std::exp(input); }

template <class data_T, typename CONFIG_T> inline float softmax_real_val_from_idx(unsigned i) {

    static constexpr int N = ceillog2(CONFIG_T::table_size);
    data_T x(0);
    x(x.width - 1, x.width - N) = i;
    return (float)x;
}

template <class data_T, typename CONFIG_T> inline unsigned softmax_idx_from_real_val(data_T x) {

    static constexpr int N = ceillog2(CONFIG_T::table_size);
    ap_uint<N> y = x(x.width - 1, x.width - N);
    return (unsigned)y(N - 1, 0);
}

template <class data_T, typename CONFIG_T>
void init_exp_table(typename CONFIG_T::exp_table_t table_out[CONFIG_T::table_size]) {

    VITIS_LOOP_151_1: for (unsigned i = 0; i < CONFIG_T::table_size; i++) {

        float x = softmax_real_val_from_idx<data_T, CONFIG_T>(i);
        typename CONFIG_T::exp_table_t exp_x = exp_fcn_float(x);
        table_out[i] = exp_x;
    }
}

template <class data_T, typename CONFIG_T>
void init_invert_table(typename CONFIG_T::inv_table_t table_out[CONFIG_T::table_size]) {

    VITIS_LOOP_162_1: for (unsigned i = 0; i < CONFIG_T::table_size; i++) {
        float x = softmax_real_val_from_idx<data_T, CONFIG_T>(i);
        typename CONFIG_T::inv_table_t inv_x = 1 / x;
        table_out[i] = inv_x;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_latency(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS pipeline


 bool initialized = false;
    typename CONFIG_T::exp_table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::inv_table_t invert_table[CONFIG_T::table_size];






    if (!initialized) {

        init_exp_table<data_T, CONFIG_T>(exp_table);

        init_invert_table<typename CONFIG_T::exp_table_t, CONFIG_T>(invert_table);
        initialized = true;
    }


    typename CONFIG_T::exp_table_t exp_res[CONFIG_T::n_in];
#pragma HLS array_partition variable=exp_res complete
 typename CONFIG_T::exp_table_t exp_sum(0);
    VITIS_LOOP_195_1: for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 unsigned x = softmax_idx_from_real_val<data_T, CONFIG_T>(data[i]);
        exp_res[i] = exp_table[x];
    }



    Op_add<typename CONFIG_T::exp_table_t> op_add;
    exp_sum =
        reduce<typename CONFIG_T::exp_table_t, CONFIG_T::n_in, Op_add<typename CONFIG_T::exp_table_t>>(exp_res, op_add);

    typename CONFIG_T::inv_table_t inv_exp_sum =
        invert_table[softmax_idx_from_real_val<typename CONFIG_T::exp_table_t, CONFIG_T>(exp_sum)];
    VITIS_LOOP_209_2: for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 res[i] = exp_res[i] * inv_exp_sum;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_stable(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS pipeline


 bool initialized = false;
    typename CONFIG_T::exp_table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::inv_table_t invert_table[CONFIG_T::table_size];






    if (!initialized) {

        init_exp_table<data_T, CONFIG_T>(exp_table);

        init_invert_table<typename CONFIG_T::exp_table_t, CONFIG_T>(invert_table);
        initialized = true;
    }


    Op_max<data_T> op_max;
    data_T x_max = reduce<data_T, CONFIG_T::n_in, Op_max<data_T>>(data, op_max);


    ap_fixed<data_T::width, data_T::iwidth, AP_RND, AP_SAT> d_xi_xmax[CONFIG_T::n_in];
    VITIS_LOOP_243_1: for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 d_xi_xmax[i] = data[i] - x_max;
    }


    typename CONFIG_T::exp_table_t exp_res[CONFIG_T::n_in];
#pragma HLS array_partition variable=exp_res complete
 typename CONFIG_T::exp_table_t exp_sum(0);
    VITIS_LOOP_252_2: for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 unsigned x = softmax_idx_from_real_val<data_T, CONFIG_T>(d_xi_xmax[i]);
        exp_res[i] = exp_table[x];
    }



    Op_add<typename CONFIG_T::exp_table_t> op_add;
    exp_sum =
        reduce<typename CONFIG_T::exp_table_t, CONFIG_T::n_in, Op_add<typename CONFIG_T::exp_table_t>>(exp_res, op_add);

    typename CONFIG_T::inv_table_t inv_exp_sum =
        invert_table[softmax_idx_from_real_val<typename CONFIG_T::exp_table_t, CONFIG_T>(exp_sum)];
    VITIS_LOOP_266_3: for (unsigned i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS unroll
 res[i] = exp_res[i] * inv_exp_sum;
    }
}

template <typename CONFIG_T, int N_TABLE> void init_exp_table_legacy(typename CONFIG_T::table_t table_out[N_TABLE]) {
    VITIS_LOOP_273_1: for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 8.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = exp_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <typename CONFIG_T, int N_TABLE> void init_invert_table_legacy(typename CONFIG_T::table_t table_out[N_TABLE]) {


    VITIS_LOOP_286_1: for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 64.0 * ii / float(N_TABLE);

        if (in_val > 0.0)
            table_out[ii] = 1.0 / in_val;
        else
            table_out[ii] = 0.0;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_legacy(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::table_t invert_table[CONFIG_T::table_size];





    if (!initialized) {
        init_exp_table_legacy<CONFIG_T, CONFIG_T::table_size>(exp_table);
        init_invert_table_legacy<CONFIG_T, CONFIG_T::table_size>(invert_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 typename CONFIG_T::table_t exp_res[CONFIG_T::n_in];
    typename CONFIG_T::table_t exp_diff_res;
    data_T data_cache[CONFIG_T::n_in];
    int data_round;
    int index;
    VITIS_LOOP_323_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_cache[ii] = data[ii];
        exp_res[ii] = 0;
    }

    VITIS_LOOP_328_2: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        VITIS_LOOP_329_3: for (int jj = 0; jj < CONFIG_T::n_in; jj++) {
            if (ii == jj)
                exp_diff_res = 1;
            else {
                data_round = (data_cache[jj] - data_cache[ii]) * CONFIG_T::table_size / 16;
                index = data_round + 8 * CONFIG_T::table_size / 16;
                if (index < 0)
                    index = 0;
                if (index > CONFIG_T::table_size - 1)
                    index = CONFIG_T::table_size - 1;
                exp_diff_res = exp_table[index];
            }
            exp_res[ii] += exp_diff_res;
        }
    }


    VITIS_LOOP_346_4: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        int exp_res_index = exp_res[ii] * CONFIG_T::table_size / 64;
        if (exp_res_index < 0)
            exp_res_index = 0;
        if (exp_res_index > CONFIG_T::table_size - 1)
            exp_res_index = CONFIG_T::table_size - 1;

        res[ii] = (res_T)invert_table[exp_res_index];
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_argmax(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    VITIS_LOOP_359_1: for (int i = 0; i < CONFIG_T::n_in; i++) {
#pragma HLS UNROLL
 res[i] = (res_T)0;
    }

    data_T maximum = data[0];
    int idx = 0;

    VITIS_LOOP_367_2: for (int i = 1; i < CONFIG_T::n_in; i++) {
#pragma HLS PIPELINE
 if (data[i] > maximum) {
            maximum = data[i];
            idx = i;
        }
    }

    res[idx] = (res_T)1;
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS inline
 switch (CONFIG_T::implementation) {
    case softmax_implementation::latency:
        softmax_latency<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::stable:
        softmax_stable<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::legacy:
        softmax_legacy<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::argmax:
        softmax_argmax<data_T, res_T, CONFIG_T>(data, res);
        break;
    }
}




template <typename CONFIG_T, int N_TABLE> void init_tanh_table(typename CONFIG_T::table_t table_out[N_TABLE]) {

    VITIS_LOOP_402_1: for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 4.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = tanh(in_val);


        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T> void tanh(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t tanh_table[CONFIG_T::table_size];




    if (!initialized) {
        init_tanh_table<CONFIG_T, CONFIG_T::table_size>(tanh_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 int data_round;
    int index;
    VITIS_LOOP_432_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_round = data[ii] * CONFIG_T::table_size / 8;
        index = data_round + 4 * CONFIG_T::table_size / 8;

        if (index < 0)
            index = 0;
        if (index > CONFIG_T::table_size - 1)
            index = CONFIG_T::table_size - 1;
        res[ii] = (res_T)tanh_table[index];
    }
}




template <int table_size, class data_T> inline unsigned get_index_unary_lut(data_T x) {

    static constexpr int N = ceillog2(table_size);
    return (unsigned)(x(x.width - 1, 0));
}

template <class data_T, class res_T, typename CONFIG_T>
void unary_lut(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in],
               typename CONFIG_T::table_t table[CONFIG_T::table_size]) {
#pragma HLS function_instantiate variable=table
#pragma HLS ARRAY_PARTITION variable=table

 VITIS_LOOP_459_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
#pragma HLS UNROLL
 unsigned index = get_index_unary_lut<CONFIG_T::table_size>(data[ii]);
        res[ii] = (res_T)table[index];
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void hard_sigmoid(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 VITIS_LOOP_473_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        auto datareg = CONFIG_T::slope * data[ii] + CONFIG_T::shift;
        if (datareg > 1)
            datareg = 1;
        else if (datareg < 0)
            datareg = 0;
        res[ii] = datareg;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void hard_tanh(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    if (CONFIG_T::io_type == io_parallel) {
#pragma HLS PIPELINE
 }

    VITIS_LOOP_489_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        auto sigmoid = CONFIG_T::slope * data[ii] + CONFIG_T::shift;
        if (sigmoid > 1)
            sigmoid = 1;
        else if (sigmoid < 0)
            sigmoid = 0;
        res[ii] = 2 * sigmoid - 1;
    }
}




template <class data_T, class param_T, class res_T, typename CONFIG_T>
void leaky_relu(data_T data[CONFIG_T::n_in], param_T alpha, res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    VITIS_LOOP_507_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > 0)
            res[ii] = datareg;
        else
            res[ii] = alpha * datareg;
    }
}




template <class data_T, class param_T, class res_T, typename CONFIG_T>
void thresholded_relu(data_T data[CONFIG_T::n_in], param_T theta, res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    VITIS_LOOP_524_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > theta)
            res[ii] = datareg;
        else
            res[ii] = 0;
    }
}




inline float softplus_fcn_float(float input) { return std::log(std::exp(input) + 1.); }

template <typename CONFIG_T, int N_TABLE> void init_softplus_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    VITIS_LOOP_541_1: for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 8.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = softplus_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softplus(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t softplus_table[CONFIG_T::table_size];




    if (!initialized) {
        init_softplus_table<CONFIG_T, CONFIG_T::table_size>(softplus_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 int data_round;
    int index;
    VITIS_LOOP_571_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_round = data[ii] * CONFIG_T::table_size / 16;
        index = data_round + 8 * CONFIG_T::table_size / 16;
        if (index < 0)
            index = 0;
        if (index > CONFIG_T::table_size - 1)
            index = CONFIG_T::table_size - 1;
        res[ii] = (res_T)softplus_table[index];
    }
}




inline float softsign_fcn_float(float input) { return input / (std::abs(input) + 1.); }

template <typename CONFIG_T, int N_TABLE> void init_softsign_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    VITIS_LOOP_590_1: for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = 2 * 8.0 * (ii - float(N_TABLE) / 2.0) / float(N_TABLE);

        typename CONFIG_T::table_t real_val = softsign_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softsign(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t softsign_table[CONFIG_T::table_size];




    if (!initialized) {
        init_softsign_table<CONFIG_T, CONFIG_T::table_size>(softsign_table);
        initialized = true;
    }

#pragma HLS PIPELINE


 int data_round;
    int index;
    VITIS_LOOP_620_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        data_round = data[ii] * CONFIG_T::table_size / 16;
        index = data_round + 8 * CONFIG_T::table_size / 16;
        if (index < 0)
            index = 0;
        if (index > CONFIG_T::table_size - 1)
            index = CONFIG_T::table_size - 1;
        res[ii] = (res_T)softsign_table[index];
    }
}




inline float elu_fcn_float(float input) { return std::exp(input) - 1.; }

template <typename CONFIG_T, int N_TABLE> void init_elu_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    VITIS_LOOP_639_1: for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = -8.0 * ii / float(N_TABLE);

        typename CONFIG_T::table_t real_val = elu_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class param_T, class res_T, typename CONFIG_T>
void elu(data_T data[CONFIG_T::n_in], const param_T alpha, res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t elu_table[CONFIG_T::table_size];




    if (!initialized) {
        init_elu_table<CONFIG_T, CONFIG_T::table_size>(elu_table);
        initialized = true;
    }

#pragma HLS PIPELINE

 data_T datareg;

    int index;
    VITIS_LOOP_669_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg >= 0) {
            res[ii] = datareg;
        } else {
            index = datareg * CONFIG_T::table_size / -8;
            if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            res[ii] = alpha * elu_table[index];
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T> void elu(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
    elu<data_T, ap_uint<1>, res_T, CONFIG_T>(data, 1.0, res);
}




inline float selu_fcn_float(float input) {
    return 1.0507009873554804934193349852946 * (1.6732632423543772848170429916717 * (std::exp(input) - 1.));
}

template <typename CONFIG_T, int N_TABLE> void init_selu_table(typename CONFIG_T::table_t table_out[N_TABLE]) {


    VITIS_LOOP_696_1: for (int ii = 0; ii < N_TABLE; ii++) {

        float in_val = -8.0 * ii / float(N_TABLE);

        typename CONFIG_T::table_t real_val = selu_fcn_float(in_val);

        table_out[ii] = real_val;
    }
}

template <class data_T, class res_T, typename CONFIG_T> void selu(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {


    bool initialized = false;
    typename CONFIG_T::table_t selu_table[CONFIG_T::table_size];




    if (!initialized) {
        init_selu_table<CONFIG_T, CONFIG_T::table_size>(selu_table);
        initialized = true;
    }

#pragma HLS PIPELINE

 data_T datareg;

    int index;
    VITIS_LOOP_725_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg >= 0) {
            res[ii] = res_T(1.0507009873554804934193349852946) * datareg;
        } else {
            index = datareg * CONFIG_T::table_size / -8;
            if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            res[ii] = selu_table[index];
        }
    }
}




template <class data_T, class param_T, class res_T, typename CONFIG_T>
void prelu(data_T data[CONFIG_T::n_in], param_T alpha[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    VITIS_LOOP_746_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > 0)
            res[ii] = datareg;
        else
            res[ii] = alpha[ii] * datareg;
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void binary_tanh(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    res_T cache;
    VITIS_LOOP_764_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = data[ii];
        if (datareg > 0)
            cache = 1;
        else
            cache = -1;

        res[ii] = (res_T)cache;
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void ternary_tanh(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_in]) {
#pragma HLS PIPELINE

 data_T datareg;
    res_T cache;
    VITIS_LOOP_784_1: for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        datareg = 2 * data[ii];
        if (datareg > 1)
            cache = 1;
        else if (datareg > -1 && datareg <= 1)
            cache = 0;
        else
            cache = -1;

        res[ii] = (res_T)cache;
    }
}

}
# 11 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_activation_stream.h" 1







# 1 "firmware/nnet_utils/nnet_stream.h" 1







namespace nnet {

struct broadcast_config {
    static const unsigned in_height = 1;
    static const unsigned in_width = 1;
    static const unsigned in_chan = 3;
    static const unsigned out_height = 2;
    static const unsigned out_width = 2;
    static const unsigned out_chan = 3;
};

template <class data_T, class res_T, int N>
void clone_stream(hls::stream<data_T> &data, hls::stream<res_T> &res1, hls::stream<res_T> &res2) {
CloneLoop:
    for (int i = 0; i < N / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data1;
        res_T out_data2;



    ClonePack:
        for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 out_data1[j] = in_data[j];
            out_data2[j] = in_data[j];
        }

        res1.write(out_data1);
        res2.write(out_data2);
    }
}

template <class data_T, class res_T, int N>
void clone_stream(hls::stream<data_T> &data, hls::stream<res_T> &res1, hls::stream<res_T> &res2, hls::stream<res_T> &res3) {
CloneLoop:
    for (int i = 0; i < N / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data1;
        res_T out_data2;
        res_T out_data3;




    ClonePack:
        for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 out_data1[j] = in_data[j];
            out_data2[j] = in_data[j];
            out_data3[j] = in_data[j];
        }

        res1.write(out_data1);
        res2.write(out_data2);
        res3.write(out_data3);
    }
}

template <class data_T, class res_T, int N> void repack_stream(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    if (data_T::size == res_T::size) {
        VITIS_LOOP_73_1: for (int i = 0; i < N / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
            res_T out_data;


            VITIS_LOOP_80_2: for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 out_data[j] = in_data[j];
            }

            res.write(out_data);
        }
    } else if (data_T::size > res_T::size) {
        constexpr unsigned pack_diff = data_T::size / res_T::size;
        VITIS_LOOP_89_3: for (int i = 0; i < N / data_T::size; i++) {
            if (N / data_T::size > 1) {
#pragma HLS PIPELINE
 }

            data_T in_data = data.read();
            res_T out_data;


            VITIS_LOOP_98_4: for (int j = 0; j < pack_diff; j++) {
#pragma HLS PIPELINE

 res_T out_data;
                VITIS_LOOP_102_5: for (int k = 0; k < res_T::size; k++) {
#pragma HLS UNROLL
 out_data[k] = in_data[j * res_T::size + k];
                }
                res.write(out_data);
            }
        }
    } else {
        res_T out_data;
        constexpr unsigned pack_diff = res_T::size / data_T::size;
        unsigned pack_cnt = 0;
        VITIS_LOOP_113_6: for (int i = 0; i < N / data_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
            VITIS_LOOP_117_7: for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 out_data[pack_cnt * data_T::size + j] = in_data[j];
            }

            if (pack_cnt == pack_diff - 1) {
                res.write(out_data);
                pack_cnt = 0;
            } else {
                pack_cnt++;
            }
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void broadcast_stream_1x1xC(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::in_height == 1 && CONFIG_T::in_width == 1 && CONFIG_T::in_chan == CONFIG_T::out_chan; __builtin_assume(_AssertPred); });
    int n_dupl = (CONFIG_T::out_height * CONFIG_T::out_width * CONFIG_T::out_chan) /
                 (CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::in_chan);
BroadcastLoop:
    for (int i = 0; i < CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::in_chan / data_T::size; i++) {
#pragma HLS PIPELINE
 data_T in_data = data.read();
        VITIS_LOOP_141_1: for (int j = 0; j < n_dupl; j++) {
#pragma HLS PIPELINE
 res_T out_data;

            VITIS_LOOP_145_2: for (int k = 0; k < res_T::size; k++) {
#pragma HLS UNROLL
 out_data[k] = in_data[k];
            }
            res.write(out_data);
        }
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void broadcast_stream_HxWx1(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::in_chan == 1 && CONFIG_T::in_height == CONFIG_T::out_height && CONFIG_T::in_width == CONFIG_T::out_width; __builtin_assume(_AssertPred); });

BroadcastLoop:
    for (int i = 0; i < CONFIG_T::in_height * CONFIG_T::in_width * CONFIG_T::in_chan / data_T::size; i++) {
#pragma HLS PIPELINE
 data_T in_data = data.read();
        res_T out_data;

        VITIS_LOOP_164_1: for (int k = 0; k < res_T::size; k++) {
#pragma HLS UNROLL
 out_data[k] = in_data[0];
        }
        res.write(out_data);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void broadcast_stream(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    if (CONFIG_T::in_height == 1 && CONFIG_T::in_width == 1 && CONFIG_T::in_chan == CONFIG_T::out_chan) {
        broadcast_stream_1x1xC<data_T, res_T, CONFIG_T>(data, res);
    } else if (CONFIG_T::in_chan == 1 && CONFIG_T::in_height == CONFIG_T::out_height &&
               CONFIG_T::in_width == CONFIG_T::out_width) {
        broadcast_stream_HxWx1<data_T, res_T, CONFIG_T>(data, res);
    }
}

}
# 9 "firmware/nnet_utils/nnet_activation_stream.h" 2

# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 1 3
# 40 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
# 11 "firmware/nnet_utils/nnet_activation_stream.h" 2

namespace nnet {




template <class data_T, class res_T, typename CONFIG_T> void linear(hls::stream<data_T> &data, hls::stream<res_T> &res) {
LinearActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    LinearPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 out_data[j] = in_data[j];
        }

        res.write(out_data);
    }
}




template <class data_T, class res_T, typename CONFIG_T> void relu(hls::stream<data_T> &data, hls::stream<res_T> &res) {
ReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    ReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 0)
                out_data[j] = in_data[j];
            else
                out_data[j] = 0;
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T> void sigmoid(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t sigmoid_table[CONFIG_T::table_size];




    if (!initialized) {
        init_sigmoid_table<CONFIG_T, CONFIG_T::table_size>(sigmoid_table);
        initialized = true;
    }

SigmoidActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    SigmoidPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 int data_round = in_data[j] * CONFIG_T::table_size / 16;
            int index = data_round + 8 * CONFIG_T::table_size / 16;
            if (index < 0)
                index = 0;
            else if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            out_data[j] = sigmoid_table[index];
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T>
void softmax_latency(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::exp_table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::inv_table_t invert_table[CONFIG_T::table_size];






    if (!initialized) {

        init_exp_table<typename data_T::value_type, CONFIG_T>(exp_table);

        init_invert_table<typename CONFIG_T::exp_table_t, CONFIG_T>(invert_table);
        initialized = true;
    }

    constexpr unsigned multiplier_limit = ((data_T::size + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    constexpr unsigned ii = data_T::size / multiplier_limit;


    typename CONFIG_T::exp_table_t exp_res[data_T::size];
#pragma HLS array_partition variable=exp_res complete
 typename CONFIG_T::exp_table_t exp_sum(0);
SoftmaxExpLoop:
    for (unsigned i = 0; i < CONFIG_T::n_in / data_T::size; i++) {
#pragma HLS PIPELINE II=ii

 data_T in_pack = data.read();
    SoftmaxExpPackLoop:
        for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 unsigned x = softmax_idx_from_real_val<typename data_T::value_type, CONFIG_T>(in_pack[j]);
            exp_res[j] = exp_table[x];
        }



        Op_add<typename CONFIG_T::exp_table_t> op_add;
        exp_sum =
            reduce<typename CONFIG_T::exp_table_t, data_T::size, Op_add<typename CONFIG_T::exp_table_t>>(exp_res, op_add);

        typename CONFIG_T::inv_table_t inv_exp_sum =
            invert_table[softmax_idx_from_real_val<typename CONFIG_T::exp_table_t, CONFIG_T>(exp_sum)];

        res_T out_pack;


    SoftmaxInvPackLoop:
        for (unsigned j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
#pragma HLS ALLOCATION operation instances=mul limit=multiplier_limit
 out_pack[j] = exp_res[j] * inv_exp_sum;
        }
        res.write(out_pack);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_stable(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::exp_table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::inv_table_t invert_table[CONFIG_T::table_size];






    if (!initialized) {

        init_exp_table<typename data_T::value_type, CONFIG_T>(exp_table);

        init_invert_table<typename CONFIG_T::exp_table_t, CONFIG_T>(invert_table);
        initialized = true;
    }

    constexpr unsigned multiplier_limit = ((data_T::size + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    constexpr unsigned ii = data_T::size / multiplier_limit;

    typename data_T::value_type data_array[data_T::size];
#pragma HLS ARRAY_PARTITION variable=data_array complete
SoftmaxArrayLoop:
    for (unsigned i = 0; i < CONFIG_T::n_in / data_T::size; i++) {
#pragma HLS PIPELINE II=ii

 data_T in_pack = data.read();
    SoftmaxArrayPackLoop:
        for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 data_array[j] = in_pack[j];
        }


        Op_max<typename data_T::value_type> op_max;
        typename data_T::value_type x_max =
            reduce<typename data_T::value_type, data_T::size, Op_max<typename data_T::value_type>>(data_array, op_max);


        ap_fixed<data_T::value_type::width, data_T::value_type::iwidth, AP_RND, AP_SAT> d_xi_xmax[data_T::size];
        VITIS_LOOP_213_1: for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 d_xi_xmax[j] = data_array[j] - x_max;
        }


        typename CONFIG_T::exp_table_t exp_res[data_T::size];
#pragma HLS ARRAY_PARTITION variable=exp_res complete
 typename CONFIG_T::exp_table_t exp_sum(0);
        VITIS_LOOP_222_2: for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 unsigned x = softmax_idx_from_real_val<typename data_T::value_type, CONFIG_T>(d_xi_xmax[j]);
            exp_res[j] = exp_table[x];
        }



        Op_add<typename CONFIG_T::exp_table_t> op_add;
        exp_sum =
            reduce<typename CONFIG_T::exp_table_t, data_T::size, Op_add<typename CONFIG_T::exp_table_t>>(exp_res, op_add);

        typename CONFIG_T::inv_table_t inv_exp_sum =
            invert_table[softmax_idx_from_real_val<typename CONFIG_T::exp_table_t, CONFIG_T>(exp_sum)];

        res_T out_pack;


    SoftmaxInvPackLoop:
        for (unsigned j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
#pragma HLS ALLOCATION operation instances=mul limit=multiplier_limit
 out_pack[j] = exp_res[j] * inv_exp_sum;
        }
        res.write(out_pack);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_legacy(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t exp_table[CONFIG_T::table_size];
    typename CONFIG_T::table_t invert_table[CONFIG_T::table_size];





    if (!initialized) {
        init_exp_table_legacy<CONFIG_T, CONFIG_T::table_size>(exp_table);
        init_invert_table_legacy<CONFIG_T, CONFIG_T::table_size>(invert_table);
        initialized = true;
    }


    typename CONFIG_T::table_t exp_res[data_T::size];
    typename CONFIG_T::table_t exp_diff_res;
    typename data_T::value_type data_cache[data_T::size];

SoftmaxInitLoop:
    for (unsigned s = 0; s < CONFIG_T::n_in / data_T::size; s++) {
#pragma HLS PIPELINE
 data_T in_pack = data.read();
    SoftmaxInitPackLoop:
        for (unsigned j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL
 data_cache[j] = in_pack[j];
            exp_res[j] = 0;
        }

    SoftmaxExpLoop:
        for (int i = 0; i < data_T::size; i++) {
#pragma HLS UNROLL
 SoftmaxExpInner:
            for (int j = 0; j < data_T::size; j++) {
#pragma HLS UNROLL

 if (i == j) {
                    exp_diff_res = 1;
                } else {
                    int data_round = (data_cache[j] - data_cache[i]) * CONFIG_T::table_size / 16;
                    int index = data_round + 8 * CONFIG_T::table_size / 16;
                    if (index < 0)
                        index = 0;
                    if (index > CONFIG_T::table_size - 1)
                        index = CONFIG_T::table_size - 1;
                    exp_diff_res = exp_table[index];
                }

                exp_res[i] += exp_diff_res;
            }
        }

        res_T out_pack;


    SoftmaxInvPackLoop:
        for (unsigned j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL

 int exp_res_index = exp_res[j] * CONFIG_T::table_size / 64;
            if (exp_res_index < 0)
                exp_res_index = 0;
            if (exp_res_index > CONFIG_T::table_size - 1)
                exp_res_index = CONFIG_T::table_size - 1;

            out_pack[j] = (typename res_T::value_type)invert_table[exp_res_index];
        }
        res.write(out_pack);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void softmax_argmax(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    VITIS_LOOP_328_1: for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE
 data_T in_data = data.read();
        res_T out_data;

        VITIS_LOOP_333_2: for (int i = 0; i < res_T::size; i++) {
#pragma HLS UNROLL
 out_data[i] = (typename res_T::value_type)0;
        }

        typename data_T::value_type maximum = in_data[0];
        int idx = 0;

        VITIS_LOOP_341_3: for (int i = 1; i < res_T::size; i++) {
#pragma HLS PIPELINE
 if (in_data[i] > maximum) {
                maximum = in_data[i];
                idx = i;
            }
        }

        out_data[idx] = (typename res_T::value_type)1;
        res.write(out_data);
    }
}

template <class data_T, class res_T, typename CONFIG_T> void softmax(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    ({ bool _AssertPred = CONFIG_T::axis == -1; __builtin_assume(_AssertPred); });

    switch (CONFIG_T::implementation) {
    case softmax_implementation::latency:
        softmax_latency<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::stable:
        softmax_stable<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::legacy:
        softmax_legacy<data_T, res_T, CONFIG_T>(data, res);
        break;
    case softmax_implementation::argmax:
        softmax_argmax<data_T, res_T, CONFIG_T>(data, res);
        break;
    }
}





template <class data_T, class res_T, typename CONFIG_T> void tanh(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t tanh_table[CONFIG_T::table_size];




    if (!initialized) {
        init_tanh_table<CONFIG_T, CONFIG_T::table_size>(tanh_table);
        initialized = true;
    }

TanHActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    TanHPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 int data_round = in_data[j] * CONFIG_T::table_size / 8;
            int index = data_round + 4 * CONFIG_T::table_size / 8;
            if (index < 0)
                index = 0;
            else if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            out_data[j] = tanh_table[index];
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T>
void unary_lut(hls::stream<data_T> &data, hls::stream<res_T> &res, typename CONFIG_T::table_t table[CONFIG_T::table_size]) {
#pragma HLS function_instantiate variable=table
#pragma HLS ARRAY_PARTITION variable=table complete

UnaryLUTActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor rewind

 data_T in_data = data.read();
        res_T out_data;


    UnaryLUTPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 unsigned index = get_index_unary_lut<CONFIG_T::table_size>(in_data[j].V);
            out_data[j] = table[index];
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T>
void hard_sigmoid(hls::stream<data_T> &data, hls::stream<res_T> &res) {

HardSigmoidActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    HardSigmoidPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 auto datareg = CONFIG_T::slope * in_data[j] + CONFIG_T::shift;
            if (datareg > 1)
                datareg = 1;
            else if (datareg < 0)
                datareg = 0;
            out_data[j] = datareg;
        }

        res.write(out_data);
    }
}

template <class data_T, class res_T, typename CONFIG_T> void hard_tanh(hls::stream<data_T> &data, hls::stream<res_T> &res) {

HardSigmoidActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    HardSigmoidPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 auto sigmoid = CONFIG_T::slope * in_data[j] + CONFIG_T::shift;
            if (sigmoid > 1)
                sigmoid = 1;
            else if (sigmoid < 0)
                sigmoid = 0;
            out_data[j] = 2 * sigmoid - 1;
        }

        res.write(out_data);
    }
}





template <class data_T, class param_T, class res_T, typename CONFIG_T>
void leaky_relu(hls::stream<data_T> &data, param_T alpha, hls::stream<res_T> &res) {
LeakyReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    LeakyReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 0)
                out_data[j] = in_data[j];
            else
                out_data[j] = alpha * in_data[j];
        }
        res.write(out_data);
    }
}





template <class data_T, class param_T, class res_T, typename CONFIG_T>
void thresholded_relu(hls::stream<data_T> &data, param_T theta, hls::stream<res_T> &res) {
ThresholdedReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    ThresholdedReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > theta)
                out_data[j] = in_data[j];
            else
                out_data[j] = 0;
        }

        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T> void softplus(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t softplus_table[CONFIG_T::table_size];




    if (!initialized) {
        init_softplus_table<CONFIG_T, CONFIG_T::table_size>(softplus_table);
        initialized = true;
    }

SoftplusActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    SoftplusPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 int data_round = in_data[j] * CONFIG_T::table_size / 16;
            int index = data_round + 8 * CONFIG_T::table_size / 16;
            if (index < 0)
                index = 0;
            else if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            out_data[j] = softplus_table[index];
        }
        res.write(out_data);
    }
}





template <class data_T, class res_T, typename CONFIG_T> void softsign(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t softsign_table[CONFIG_T::table_size];




    if (!initialized) {
        init_softsign_table<CONFIG_T, CONFIG_T::table_size>(softsign_table);
        initialized = true;
    }

SoftsignActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    SoftsignPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 int data_round = in_data[j] * CONFIG_T::table_size / 16;
            int index = data_round + 8 * CONFIG_T::table_size / 16;
            if (index < 0)
                index = 0;
            else if (index > CONFIG_T::table_size - 1)
                index = CONFIG_T::table_size - 1;
            out_data[j] = softsign_table[index];
        }
        res.write(out_data);
    }
}




template <class data_T, class param_T, class res_T, typename CONFIG_T>
void elu(hls::stream<data_T> &data, param_T alpha, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t elu_table[CONFIG_T::table_size];




    if (!initialized) {
        init_elu_table<CONFIG_T, CONFIG_T::table_size>(elu_table);
        initialized = true;
    }

EluActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    EluPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL

 typename data_T::value_type datareg = in_data[j];
            if (datareg >= 0) {
                out_data[j] = datareg;
            } else {
                int index = datareg * CONFIG_T::table_size / -8;
                if (index > CONFIG_T::table_size - 1)
                    index = CONFIG_T::table_size - 1;
                out_data[j] = alpha * elu_table[index];
            }
        }
        res.write(out_data);
    }
}

template <class data_T, class res_T, typename CONFIG_T> void elu(hls::stream<data_T> &data, hls::stream<res_T> &res) {
    elu<data_T, ap_uint<1>, res_T, CONFIG_T>(data, 1.0, res);
}





template <class data_T, class res_T, typename CONFIG_T> void selu(hls::stream<data_T> &data, hls::stream<res_T> &res) {


    bool initialized = false;
    typename CONFIG_T::table_t selu_table[CONFIG_T::table_size];




    if (!initialized) {
        init_selu_table<CONFIG_T, CONFIG_T::table_size>(selu_table);
        initialized = true;
    }

SeluActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    SeluPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL

 typename data_T::value_type datareg = in_data[j];
            if (datareg >= 0) {
                out_data[j] = (typename data_T::value_type)1.0507009873554804934193349852946 * datareg;
            } else {
                int index = datareg * CONFIG_T::table_size / -8;
                if (index > CONFIG_T::table_size - 1)
                    index = CONFIG_T::table_size - 1;
                out_data[j] = selu_table[index];
            }
        }
        res.write(out_data);
    }
}





template <class data_T, class param_T, class res_T, typename CONFIG_T>
void prelu(hls::stream<data_T> &data, const param_T alpha[CONFIG_T::n_in], hls::stream<res_T> &res) {
PReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    PReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 0)
                out_data[j] = in_data[j];
            else
                out_data[j] = alpha[i * res_T::size + j] * in_data[j];
        }
        res.write(out_data);
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void binary_tanh(hls::stream<data_T> &data, hls::stream<res_T> &res) {
PReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    PReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 0)
                out_data[j] = (typename res_T::value_type)1;
            else
                out_data[j] = (typename res_T::value_type) - 1;
        }
        res.write(out_data);
    }
}




template <class data_T, class res_T, typename CONFIG_T>
void ternary_tanh(hls::stream<data_T> &data, hls::stream<res_T> &res) {
PReLUActLoop:
    for (int i = 0; i < CONFIG_T::n_in / res_T::size; i++) {
#pragma HLS PIPELINE

 data_T in_data = data.read();
        res_T out_data;


    PReLUPackLoop:
        for (int j = 0; j < res_T::size; j++) {
#pragma HLS UNROLL
 if (in_data[j] > 1)
                out_data[j] = (typename res_T::value_type)1;
            else if (in_data[j] <= -1)
                out_data[j] = (typename res_T::value_type) - 1;
            else
                out_data[j] = (typename res_T::value_type)0;
        }
        res.write(out_data);
    }
}

}
# 12 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_dense.h" 1





# 1 "firmware/nnet_utils/nnet_dense_latency.h" 1







# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\math.h" 1 3
# 9 "firmware/nnet_utils/nnet_dense_latency.h" 2

namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void dense_latency(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                   typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                   typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
    data_T cache;
    typename CONFIG_T::accum_t mult[CONFIG_T::n_in * CONFIG_T::n_out];
    typename CONFIG_T::accum_t acc[CONFIG_T::n_out];


#pragma HLS function_instantiate variable=weights,biases




#pragma HLS PIPELINE II=CONFIG_T::reuse_factor


#pragma HLS ARRAY_PARTITION variable=biases complete
#pragma HLS ARRAY_PARTITION variable=mult complete
#pragma HLS ARRAY_PARTITION variable=acc complete

#pragma HLS ALLOCATION operation instances=mul limit=CONFIG_T::multiplier_limit


Product1:
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
        cache = data[ii];
    Product2:
        for (int jj = 0; jj < CONFIG_T::n_out; jj++) {
            int index = ii * CONFIG_T::n_out + jj;
            mult[index] = CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(cache, weights[index]);
        }
    }


ResetAccum:
    for (int iacc = 0; iacc < CONFIG_T::n_out; iacc++) {
        acc[iacc] = (typename CONFIG_T::accum_t)biases[iacc];
    }


Accum1:
    for (int ii = 0; ii < CONFIG_T::n_in; ii++) {
    Accum2:
        for (int jj = 0; jj < CONFIG_T::n_out; jj++) {
            int index = ii * CONFIG_T::n_out + jj;
            acc[jj] += mult[index];
        }
    }


Result:
    for (int ires = 0; ires < CONFIG_T::n_out; ires++) {

        res[ires] = cast<data_T, res_T, CONFIG_T>(acc[ires]);
    }
}

}
# 7 "firmware/nnet_utils/nnet_dense.h" 2
# 1 "firmware/nnet_utils/nnet_dense_resource.h" 1






# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 1 3
# 8 "firmware/nnet_utils/nnet_dense_resource.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\math.h" 1 3
# 9 "firmware/nnet_utils/nnet_dense_resource.h" 2

namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource_rf_leq_nin(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                               typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                               typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    const int rufactor = CONFIG_T::reuse_factor;
    const int multfactor = (CONFIG_T::n_in > CONFIG_T::reuse_factor ? CONFIG_T::reuse_factor : CONFIG_T::n_in);
    const int multiplier_limit = ((CONFIG_T::n_in * CONFIG_T::n_out + multfactor - 1) / multfactor);
    const int block_factor = ((CONFIG_T::n_in * CONFIG_T::n_out + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    const int multscale = multiplier_limit / CONFIG_T::n_out;
    const int nin = CONFIG_T::n_in;
    const int nout = CONFIG_T::n_out;

    ({ bool _AssertPred = (multiplier_limit % nout == 0 || rufactor >= nin) && "The current Reuse Factor is not allowed"; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = (multiplier_limit == block_factor) && "This function is correct only for RF <= N_IN"; __builtin_assume(_AssertPred); });

#pragma HLS function_instantiate variable=weights,biases
#pragma HLS ARRAY_RESHAPE variable=weights block factor=block_factor
#pragma HLS ARRAY_PARTITION variable=biases complete

 if (CONFIG_T::reuse_factor > 1) {
#pragma HLS RESOURCE variable=weights core=ROM_nP_BRAM
 }

    typename CONFIG_T::accum_t acc[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete

InitAccum:
    for (int iacc = 0; iacc < nout; iacc++) {
#pragma HLS UNROLL
 acc[iacc] = (typename CONFIG_T::accum_t)biases[iacc];
    }

ReuseLoop:
    for (int ir = 0; ir < rufactor; ir++) {
#pragma HLS PIPELINE II=1 rewind

 int w_index = ir;
        int in_index = ir;
        int out_index = 0;
        int acc_step = 0;

    MultLoop:
        for (int im = 0; im < block_factor; im++) {
#pragma HLS UNROLL

 acc[out_index] += static_cast<typename CONFIG_T::accum_t>(
                CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(data[in_index], weights[w_index]));


            w_index += rufactor;

            in_index += rufactor;
            if (in_index >= nin) {
                in_index = ir;
            }

            if (acc_step + 1 >= multscale) {
                acc_step = 0;
                out_index++;
            } else {
                acc_step++;
            }
        }
    }


Result:
    for (int ires = 0; ires < CONFIG_T::n_out; ires++) {
#pragma HLS UNROLL
 res[ires] = cast<data_T, res_T, CONFIG_T>(acc[ires]);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource_rf_gt_nin_rem0(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                                   typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                                   typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    const int rufactor = (CONFIG_T::reuse_factor > CONFIG_T::n_in * CONFIG_T::n_out ? CONFIG_T::n_in * CONFIG_T::n_out : CONFIG_T::reuse_factor);
    const int multfactor = (CONFIG_T::n_in > CONFIG_T::reuse_factor ? CONFIG_T::reuse_factor : CONFIG_T::n_in);
    const int multiplier_limit = ((CONFIG_T::n_in * CONFIG_T::n_out + multfactor - 1) / multfactor);
    const int block_factor = ((CONFIG_T::n_in * CONFIG_T::n_out + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    const int multscale = multiplier_limit / CONFIG_T::n_out;
    const int nin = CONFIG_T::n_in;
    const int nout = CONFIG_T::n_out;

    ({ bool _AssertPred = (multiplier_limit % nout == 0 || rufactor >= nin) && "The current Reuse Factor is not allowed"; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = (rufactor > nin && rufactor % nin == 0) && "This function is correct only for RF > N_IN && RF % N_IN == 0"; __builtin_assume(_AssertPred); });

#pragma HLS function_instantiate variable=weights,biases
#pragma HLS ARRAY_RESHAPE variable=weights block factor=block_factor
#pragma HLS ARRAY_PARTITION variable=biases complete

 if (CONFIG_T::reuse_factor > 1) {
#pragma HLS RESOURCE variable=weights core=ROM_nP_BRAM
 }

    typename CONFIG_T::accum_t acc[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete

InitAccum:
    for (int iacc = 0; iacc < nout; iacc++) {
#pragma HLS UNROLL
 acc[iacc] = (typename CONFIG_T::accum_t)biases[iacc];
    }

    int w_index;
    int in_index = 0;
    int out_index;
    int outstep = 0;
    const int outscale = rufactor / nin;

    int outidx[rufactor];
IndexLoop:
    for (int ir = 0; ir < rufactor; ir++) {
        outidx[ir] = outstep;
        if ((ir + 1) % nin == 0) {
            outstep++;
        }
    }

ReuseLoop:
    for (int ir = 0; ir < rufactor; ir++) {
#pragma HLS PIPELINE II=1 rewind

 w_index = ir;
        out_index = outidx[ir] ;

    MultLoop:
        for (int im = 0; im < block_factor; im++) {
#pragma HLS UNROLL
 acc[out_index] += static_cast<typename CONFIG_T::accum_t>(
                CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(data[in_index], weights[w_index]));

            w_index += rufactor;
            if (w_index >= CONFIG_T::n_in * CONFIG_T::n_out)
                break;
            out_index += outscale;
        }

        in_index++;
        if (in_index >= nin) {
            in_index = 0;

        }
    }


Result:
    for (int ires = 0; ires < CONFIG_T::n_out; ires++) {
#pragma HLS UNROLL
 res[ires] = cast<data_T, res_T, CONFIG_T>(acc[ires]);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource_rf_gt_nin(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                              typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                              typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    const int rufactor = CONFIG_T::reuse_factor;
    const int multfactor = (CONFIG_T::n_in > CONFIG_T::reuse_factor ? CONFIG_T::reuse_factor : CONFIG_T::n_in);
    const int multiplier_limit = ((CONFIG_T::n_in * CONFIG_T::n_out + multfactor - 1) / multfactor);
    const int block_factor = ((CONFIG_T::n_in * CONFIG_T::n_out + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);
    const int multscale = multiplier_limit / CONFIG_T::n_out;
    const int nin = CONFIG_T::n_in;
    const int nout = CONFIG_T::n_out;

    ({ bool _AssertPred = (multiplier_limit % nout == 0 || rufactor >= nin) && "The current Reuse Factor is not allowed"; __builtin_assume(_AssertPred); });
    ({ bool _AssertPred = (rufactor > nin) && "This function is correct only for RF > N_IN"; __builtin_assume(_AssertPred); });

#pragma HLS function_instantiate variable=weights,biases
#pragma HLS ARRAY_RESHAPE variable=weights block factor=block_factor
#pragma HLS ARRAY_PARTITION variable=biases complete

 if (CONFIG_T::reuse_factor > 1) {
#pragma HLS RESOURCE variable=weights core=ROM_nP_BRAM
 }

    typename CONFIG_T::accum_t acc[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete

InitAccum:
    for (int iacc = 0; iacc < nout; iacc++) {
#pragma HLS UNROLL
 acc[iacc] = (typename CONFIG_T::accum_t)biases[iacc];
    }

ReuseLoop:
    for (int ir = 0; ir < rufactor; ir++) {
#pragma HLS PIPELINE II=1 rewind
 typename CONFIG_T::accum_t tmpmult[block_factor];
#pragma HLS ARRAY_PARTITION variable=tmpmult complete

 MultLoop:
        for (int im = 0; im < block_factor; im++) {
#pragma HLS UNROLL
 int w_index = ir + rufactor * im;
            int in_index = w_index % nin;
            if (w_index >= CONFIG_T::n_in * CONFIG_T::n_out)
                continue;
            tmpmult[im] =
                CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(data[in_index], weights[w_index]);
        }

        typename CONFIG_T::accum_t mult[multiplier_limit];
#pragma HLS ARRAY_PARTITION variable=mult complete

 ResetMult:
        for (int imult = 0; imult < multiplier_limit; imult++) {
#pragma HLS UNROLL
 mult[imult] = 0;
        }

    AccumLoop1:
        for (int im = 0; im < block_factor; im++) {
#pragma HLS UNROLL
 int w_index = ir + rufactor * im;
            int out_index = w_index / multfactor;
            if (out_index >= multiplier_limit)
                continue;
            mult[out_index] += tmpmult[im];
        }

    AccumLoop2:
        for (int im = 0; im < multiplier_limit; im++) {
#pragma HLS UNROLL


 acc[im] += mult[im];
        }
    }


Result:
    for (int ires = 0; ires < CONFIG_T::n_out; ires++) {
#pragma HLS UNROLL
 res[ires] = cast<data_T, res_T, CONFIG_T>(acc[ires]);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                    typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                    typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

#pragma HLS INLINE recursive

 if (CONFIG_T::reuse_factor <= CONFIG_T::n_in) {
        dense_resource_rf_leq_nin<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    } else if (CONFIG_T::reuse_factor % CONFIG_T::n_in == 0) {
        dense_resource_rf_gt_nin_rem0<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    } else {
        dense_resource_rf_gt_nin<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    }
}

}
# 8 "firmware/nnet_utils/nnet_dense.h" 2



# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\math.h" 1 3
# 12 "firmware/nnet_utils/nnet_dense.h" 2

namespace nnet {

struct dense_config {

    typedef float bias_t;
    typedef float weight_t;
    typedef float accum_t;


    static const unsigned n_in = 10;
    static const unsigned n_out = 10;


    static const unsigned io_type = io_parallel;
    static const unsigned strategy = latency;
    static const unsigned reuse_factor = 1;
    static const bool store_weights_in_bram = false;
    static const unsigned n_zeros = 0;

    template <class data_T, class res_T, class CONFIG_T> using kernel = nnet::DenseKernel<data_T, res_T, CONFIG_T>;




    template <class x_T, class y_T> using product = nnet::product::mult<x_T, y_T>;
};

template <class data_T, class res_T, typename CONFIG_T>
void dense(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
           typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
           typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
#pragma HLS INLINE
 CONFIG_T::template kernel<data_T, res_T, CONFIG_T>::dense(data, res, weights, biases);
}

template <class data_T, class res_T, typename CONFIG_T> class DenseLatency : public DenseKernel<data_T, res_T, CONFIG_T> {
  public:
    static void dense(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                      typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                      typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
#pragma HLS INLINE
 dense_latency<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    }
};

template <class data_T, class res_T, typename CONFIG_T>
class DenseResource_rf_leq_nin : public DenseKernel<data_T, res_T, CONFIG_T> {
  public:
    static void dense(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                      typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                      typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
#pragma HLS INLINE
 dense_resource_rf_leq_nin<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    }
};

template <class data_T, class res_T, typename CONFIG_T>
class DenseResource_rf_gt_nin_rem0 : public DenseKernel<data_T, res_T, CONFIG_T> {
  public:
    static void dense(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                      typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                      typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
#pragma HLS INLINE
 dense_resource_rf_gt_nin_rem0<data_T, res_T, CONFIG_T>(data, res, weights, biases);
    }
};

}
# 13 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_dense_compressed.h" 1






# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\math.h" 1 3
# 8 "firmware/nnet_utils/nnet_dense_compressed.h" 2

namespace nnet {

template <typename CONFIG_T>
void fill_mult(typename CONFIG_T::index_t index, typename CONFIG_T::accum_t mult[CONFIG_T::n_out],
               typename CONFIG_T::accum_t weight) {
    VITIS_LOOP_14_1: for (unsigned k = 0; k < CONFIG_T::n_out; k++) {
#pragma HLS UNROLL
 if (k == index)
            mult[k] += weight;
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_compressed(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                      typename CONFIG_T::weight_t weights[CONFIG_T::n_nonzeros],
                      typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {

    const int multiplier_limit = ((CONFIG_T::n_nonzeros + CONFIG_T::reuse_factor - 1) / CONFIG_T::reuse_factor);

    typename CONFIG_T::accum_t acc[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=acc complete
#pragma HLS ARRAY_PARTITION variable=biases complete
#pragma HLS ARRAY_RESHAPE variable=weights block factor=multiplier_limit


#pragma HLS AGGREGATE variable=weights




InitAccum:
    for (unsigned i = 0; i < CONFIG_T::n_out; i++) {
#pragma HLS UNROLL
 acc[i] = (typename CONFIG_T::accum_t)(biases[i]);
    }


    const int rufactor = CONFIG_T::reuse_factor;
ReuseLoop:
    for (unsigned ir = 0; ir < rufactor; ir++) {
#pragma HLS PIPELINE II=1 rewind

 typename CONFIG_T::accum_t mult[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=mult complete

 ResetMult:
        for (int imult = 0; imult < CONFIG_T::n_out; imult++) {
#pragma HLS UNROLL
 mult[imult] = 0;
        }

    CompressedMultLoop:
        for (unsigned im = 0; im < multiplier_limit; im++) {
#pragma HLS UNROLL
 unsigned w = im * rufactor + ir;
            auto row = weights[w].row_index;
            auto col = weights[w].col_index;
            auto weight_cache = weights[w].weight;
            data_T data_cache = data[row];

            typename CONFIG_T::accum_t prod =
                CONFIG_T::template product<data_T, typename CONFIG_T::weight_t>::product(data_cache, weight_cache);
            fill_mult<CONFIG_T>(col, mult, prod);
        }

        VITIS_LOOP_74_1: for (int im = 0; im < CONFIG_T::n_out; im++) {
            acc[im] += mult[im];
        }
    }


ResultLoop:
    for (unsigned i = 0; i < CONFIG_T::n_out; i++) {
#pragma HLS UNROLL

 res[i] = cast<data_T, res_T, CONFIG_T>(acc[i]);
    }
}

}
# 14 "firmware/parameters.h" 2
# 1 "firmware/nnet_utils/nnet_dense_stream.h" 1






# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 1 3
# 8 "firmware/nnet_utils/nnet_dense_stream.h" 2
# 1 "C:/Xilinx/Vitis/2024.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\math.h" 1 3
# 9 "firmware/nnet_utils/nnet_dense_stream.h" 2

namespace nnet {

template <class data_T, class res_T, typename CONFIG_T>
void dense_latency_wrapper(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                           typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                           typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
#pragma HLS PIPELINE II=CONFIG_T::reuse_factor
 dense_latency<data_T, res_T, CONFIG_T>(data, res, weights, biases);
}

template <class data_T, class res_T, typename CONFIG_T>
void dense_resource_wrapper(data_T data[CONFIG_T::n_in], res_T res[CONFIG_T::n_out],
                            typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
                            typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
    dense_resource<data_T, res_T, CONFIG_T>(data, res, weights, biases);
}

template <class data_T, typename CONFIG_T>
void data_prepare(hls::stream<data_T> &data_stream, typename data_T::value_type data[CONFIG_T::n_in]) {
#pragma HLS INLINE

 if (CONFIG_T::n_in / data_T::size > 1) {
    DataPrepare:
        for (int i_in = 0; i_in < CONFIG_T::n_in / data_T::size; i_in++) {
#pragma HLS PIPELINE
 data_T data_pack = data_stream.read();
        DataPackPipeline:
            for (int i_pack = 0; i_pack < data_T::size; i_pack++) {
#pragma HLS UNROLL
 data[i_in * data_T::size + i_pack] = data_pack[i_pack];
            }
        }
    } else {
        data_T data_pack = data_stream.read();
    DataPackSingle:
        for (int i_pack = 0; i_pack < data_T::size; i_pack++) {
#pragma HLS UNROLL
 data[i_pack] = data_pack[i_pack];
        }
    }
}

template <class res_T, typename CONFIG_T>
void res_write(typename res_T::value_type res[CONFIG_T::n_out], hls::stream<res_T> &res_stream) {
#pragma HLS INLINE

 if (CONFIG_T::n_out / res_T::size > 1) {
    ResWrite:
        for (unsigned i_out = 0; i_out < CONFIG_T::n_out / res_T::size; i_out++) {
#pragma HLS PIPELINE
 res_T res_pack;

        ResPackPipeline:
            for (int i_pack = 0; i_pack < res_T::size; i_pack++) {
#pragma HLS UNROLL
 res_pack[i_pack] = res[i_out * res_T::size + i_pack];
            }
            res_stream.write(res_pack);
        }
    } else {
        res_T res_pack;

    ResPackSingle:
        for (int i_pack = 0; i_pack < res_T::size; i_pack++) {
#pragma HLS UNROLL
 res_pack[i_pack] = res[i_pack];
        }
        res_stream.write(res_pack);
    }
}

template <class data_T, class res_T, typename CONFIG_T>
void dense(hls::stream<data_T> &data_stream, hls::stream<res_T> &res_stream,
           typename CONFIG_T::weight_t weights[CONFIG_T::n_in * CONFIG_T::n_out],
           typename CONFIG_T::bias_t biases[CONFIG_T::n_out]) {
#pragma HLS INLINE recursive

 typename data_T::value_type data[CONFIG_T::n_in];
#pragma HLS ARRAY_PARTITION variable=data complete

 typename res_T::value_type res[CONFIG_T::n_out];
#pragma HLS ARRAY_PARTITION variable=res complete

 data_prepare<data_T, CONFIG_T>(data_stream, data);
    if (CONFIG_T::strategy == nnet::latency) {
        dense_latency_wrapper<typename data_T::value_type, typename res_T::value_type, CONFIG_T>(data, res, weights, biases);
    } else {
        dense_resource_wrapper<typename data_T::value_type, typename res_T::value_type, CONFIG_T>(data, res, weights,
                                                                                                  biases);
    }
    res_write<res_T, CONFIG_T>(res, res_stream);
}

}
# 15 "firmware/parameters.h" 2


# 1 "firmware/weights/w2.h" 1
# 12 "firmware/weights/w2.h"
model_default_t w2[12800] = {-0.0756676421, -0.1076232344, 0.0466070771, 0.0759256408, -0.0263904408, 0.2252092510, -0.0459975600, -0.0186362602, -0.2869565487, 0.4339684248, -0.0105966376, 0.1287984848, 0.1547917426, -0.0994789153, 0.1077457368, 0.6013286114, 0.0536460616, -0.2713207603, -0.0699367002, -0.2608984113, 0.5260864496, -0.1464551091, -0.0597575940, 0.0243622009, 0.0082662525, 0.2414033711, -0.0962788910, 0.0863497406, -0.1430922747, -0.0649928451, -0.1827534884, 0.4022317231, -0.3064680099, -0.5171166658, 0.0511616357, -0.0760213062, 0.1083879471, 0.0816444606, -0.1512194872, -0.1189616099, -0.0338999890, 0.1004845574, -0.0697906464, -0.0822641253, -0.1230221912, 0.1738084257, -0.0575307757, -0.1469029486, 0.0786115900, -0.1775780618, -0.2516113520, 0.1205815747, -0.2027591467, -0.0554557741, 0.0708804876, 0.1025758460, 0.6525135636, 0.1537168622, -0.0038881863, 0.2446085811, -0.3155905604, -0.2275151163, 0.1242724508, 0.2226199061, 0.0637086257, -0.2945678532, 0.0859133378, 0.1013116091, 0.2548979223, 0.0807335749, -0.1175256521, -0.1762856394, 0.1439219564, 0.0481580310, -0.1834351271, -0.0794374943, -0.5850388408, 0.0506275073, -0.1440188736, -0.2198592275, 0.0617081225, -0.0706397519, 0.4613364339, 0.1430076957, 0.3463858962, 0.1297609955, 0.0422002599, -0.0103659034, 0.1209110767, 0.2007029355, 0.0087555991, -0.1853441745, -0.2756253779, -0.1540732533, 0.0546790287, -0.0864607841, 0.1205483675, -0.0874757320, 0.2079114914, -0.1239440888, -0.2001452446, 0.3183964193, -0.0730273202, 0.0526281781, -0.1615777463, -0.1661352366, 0.1413608640, 0.2430461943, 0.0603167005, 0.0387980156, -0.1754326671, -0.0623317510, 0.3751395047, -0.1788360626, 0.1211160123, -0.1582283229, 0.0276927110, 0.2034298331, -0.1708746105, 0.2161179483, 0.1119890139, -0.0191176943, 0.1113111377, -0.1599076092, 0.1403051466, -0.2204124629, -0.1048207954, 0.3629141152, 0.1282973439, 0.0406515151, 0.0817548335, -0.1137716323, -0.1535444707, 0.4022588730, -0.1076921970, 0.1365247369, -0.3546479642, 0.0980599895, -0.1468477547, -0.1106133908, -0.1033949256, -0.1214422360, -0.4816204309, -0.6866431832, 0.0122035844, -0.1481015682, 0.0704857334, -0.3049907684, 0.0506114140, 0.0913795382, 0.1533057839, -0.1309543699, 0.0745364055, 0.1821625531, -0.0828697830, 0.1847744584, 0.0126237394, 0.1050654501, 0.0051235617, 0.7254818082, 0.1543100774, 0.0394721143, 0.1422194093, -0.1932966709, 0.0067772153, 0.2142935246, -0.1947247833, -0.0782284662, 0.1173804775, 0.1679243296, 0.0982874408, 0.2050652504, 0.1147291884, 0.3978787065, -0.1147319376, -0.7877698541, 0.1518039405, -0.0719336346, 0.1846759915, -0.2308939546, 0.0474811792, -0.1242557019, 0.0101383524, 0.0010648940, -0.3787865639, -0.2331386060, -0.0283215437, -0.1228836626, -0.2603181303, -0.5888602734, -0.0181490779, 0.3003687561, -0.0452457368, -0.1667132825, -0.0738627240, 0.0687254220, -0.4354267120, 0.0521949343, -0.0963247642, 0.1291969717, 0.2372642606, 0.0452675745, -0.0540007837, -0.1797062904, 0.4121516943, 0.1213355735, -0.0347097963, 0.3909710050, -0.1540763527, 0.0396302044, 0.1216169298, -0.0462964699, 0.1370052695, 0.3869155645, 0.0525484607, 0.0069026202, -0.3835552633, -0.1205481365, 0.0452031903, 0.0696427077, 0.0728062317, -0.1425372511, -0.0757899582, -0.0800125748, 0.0488666669, 0.1390331984, -0.1982101649, 0.1476764530, -0.2067825496, -0.1155620813, -0.5521195531, 0.1249297187, -0.1750690341, -0.0011245244, 0.0704285502, -0.1345728785, 0.0612525009, -0.1521847248, -0.0392742790, 0.2110213935, 0.5776748061, 0.1548893154, -0.1573816836, -0.2684158683, 0.0554163493, 0.0984757021, -0.1545223445, 0.3014129996, 0.1262614876, -0.1988243610, 0.0972272977, -0.1127522886, 0.0415487662, 0.2680868804, 0.0804990605, -0.6470761895, -0.0897157118, 0.0912764296, -0.3947488070, 0.1406026632, -0.0243553333, 0.4825161397, 0.0231769942, 0.1111470461, 0.3040394485, 0.0974860415, -0.1889676303, -0.6036413312, 0.0202958398, 0.0785834268, 0.0495559573, -0.3984488845, 0.0785006210, 0.0459550507, 0.0416035019, 0.0358815119, 0.1288976669, 0.0394717231, 0.0908410922, 0.1290632039, 0.0111394441, -0.0572986379, -0.1619960219, -0.1699063033, -0.1245383993, -0.0481516197, -0.0825705454, -0.3138496876, -0.1238126308, -0.4441047311, 0.0190141518, -0.0889807492, -0.0180603396, 0.6822972894, 0.0883121192, -0.5322279334, 0.0287405625, -0.0645261183, 0.0887035802, 0.1805943847, 0.1105439588, -0.1234345362, 0.1533634961, -0.4974679351, 0.1476319879, 0.1454983801, -0.1381078660, 0.4261822402, 0.1208172813, -0.1841658354, -0.0532148518, 0.0455137156, 0.6222589016, -0.2473086715, 0.1267579794, 0.0522252396, -0.2609847784, -0.0301941186, -0.1009263545, -0.2574388087, 0.0285316687, -0.0383937061, 0.4854885936, -0.1485188007, -0.0461829342, 0.0368163660, -0.0210237801, 0.1500921100, -0.0202573556, -0.0666295812, 0.1544719934, -0.0433714464, -0.3694123030, -0.1530321091, -0.0003821842, 0.0032836155, -0.0825489387, 0.0774082765, 0.1265698969, 0.0282036141, -0.2240352780, 0.4342890382, -0.0397590213, -0.0830179304, -0.2672800720, 0.0624138750, -0.0854185596, -0.1076567769, -0.1596612781, 0.0928070843, -0.0556733906, 0.0293769408, -0.1690317094, -0.0903523266, -0.3393226266, -0.0384353139, -0.0195689499, 0.1033814251, -0.0236640293, 0.0833828822, -0.0845746323, 0.1450728923, -0.1762022227, -0.0390564241, -0.2034942955, -0.0941422656, -0.1390908957, 0.5815551877, 0.0130898729, -0.3179427981, 0.0090707308, 0.2388838828, 0.0069304663, 0.0486214310, -0.1131249517, -0.6864537001, 0.5039497018, -0.2757397294, 0.0357906595, -0.0270980056, -0.1184848472, 0.0928347111, -0.1507021487, -0.0209469665, -0.1320552081, 0.0377235077, 0.0740263388, -0.1338214129, 0.1002691463, 0.1610464007, -0.1693032980, -0.1066520214, -0.5425008535, 0.0622076467, 0.0713556409, -1.0394357443, 0.0346172154, -0.1231399775, -0.0412187167, -0.6761686802, -0.0827411562, -0.1859285831, 0.1994620115, -0.0376243889, 0.3152875900, -0.1509553194, -0.1817897409, -0.1165203452, 0.1083803922, -0.0734041408, 0.1863168180, -0.1100023463, -0.0842005238, 0.0499120578, 0.0638848469, -0.4690583646, -0.0593937300, -0.0555251911, 0.0813920051, -0.1711820066, -0.0051478734, 0.4374786019, -0.0948731750, -0.6554221511, -0.1575651765, -0.2262055725, -0.0925590992, 0.1534903198, -0.0697953925, 0.1014609486, -0.0398393683, 0.0138369091, 0.0010590077, 0.1155888215, 0.1215679944, 0.2736535370, 0.0522018149, -0.3146039248, -0.0794306546, 0.0752058849, -0.1053680778, -0.0595224537, -0.0647002682, 0.3255100846, 0.3453318179, 0.2797855139, -0.1088449657, -0.6680551767, 0.0663212016, -0.2750629783, -0.4550738335, -0.1779055148, 0.0396436565, 0.1308578998, -0.1449149847, 0.1699120104, 0.1410961598, -0.1429151297, -0.0301410425, -0.0584774166, -0.3676201701, -0.0301174857, 0.0168245658, -0.3744157255, 0.0152267814, 0.0034520703, 0.3789150119, 0.0268230420, -0.0611035302, 0.4952011108, -0.1386926174, -0.1529527605, 0.7792176008, 0.1138323620, 0.0572428219, 0.0435928665, -0.0188019034, 0.0582419038, -0.0356974378, 0.1186032146, 0.0755032897, 0.0888287276, 0.2770714760, -0.0675023943, -0.1469551474, -0.1401055306, -0.1161057204, -0.0421750285, -0.0583678111, -0.0236304551, 0.1884204745, -0.1974529326, -0.1656474173, 0.0707930252, -0.7870196104, -0.1023409069, 0.2275170386, -0.3045789003, 0.0686434880, 0.4930770993, -0.1541853100, 0.0990897715, -0.1158001572, -0.3600669801, 0.0659411177, 0.3661460876, -0.1219032109, -0.0179808680, 0.0597252697, -0.2011812180, 0.0526433289, -0.2512390614, 0.1082175002, 0.0997036770, -0.2349728048, 0.0314212739, 0.0542927273, 0.2710249126, 0.0764785558, 0.1128492355, -0.0239360854, 0.5036959052, -0.2214332521, -0.1702186167, -0.1423389316, -0.0868890956, -0.0106777688, 0.9193648696, 0.1504644156, 0.4965765178, 0.5016034245, -0.0996820405, 0.6705921888, 0.0954651535, 0.0922550932, 0.1035633534, 0.1598502994, -0.1779667586, -0.0112543898, -0.1433454156, -0.0058095879, -0.1944514215, -0.0194299147, -0.0134202531, -0.2510026395, -0.0532769896, 0.1037086546, 0.0360088721, 0.0665854588, 0.5639063120, 0.4595157504, -0.7983300090, 0.0346193425, -0.1498577297, 0.1157956496, 0.0954355299, 0.0018709569, 0.1372488141, -0.0892199203, 0.4680340588, -0.1530291140, 0.0370750725, 0.0767013133, 0.7016806006, -0.1343543082, -0.2670090795, -0.1404084563, -0.0810196251, -0.0689201429, 0.4882735610, -0.1517868191, 0.2216300964, 0.5057325959, -0.0488902591, 0.0975934714, 0.2635617256, -0.0743827522, -0.3748309612, -0.8309355378, 0.1132274196, 0.0619111210, -0.1744721681, -0.0001136661, 0.1501297057, 0.1607268155, 0.0164547320, -0.0457890444, -0.2221637666, 0.6319955587, -0.0892672911, -0.0206414834, -0.1139611229, 0.0130194724, -0.1540195048, -0.0537348166, -0.1205075681, -0.0502942950, 0.0373441651, -0.2830754220, 0.0091846138, 0.4497318566, 0.0751432031, 0.1015692279, 0.1324363947, 0.2170702070, -0.0764693841, 0.0937776268, -0.0094148517, -0.0895071477, -0.0426453277, -0.1371864229, 0.0566576123, -0.0684530586, -0.0271805171, 0.0942912400, 0.0346848331, 0.1140891910, 0.0749708414, -0.0726858228, 0.0605107807, 0.0358613208, -0.0148077728, -0.0857260302, -0.2357494682, 0.1827131361, -0.1084366441, 0.0936897844, 0.6441562772, -0.1569176763, -0.1824490726, -0.1992231905, -0.0225004181, 0.4498386383, 0.1682659984, -0.1381504983, -0.0481153689, 0.0961885527, -0.1164517850, 0.0118791442, -0.4069356620, -0.1618676782, -0.1737694442, -0.3876296580, 0.0921935141, 0.3546995223, -0.1741647124, 0.0391442291, -0.0563743711, -0.4814718068, -0.5065630078, 0.0475017764, 0.0192046259, 0.1386702359, -0.1738592237, 0.5440869331, -0.2709774077, -0.0504978746, 0.3650916517, 0.2981483042, 0.2002525032, 0.7320533395, -0.0131886788, -0.1890199333, -0.1730099320, -0.1660229862, -0.2708376944, -0.0706927776, -0.1123288572, 0.1431297660, 0.0030027116, -0.1824230850, 0.1197939962, -0.1204636022, 0.0773980841, 0.1318348050, 0.1453002542, 0.0739775747, -0.1896157265, 0.0725791454, 0.6915153265, 0.0739319921, 0.0728419423, -0.0428121909, -0.0133800833, -0.1641924828, -0.2854446471, -0.0948662236, -0.0592761301, 0.0193549078, 0.0373863727, -0.2267901897, 0.2092087865, 0.0160297621, -0.0933770463, -0.1723668724, -0.0423466712, -0.6069432497, -0.0058929711, 0.1245346740, -0.5394774079, -0.5190367699, -0.0763394162, 0.0391488373, -0.1686896235, 0.1367300302, 0.2364698797, -0.1489720345, 0.0114408536, 0.0269129612, -0.0254320577, -0.0725950077, -0.1813708991, 0.1850603670, 0.0322815068, 0.0093794223, -0.1441888064, -0.3802050948, 0.1198949516, 0.0414289124, 0.2653782666, 0.0749295652, 0.1438950896, 0.1340724975, -0.1124371737, -0.2059549540, 0.8056017160, -0.0516995750, -0.0604028329, -0.0648972169, 0.0946088880, 0.1493308544, -0.0824800655, 0.0211850163, 0.0070253848, -0.1387065947, -0.1094589531, -0.0173028149, -0.0004698579, -0.0127157886, -0.0090735555, -0.1417010427, 0.0444722772, 0.5159339309, -0.0127469981, 0.1622969955, 0.1315142363, -0.3090383112, -0.1636874676, -0.1586332321, 0.0833467692, 0.0853539407, 0.7465143800, -0.0998139083, -0.4271979630, 0.0137719791, 0.0376714952, -0.0706285685, -0.0571375340, -0.0692581087, -0.3962358832, -0.0522961766, -0.1226715520, 0.1223052070, 0.0561446324, -0.1297365427, -0.1020469517, -0.0874079689, 0.3685017526, 0.0248848367, 0.0178891160, -0.1382584125, 0.0839615613, 0.4583562613, 0.1400796175, -0.3375202715, -0.0340096243, -0.5103414655, 0.2893580496, 0.0375225917, 0.6977480054, 0.0736054853, -0.1473311335, -0.3446129858, 1.1550534964, 0.0872665197, -0.2054783255, 0.3148094416, -0.0513628200, -0.2134667635, -0.0944389328, -0.1306413114, -0.0811361000, -0.0010394786, 0.0355545208, -0.0646758229, 0.0318572223, -0.1076859906, -0.3844263554, -0.1234951168, -0.3530777097, 0.3972893953, 0.1043450311, 0.0570397153, -0.0792413428, 0.0734833777, -0.0609716550, -0.3733086586, -0.4364179075, 0.0024602965, 0.0603203736, -0.0914542228, -0.0061033433, 0.1007857844, 0.0028095334, 0.0188485943, -0.3602191210, -0.1129958108, -0.1263449788, 0.0192469545, -0.0123522347, 0.0953270495, -0.0660872683, 0.0720507503, -0.1015204638, 0.0251227506, -0.0148953339, 0.1044945717, 0.2191198468, -0.3945406973, 0.2011125833, -0.0346609950, -0.4736863971, -0.0636564940, -0.0234090779, -0.2222898751, 0.1068855152, -0.2533478141, 0.0398719795, -0.0454505756, 0.1636147946, 0.1207739711, -0.1732961386, -0.0212054141, 0.0326982327, -0.0880811140, -0.1174686328, -0.1056412831, 0.3821906149, -0.0228777528, 0.0286023561, -0.2706931829, -0.1548067927, 0.2673952281, 0.0246646907, -0.0496614128, 0.1464655846, -0.2099402100, 0.0013575916, -0.0066574183, 0.0866606236, -0.1935727149, -0.1346022636, 0.0014614968, 0.0002061813, 0.0690449998, -0.0576307327, -0.1311392933, -0.0739337727, 0.1422892213, 0.2254923582, -0.0332098603, 0.0447604544, -0.1020995006, -0.1348163188, 0.1395781934, 0.2980567515, -0.0087475572, -0.0513102077, 0.1627459973, -0.1614166200, 0.2568923235, 0.0693967864, 0.0307249427, -0.1871295422, 0.0007104931, -0.1398051381, -0.0720182508, -0.0110552534, -0.4645783305, 0.3987993002, 0.0463978276, -0.0797184855, 0.0860324055, 0.0002405619, 0.0071114628, 0.1457606703, -0.1276442260, -0.1391825080, -0.2124465108, 0.0100957910, 0.1191725656, -0.0898490697, 0.0384895094, -0.0704687014, -0.0888494328, 0.1293540895, 0.0652295873, 0.0308975279, -0.0636207089, -0.0104851108, -0.5192710757, -0.2508733869, -0.0845525265, 0.1523503959, 0.2051111609, -0.1658149511, 0.4079189599, -0.1112672538, 0.1202679127, 0.0126555357, -0.2324560434, 0.0145988446, -0.4090539813, -0.2119626999, -0.1356664598, -0.1114553884, 0.0208752509, 0.6738046408, 0.3342720270, -0.1289650947, 0.1606084555, 0.1411989927, -0.0960560441, 0.6082410812, -0.0419449061, 0.8652400970, -0.0674233362, -0.0587421358, 0.0748043731, 0.0705543756, -0.0608472563, 0.0580478311, 0.1621379405, -0.1253263950, -0.1583696455, -0.0070261899, 0.0125428969, 0.4549074471, -0.0792094320, 0.1119800657, -0.1180027351, 0.1049688756, 0.2338428795, -0.0421714894, -0.1379382014, 0.6347130537, 0.2871365547, -0.2559805214, -0.1500520557, 0.0196535140, -0.0623339824, -0.0951834843, -0.0184614286, -0.1110013276, -0.3915368021, 0.0450336039, 0.1270189136, -0.0607213341, -0.0210823398, -0.0556360334, 0.1582645029, 0.1242823824, 0.1374324113, 0.0102082472, -0.0279350765, -0.0856298059, 0.0596762598, 0.1513735950, -0.0699065626, 0.0231937189, -0.0056347586, -0.2912620902, 0.1601915807, 0.0449937284, -0.3892892003, 0.1292617470, 0.0039999224, -0.0637264401, 0.0052861078, -0.0790114254, 0.1076349765, 0.1191333532, -0.0238275323, 0.0923855826, -0.2743124068, 0.0093937442, 0.1157407463, -0.0817144811, -0.4220300615, 0.1252734810, -0.1202770174, 0.0953793451, 0.4686111212, 0.2397172451, -0.1523529887, -0.1546619385, 0.5825248361, -0.6772050858, -0.7280418873, 0.2156988829, 0.1256532669, 0.4958766401, 0.0025065674, 0.1414177120, 0.1010057330, 0.2167339474, -0.3182142079, -0.0388898887, -0.0465839431, 0.1100291386, 0.0019286975, 0.1094952151, -0.0554942749, 0.3040733337, 0.0634178892, -0.0909760371, 0.0770015270, -0.0452037640, 0.1769953370, -0.6421113014, -0.0423747785, 0.0470928513, -0.0683878064, -0.0142008606, -0.1908445358, 0.0806823298, 0.1762562692, -0.1585849971, 1.5431600809, -0.0066720489, 0.1148736328, 0.5335195065, 0.0123927351, 0.1880884767, -0.6624674797, -0.0870732144, 0.0426721126, -0.1724597961, -0.0927488133, -0.1406578422, -0.0486648642, 0.0391285196, 0.0617897771, -0.0556669347, -0.1307437569, 0.6528634429, 0.1105783135, -0.2207228988, 0.0455838218, -0.0780756027, 0.0112326937, -0.2784863710, -0.0542350151, -0.1420184374, -0.0457406528, -0.0859406590, 0.0876865759, 0.0534266457, 0.0797107741, -0.0356716365, -0.0553802848, -0.3666613102, 0.0541673228, 0.0292338859, 0.0293695647, 0.1024428308, -0.1466681361, -0.0931524932, -0.0663282797, -0.1418626010, -0.2518421412, -0.1561210454, 0.1200644001, 0.0983803794, -0.1729890704, -0.1370815635, -0.0394097120, -0.0737807527, 0.1026086807, 0.0155640272, -0.3637002707, -0.1307280809, -0.1874370873, -0.0689436272, 0.0119846463, 0.1272635162, 0.2071034312, 0.0477067828, -0.0807789490, 0.0825556293, -0.2842060328, 0.0105115948, -0.1186190322, -0.2698423862, 0.0505419672, -0.0779432058, -0.4731177390, -0.0818169713, -0.1251708418, -0.0834177509, -0.1054706275, 0.0079894960, 0.1613015532, -0.0538314432, 0.0241235085, 0.0997870490, 0.2770313323, 0.0225349851, -0.1286979467, -0.1829979718, -0.1557823569, -0.0211143922, -0.3711185753, 0.1081971377, 0.0851522833, 0.0513602830, -0.0483049043, -0.0559184104, -0.0194396731, 0.0735533535, 0.1781305075, -0.3705380559, 0.0991269723, -0.0348478183, 0.4304133058, -0.3880693018, -0.4668934047, 0.2360157371, -0.0256989188, -0.5992795825, 0.0873800889, 0.3227550983, -0.0998154208, -0.2489452511, -0.1592564732, 1.0361183882, 0.0580096580, -0.0062976214, -0.0689762905, -0.2598080039, 0.0242880620, 0.1891110837, -0.1854745299, -0.1073035970, 0.1602649093, -0.0545757487, 0.1632965952, 0.1702407449, 0.3051778376, 0.0975804701, 0.1936686486, -0.2022333890, 0.0626395047, -0.1262673438, -0.1305649877, 0.0397839956, -0.0217936151, -0.5196304321, -0.0952889100, -0.1486470401, 0.4208966494, -0.2965363264, 0.1488074064, -0.1472574323, 0.0695851445, -0.0225752033, -0.0942496210, -0.3347566128, -0.1729706377, 0.0087086419, 0.0969310254, 0.0042787506, 0.0081527606, 0.3825283945, 0.4638657272, -0.0590771362, -0.0700339079, 0.0057524061, -0.0114229079, -0.7407666445, 0.2637623847, -0.7916050553, 0.1010417193, 0.0889896974, -0.1632707119, -0.1264888942, 0.1270060688, 0.0027987321, 0.0619462840, 0.9425397515, 0.0565108322, 0.0406351164, 0.1529051065, -0.0961456671, -0.1781890094, -0.0771235153, -0.0678523257, 0.0678684488, 0.0988626406, 0.0764176995, 0.0628002658, 0.4365763068, 0.5204271078, 0.0222278163, -0.0439003408, -0.2387009710, 0.0998906046, -0.1556550860, 0.1161142662, -0.1246889010, -0.1219362766, -0.1985349655, -0.0609469339, -0.0144827086, 0.0729247183, 0.0641183853, -0.2573055327, 0.0307869539, 0.7331849933, 0.0217513144, 0.1035887524, -0.3525115848, 0.0979173630, 0.0963600799, -0.3571192026, -0.1691367477, -0.0867046863, -0.5153725147, -0.0236791633, 0.1474405080, -0.0156009868, -0.0762273148, 0.0132361976, 0.0344810225, -0.2880637348, -0.1299996227, -0.1073895022, 0.0024265894, 0.0778450966, -0.1138729155, 0.1733936071, 0.1100195572, 0.0455203727, 0.2925969660, -0.1770289391, 0.0391549580, -0.0198299922, -0.1716433764, -0.2686809897, -0.2735205591, -0.1685196608, -0.1905912012, -0.0619088151, -0.5538644791, -0.4610870779, 0.0657200292, 0.0707526356, 0.2998038828, -0.0259382445, 0.2173236459, -0.2301803529, 0.2849563956, 0.2458504587, -0.1523164958, 0.1274113059, 0.0027920986, 0.2500964999, -0.0456832722, -0.1920396984, 0.1135067716, 0.0538540035, 0.1244340837, -0.0540815331, 0.0738358051, 0.2295419723, -0.0434834883, -0.2348858863, 0.0184381939, 0.4899559915, -0.3175370991, -0.1075020432, -0.4123129845, -0.0339877494, 0.1119328663, -0.9040504098, -0.0935532078, 0.0936421156, -0.1168538630, 0.3344457150, 0.1122115329, 0.2023579925, 0.0550738536, 0.0147546213, 0.1365959197, -0.0885358676, -0.3891938925, 0.2655644417, -0.0488971919, 0.0221884642, -0.1461050212, -0.1036330611, -0.2808931470, 0.0034990825, 0.0984892920, -0.0406200625, -0.0819196552, -0.1724670231, 0.3932028711, 0.1308482289, -0.3019047379, 0.0682115406, 0.1753090322, -0.1477933377, -0.1723688990, 0.1289923042, -0.2375565767, -0.0197688304, 0.5726400018, -0.0857116580, 0.0554843061, -0.1857827604, 0.2201627195, 0.0172014982, 0.1263599992, 0.0743392184, -0.1602699757, -0.1629713625, -0.5263830423, -0.1618487537, -0.6495484114, 0.1573353261, -0.2140963227, 0.0869466215, 0.1435061395, 0.0935227796, -0.2887853682, -0.3428341746, -0.0785561576, -0.2067802399, -0.1407880783, -0.1102391034, 0.0755172446, 0.1302819103, -0.0770969018, 0.1277983487, -0.0494827963, 0.3750832081, 0.0974616185, -0.0997612253, -0.4197117984, 0.0066995174, -0.0172707941, -0.2910905480, -0.0033447549, -0.0104597202, -0.4155192971, 0.2733064890, 0.0270670056, 0.3357026279, -0.1021879613, 0.0758622810, 0.0197222177, 0.1155851632, -0.1399845034, 0.1214992702, -0.0344910622, 0.0397066697, 0.0858307704, 0.2692162097, 0.0417304486, -0.1386991441, 0.1831382662, -0.1940228939, -0.1128401235, -0.1101125628, 0.1497536153, 0.4352647960, 0.2299366742, 0.1151811853, 0.0279076174, -0.0604755618, -0.2615131438, -0.2283314317, -0.2744755149, 0.0419406146, 0.0262422096, 0.1404635012, -0.0917358771, 0.0523668081, 0.9759122133, 0.0553494133, -0.4336726964, 0.0649266466, 0.0599587075, -0.1135339215, -0.2408532947, -0.0774332210, -0.1557692885, 0.0462947153, -0.0773146972, -0.2633130550, 0.0363612883, 0.1724741906, -0.1350257844, -0.3238798082, -0.2406892180, -0.0655018240, 0.1249895319, 0.0536155328, -0.3778197169, 0.0604575090, -0.0547794513, -0.2134460211, 0.7115728855, 0.0832971781, -0.0299091954, 0.0264847260, -0.1100860164, 0.2616627216, -0.0515484437, -0.1004621685, 0.0889575854, 0.1425737739, -0.1068125665, 0.1351233274, -0.0527592413, 0.0732902661, 0.0667540804, 0.1357633621, -0.1116628647, -0.0664571822, 0.7067334652, 0.0646314621, -0.1515133679, 0.1117959172, -0.3679151237, 0.6216676831, -0.2737286985, -0.1356113553, -0.3053863049, -0.0572726727, 0.0439591072, -0.0601678975, -0.2692387402, -0.0556236096, 1.0837301016, -0.1326750517, 0.0367250741, -0.2306806296, 0.3550996780, -0.0262541007, -0.1740245819, -0.1005712822, 0.1788027436, -0.4016229510, -0.7281985879, 0.0316203274, 0.1468456239, -0.0618964247, 0.1340915114, -0.0396642834, 0.0741232112, 0.0162013024, 0.3412022591, 0.7975950837, 0.1302937716, 0.0346265920, -0.0490933321, -0.1088333577, 0.1174129993, 0.1793308854, -0.0463806391, -0.0718084872, -0.0893137604, 0.1783355325, 0.0080893552, 0.0420972221, -0.3258660436, -0.1277403384, -0.0707830042, -0.2976275384, 0.0118126059, 0.1193558723, -0.2012347430, -0.2236889452, -0.0747784972, -0.9120187759, -0.0444956236, 0.1036201939, -0.1291780174, 0.1990568787, 0.0467017479, -0.1308450848, -0.1258959621, -0.1072212383, -0.1408114135, 0.1528362334, -0.1180001199, 0.1342015415, 0.0572182797, -0.1750690043, -0.1615965217, -0.0823984593, -0.1030069664, -0.6785583496, -0.2421765029, -0.0078186337, -0.1174574718, -0.2681652606, 0.3123283088, -0.1238706335, -0.0442847237, -0.0049528140, 0.5248382688, 0.1681382805, -0.2695345879, 0.1020857170, -0.4237875342, 0.4426991940, 0.1774473041, -0.0842867568, -0.0309995841, 0.0206355955, -0.2023066431, -0.1120805144, 0.2007656246, -0.0091760429, 0.0332250893, -0.1275552958, -0.1276852936, -0.3338831067, 0.1901724488, -0.2086928487, -0.0751751289, 0.2086403370, 0.1653714776, -0.0308144167, 0.6058335304, 0.0163138136, -0.1135106534, -0.4122672975, 0.5069161057, 0.0561844707, 0.1004782841, 0.1464442611, -0.2210733145, 0.6880962253, -0.0259928405, -0.0030695184, 0.0751150474, -0.1007684618, -0.0579590537, -0.1475107521, -0.0000053036, -0.1420336813, 0.0728663430, -0.0188203752, 0.1879483014, 0.0915082842, 0.1298652887, 0.1174077541, 0.1058085188, -0.1727662086, 0.2055266798, 0.1711486578, 0.3950451314, 0.1503272653, 0.1349223107, 0.0779049620, -0.1376232207, -0.0960983038, 0.2004356682, 0.0655915663, -0.2381566465, -0.1137639508, -0.1244828030, 0.1592799276, -0.3392480314, -0.0454714149, 0.0733663812, -0.2133187950, -0.0862035677, -0.2587885261, 0.0342738591, 0.0749531016, -0.7418859601, -0.2930903733, 0.0980129093, -0.0975319818, 0.3897684216, 0.1320019662, -0.0624751225, -0.0662676543, -0.1618730277, 0.2493757159, -0.1514850557, -0.1235004216, -0.0082967849, 0.0464914404, -0.0755179003, -0.1678591967, 0.0752051920, -0.4996019900, -0.1508611292, 0.1546259820, 0.1533974856, -0.0830343291, -0.1450217515, -0.0356004424, -0.1083569676, -0.0428270102, 0.1491631120, 0.0928839296, -0.1363321841, -0.1267214417, -0.1309939623, 0.0162477978, -0.1437107027, -0.3112582862, 0.0809570849, 0.1125925183, 0.0271125901, -0.1797629595, 0.0693560094, -0.0513179824, -0.1045883745, -0.0047778981, 0.1756677181, -0.0960968733, -0.2503458261, -0.0343201607, -0.0935292616, 0.0649489015, 0.2173098773, 0.0859096274, -0.1743326038, -0.0676267371, -0.0819654688, -0.3751310110, 0.0125869233, -0.0394939631, -0.6430977583, 0.0787869543, -0.2368220240, -0.0234106798, 0.1547505558, -0.7520375252, 0.4503200650, 0.0766255036, -0.1701400727, -0.2168596089, 0.0517237112, -0.0239742473, -0.1716599762, 0.1397284418, -0.0335482582, 0.0454134755, 0.0916918144, -0.0383777097, -0.6656987667, 0.2475675195, 0.0055696410, -0.0993771106, -0.1100303233, 0.0849206373, 0.4964774251, -0.0616826639, 0.0474972464, 0.2927091420, -0.8597732186, -0.0749444589, -0.0534524061, -0.3320136964, 0.2041829228, 0.5000407100, -0.0560249425, -0.1940012276, -0.0253779143, -0.0428937115, 0.1191129908, -0.2116595358, -0.2498381883, 0.0783140883, -0.2270425409, -0.1393322945, -0.7712755799, -0.4242228866, 0.1845342517, 0.0883495733, 0.0777776539, 0.0173450317, 0.4343066812, 0.2869369984, 0.1697007567, 0.0585679896, -0.1445920318, 0.0823173895, -0.1957745850, -0.1314432621, 0.1108088493, 0.1407609284, 0.3036488295, 0.0713611841, -0.1788621992, -0.3147617579, -0.2703219652, 0.0222291742, -0.2384466827, -0.0709795579, 0.0993460640, -0.0025621122, -0.0360912681, -0.0238564704, 0.1226946190, 0.4851167500, -0.1121243089, 0.1000957340, 0.4615628719, 0.1256445348, -0.0683186874, 0.5344744325, -0.0038543111, 0.0921478122, -0.0779595524, -0.0932571739, -0.1178879738, -0.0439580753, -0.0630155206, 0.0071971104, 0.0859239399, -0.2146607488, 0.1347054839, 0.0139518408, 0.0255597159, 0.1267029792, -0.0536797531, 0.2122335136, -0.0108174076, -0.3442028761, 0.1113092303, -0.0996321365, -0.0032164305, 0.4547246695, -0.0201657005, -0.1482912153, -0.0675787330, -0.0674367920, -0.0692790672, 0.0416792892, 0.0391988084, -0.0967294648, -0.0398812369, -0.2164325416, -0.1564202458, 0.0518214554, 0.2002962083, -0.0755506605, -0.1171297207, 0.1298734248, -0.0062930821, 0.6905543804, 0.3166149855, 0.0747145936, 0.0873809382, -0.0610722676, -0.3146157861, 0.4282777607, 0.0127468463, -0.1596619338, 1.0391581059, 0.0141101051, -0.1185899079, -0.0165580418, 0.2875916958, -0.1019224897, 0.2514167428, 0.0507267341, -0.0676631927, -0.0723660961, -0.2246899754, -0.1254597902, 0.6245597601, -0.0583962686, 0.0503139384, -0.0773343891, 0.1378404051, 0.0404567346, -0.4315217435, -0.1374094635, -0.1450376958, -0.1313168108, -0.0089521930, -0.0660321042, -0.4236097634, 0.1116139516, -0.0170271583, 0.4927857816, -0.5383662581, 0.0015678180, 0.1797711551, 0.3672372103, 0.0916826874, -0.3031313419, -0.1380037069, -0.0060629924, 0.0216756631, -0.1266625226, -0.3020038307, -0.0840663388, -0.0901304781, -0.0502133146, 0.0527889952, 0.1362587810, -0.3679287136, -0.2792876661, 0.4822401702, -0.1956907511, 0.1419936568, 0.1296672970, -0.0891489685, -0.1058184505, 0.3944670856, -0.0314411744, -0.2124902904, 0.1468487084, -0.1860051751, 0.0603876188, 0.0936263278, -0.1115403399, -0.6103778481, 0.0948776677, -0.1805980355, -0.0813309252, -0.1637113243, -0.1054227948, -0.0404316820, 0.1977176964, -0.0631001666, 0.2040512860, -0.1013553292, -0.1558989286, 0.0249691959, -0.2403248250, 0.2544507086, 0.0743595213, -0.0305847321, -0.1064335033, 0.0156977028, 0.4793731570, 0.1234295741, -0.1285490841, -0.0698564574, -0.0439911112, -0.1320929527, 0.2104044259, 0.0528270192, -0.0495089665, 0.1527875662, 0.1745378822, -0.0221216641, 0.0354090035, -0.2196650058, -0.1239655465, 0.0870828032, -0.0592362024, 0.0319618955, -0.1792921722, 0.0691899955, 0.3043216765, -0.0379222482, -0.2182081789, 0.1491059065, -0.0614445545, -0.0159213860, 0.4931335747, 0.0101268105, -0.0028683674, -0.1227828562, 0.0971320421, -0.1410074234, -0.3108222187, 0.0292860474, -0.0741839707, -0.3614615798, -0.0526112989, -0.2265544832, 0.0051809279, -0.0614551641, 0.0743386298, -0.0016203751, -0.1490195096, 0.0658098161, -0.3806213737, 0.1210744902, -0.0621535890, 0.1393608302, -0.0230369549, -0.3814499974, -0.1280155033, -0.0721493214, 0.1308103800, 0.2799398005, 0.4135766625, -0.0531999394, -0.1490815282, 0.1497949958, -0.1843597889, 0.1003286168, 0.0834230408, -0.1277936101, -0.1016863734, -0.0755681694, 0.0642601103, 0.0939941704, -0.1381106973, -0.2794882953, 0.2033044696, -0.0003354309, -0.1411280334, -0.1784973145, 0.0461820886, -0.8072204590, 0.0920111611, -0.1459379792, -0.0909932554, -0.7718324065, -0.0503756106, -0.2061856389, -0.2571690381, -0.0173201598, -0.1137005240, -0.0540400855, -0.1766135544, 0.0974316597, -0.1690887213, -0.2628948092, -0.1324634552, 0.1569617689, 0.0966823325, -0.0717693344, 0.0713263750, 0.4621097445, -0.1559984535, 0.2889970839, -0.1170076951, -0.1480612308, -0.1436884701, -0.2870668173, 0.2322741449, -0.1325566471, 0.1270395368, 0.1716468185, 0.0656541064, 0.0210852269, -0.0234140959, -0.0714472085, 0.0063240356, 0.0515380315, -0.1548605561, -0.0624650866, 0.0566010661, 0.2233299464, -0.2404598147, 0.1943126619, 0.0957338214, -0.1324718744, -0.1198250875, 0.3132312894, -0.1281327158, 0.1408125162, -0.0258439425, -0.4648439288, -0.0179354995, -0.0999470353, -0.1733953208, -0.1032034606, 0.2752345502, -0.0689823255, 0.2211271822, -0.2548124492, 0.0739022791, -0.0806498528, 0.1133863032, -0.0853090137, 0.1297057867, -0.1605392992, 0.0775118992, 0.0846688598, 0.0715388134, 0.2590507567, 0.1591627151, 0.1159488186, 0.3685455620, -0.1582931131, -0.0331704542, 0.2665855289, -0.2837545872, 0.0466826111, -0.9798600674, -0.0631554574, -0.0587055944, -0.0305966362, -0.0283737481, 0.1157890186, 0.1131305844, 0.0101678232, -0.0452585593, -0.1600104719, 0.3619828224, -0.2118996680, -0.0888514295, -0.0606869683, -0.0576908514, -0.1203996837, -0.0367731825, 0.0282282121, 0.6749892235, 0.2726801634, 0.0046340339, 0.0416315943, 0.0699662045, -0.6071897149, 0.4387759268, 0.3320528269, 0.0195039120, 0.3798460960, 0.1079237536, -0.1768774688, 0.1608077139, -0.0203125197, -0.4467751682, -0.1979639083, -0.1085492074, -0.0442670099, 0.1002060175, -0.1672227681, -0.1793795228, 0.1959651113, -0.1527102441, -0.0716454312, -0.0215974189, -0.0273974910, 0.2857569158, -0.0541346259, -0.0715775192, 0.1035242379, 0.1857094616, 0.6446484923, 0.0736690685, 0.6084982157, -0.1308558732, -0.1302918494, 0.7881684303, -0.9765558839, 0.0273880512, 0.1991258860, -0.5320413113, -0.1664515138, 0.0643581524, 0.0549603403, -0.0128256734, -0.0072451369, 0.1076427251, -0.4326954186, -0.1784243137, -0.1264731437, -0.1187453121, -0.0689956695, -0.1428981870, 0.0695351213, -0.0741122663, -0.1072091609, 0.0774855018, -0.1794125289, -0.1009763628, -0.3573758304, -0.0978673324, 0.2717499435, -0.0356904119, -0.1596036404, 0.0724593773, 0.0429764017, -0.1453019828, -0.0361669250, 0.2490167022, -0.5388594866, 0.0692510977, -0.1658139825, 0.2078233063, 0.1894158572, -0.0198363606, -0.0518170483, 0.1047406644, 0.0427060053, 0.0201644283, 0.0187346153, 0.1203408912, 0.4713841975, -0.0858262852, 0.1149537191, -0.1156991124, 0.1727893949, -0.0190523267, 0.3589552343, -0.5744997263, 0.0164985005, 0.0523368604, 0.0127504272, -0.0236289650, -0.1172851101, -0.0912628323, 0.0455364138, -0.1798358709, -0.1778632402, 0.0404157974, 0.0458488502, 0.0443920717, -0.0886015370, -0.0873222053, 0.0533001013, -0.3481532633, 0.0569618456, -0.0757790953, -0.4633880854, -0.0025111856, -0.0438587964, 0.4731275439, 0.0212328620, -0.1071187630, 0.0529405028, -0.0984306633, -0.0347693004, -0.1179771274, 0.0990631953, 0.0754578635, -0.0056207818, 0.0062980517, -0.1210785657, -0.0633575767, -0.0661798343, 0.2147862911, -0.2262310833, -0.2110064924, 0.1085919738, -0.1398191154, -0.1690595299, 0.0748292729, -0.1342496127, -0.1410968155, 0.5721444488, 0.6002916098, -0.0855375081, -0.0108059039, -0.7516561151, 0.0002985604, -0.1722933203, -0.0655011237, 1.0191639662, 0.6229030490, -0.2823568583, -0.0635752454, 0.0536073111, -0.1069451198, -0.2021368146, 0.0180851370, -0.2571682334, -0.0515921004, -0.1603384018, 0.0110691376, -0.0889766589, 0.0464438610, 0.0513521954, -0.0521818586, -0.2040387094, -0.2624706924, -0.0864508301, 0.0777291209, 1.0034562349, 0.1543521732, 0.0468455665, 0.4848383367, -0.5609924793, -0.0964175016, 0.8784213066, 0.1538834721, -0.0182178020, 0.4238106608, -0.1469796598, -0.0978252143, -0.0124752512, 0.1117049530, -0.1846409291, -0.0108826030, 0.0867808536, 0.0955761969, 0.0896285176, 0.1367302835, -0.7080644965, -0.0312397666, 0.0513190478, -0.1981404722, 0.0714398175, 0.1494104266, 0.2532556653, -0.1355994344, 0.3949692547, 0.0529375412, -0.0450130142, -0.0021623564, 0.0939698517, -0.1558191180, -0.3067624867, 0.0141627062, -0.1153261065, 0.0266717430, -0.0774620324, -0.0779958293, -0.3118367195, -0.0489947349, -0.1448897421, 0.0599715896, 0.1333758682, -0.2901446223, -0.1217269897, -0.1174916178, 0.5319295526, -0.6188874841, 0.0936025605, -0.0752344579, -0.5682163835, -0.1588467062, -0.2256516814, -0.1529793739, -0.0414114334, -0.1635762602, 0.0550656021, -0.1531964689, -0.0864586234, 0.0852845982, 0.1536944062, 0.1344090849, -0.1177625731, 0.2887107134, -0.1498851180, 0.0075248578, -0.0868616924, 0.1535283476, 0.1094309315, 0.1227633357, 0.0550341643, -0.4267084897, 0.2329484373, 0.1403578818, -0.1109564006, -0.0428103730, 0.0945569128, -0.0732382163, 0.0885247216, 0.1919406950, -0.0249681007, -0.0754521936, -0.1047515869, 0.1218275130, -0.0071235020, 0.3297888339, 0.0525910780, 0.0518644080, -0.2799700499, -0.0184778217, 0.0738479197, 0.0466704220, -0.1497245580, 0.2479451448, 0.0147310868, -0.0162011571, -0.1755350828, -0.4044192135, 0.0938868076, 0.0237649027, -0.2514870167, -0.0438865386, -0.2354630828, 0.1110799909, -0.2225460857, -0.2392388880, -0.3108070195, -0.1377821714, -0.2784727812, 0.0597711429, -0.0922410563, -0.2095813900, 0.1844735295, 0.0067813853, -0.1309235096, -0.0460272841, 0.1534290463, -0.0947117358, -0.0150092980, -0.0057061780, 0.0982142836, -0.0898989588, 0.0032076966, 0.1018620953, 0.5553856492, -0.1471126676, -0.4687916934, 0.0404030681, -0.0034697738, 0.6797852516, 0.1117596701, 0.1106196791, -0.2994078398, -0.0455690622, 0.1080309823, -0.1356651336, 0.0832067132, 0.0258166250, 0.0495188795, 0.0597585067, -0.1431902051, 0.1787160784, 0.0019335864, 0.0281910431, 0.2167592198, 0.1285673529, -0.0221575629, -0.4668909311, 0.3243706226, -0.1048222706, -0.1492729336, -0.0322042517, 0.2694549263, 0.0690861121, 0.3747838438, -0.1151640937, 0.0979490876, -0.0358409993, 0.1419209093, -0.1561211795, 0.5910139680, 0.0299955457, -0.5165449381, 0.0918498039, -0.0690647736, -0.1698023230, -0.0999972746, -0.0668705180, 0.2389472723, -0.0768352002, 0.0101520559, 0.1588669717, 0.1574739367, -0.1288756728, -0.7926501036, 0.2656875849, 0.2546508610, -0.1064813957, 0.1021404564, 0.0243366770, 0.0105810855, -0.0433269888, -0.1137750074, 0.1451177895, 0.0276601035, -0.0599664450, 0.1667837352, 0.1048219651, 0.1229683459, -0.0863109007, 0.0987465009, 0.0468746908, -0.1416348815, -0.1091856435, -0.3318021595, -0.0075241029, 0.0051095998, -0.2511425316, -0.2087564915, -0.0204338487, 0.2402324826, -0.0054172282, -0.0042232573, 0.1377875507, 0.0422859751, 0.0707920864, -0.0657418072, 0.0287206527, -0.0949194506, 0.1507508755, -0.2099032998, -0.0249021556, -0.1028160974, -0.1711391658, -0.0986436382, -0.0026537704, 0.1030992642, -0.3198608458, 0.1266535074, 0.0651080981, -0.0499370582, -0.3696941137, -0.2241944969, 0.0714350045, -0.0343276188, 0.9714324474, -0.0944504067, -0.2925304472, -0.1195307598, 0.0977786854, -0.6342631578, 0.0247732196, -0.1277551949, -0.1135356128, 0.4014112949, -1.2659235001, -0.0712015629, -0.0410766453, -0.1121619418, -0.1214528903, -0.1336836666, -0.1055395156, 0.1549244672, 0.0246759728, 0.0344699919, -0.1302273571, -0.0381638519, 0.0865980014, 0.0943534672, -0.1316056401, -0.0801985189, -0.1147995815, -0.0701623857, -0.0930544212, 0.1424525380, 0.0276962612, 0.0246213581, -0.8833210468, -0.6517708898, 0.0803051442, -0.0882629454, -0.2769138217, 0.3064922988, 0.2111961842, -0.2709085047, 0.0504694507, -0.1302877665, 0.0793400183, 0.3276806772, 0.0804120749, -0.2464213967, -0.0962018445, -0.0629294738, -0.0205130298, -0.4562732875, -0.1751615405, -0.0306622740, -0.0958412215, 0.1163588241, 0.1257155091, -0.2645202279, -0.4916852415, 0.3336741626, -0.1047595814, 0.1117354557, -0.1063800231, -0.1220822260, 0.1480060667, 0.2331919819, -0.0681614652, 0.1312190294, 0.0661588684, -0.1357665658, -0.2938918173, 0.2439200729, 0.0875801146, -0.1066866741, 0.0080769500, -0.0709582344, -0.5508871675, -0.4446369410, 0.0441129059, -0.8768830895, 0.7101219296, 0.2150569707, -0.1241942793, -0.0540309325, 0.0393692739, 0.1673283726, 0.2659938335, -0.1232672930, -0.0527103730, 0.1605912447, -0.0131810308, -0.1579516977, 0.1340838373, 0.0555277057, -0.0151818264, 0.0546429828, 0.2986063659, 0.0239732563, 0.1123238504, -0.3519095182, 0.0298094898, -0.0608393773, -0.1434035748, -0.0559297167, -0.2435938120, 0.1939117312, -0.0347327366, -0.0565310717, -1.6922770739, -0.2412327677, 0.0420625322, -0.0171054974, 0.0428122655, -0.1291349381, -0.1062146425, 0.1053473949, 0.1059630811, 0.0698243827, 0.2916724086, -0.1630714387, -0.1275831908, 0.1857918352, -0.0194282271, 0.0652299151, -0.0826783031, 0.0309837013, -0.2615532875, 0.3193428218, -0.0489051938, -0.1827238649, 0.2173872292, 0.2236161083, 0.3511594534, -0.1083856747, -0.1635813415, -0.2369297445, 0.1022303700, -0.1344300508, 0.0217735488, -0.3171361387, -0.6599556208, -0.2234766036, 0.1440745443, -0.0465140641, -0.1703894138, -0.1694467664, 0.0806742162, 0.0572450384, -0.1075343937, -0.1099166870, -0.0353698991, -0.1379893869, -0.1076749414, 0.0474643670, 0.0565289035, -0.1858988702, -0.0654070601, -0.3332476914, -0.1678368598, -0.8677903414, -0.0614166670, -0.0611997209, -0.2527761459, -0.2060638964, 0.0950301215, -0.3072052896, -0.3338052034, -0.2014472634, 0.6338900924, 0.0553553253, 0.1124048531, -0.0815085694, -0.2331867218, -0.1211795285, -0.2092509121, -0.0550736897, -0.0517360792, -0.0403820202, 0.0568359420, -0.2314310670, 0.0683823526, 0.3247141540, -0.0448837914, 0.0673059002, 0.1446125656, 0.2931083739, -0.2103240341, 0.7260754704, -0.0742481053, -0.0024174976, 0.1386735439, 0.0010006771, 0.0857978091, 0.9541946054, 0.0236693714, -0.7966378927, 0.0907586589, 0.0935233459, 0.2122195661, 0.1411935836, 0.0092901327, -0.0696238577, 0.0499970354, -0.0050441343, 0.1943192184, -0.1195065379, -0.1285687238, 0.5303764343, -0.6579638124, 0.0588466078, 0.1618570536, -0.0308780316, 0.0717251599, -0.2501392066, -0.4471656680, 0.0070348126, 0.1388595253, -0.1439150125, 0.0356790423, 0.0791706592, 0.0958476439, -0.0681105107, 0.1281806231, -0.0656611472, 0.0061148894, -0.1053540632, 0.1392600536, -0.1279314309, -0.0310638100, 0.0238419287, 0.2462597638, -0.0101129618, -0.3517640829, -0.1174814403, 0.0250555705, -0.0483908877, -0.6732680202, -0.1095941439, 0.0563469641, -0.0766705424, 0.0419947803, 0.0986642316, 0.1004032195, -0.0508086123, -0.1908485591, -0.1581098437, -0.4590988755, -0.0270947460, 0.0905512199, 0.2064284086, -0.6005119681, -0.1576840878, 0.0089506218, 0.0337136053, 0.2879125774, -0.0195009112, 0.0743111670, -0.2049440593, 0.5714463592, 0.0775949135, -0.2116471976, 0.0588588528, 0.0115056243, -0.8463176489, -0.0358844772, 0.0831802562, -0.1924900115, -0.1199969128, -1.2165554762, -0.1756039560, -0.0106229559, 0.1293233335, -0.1818004400, 0.2462767959, 0.0193404015, -0.2033448517, 0.0052150264, -0.1935323179, 0.0958658159, -0.0554448254, -0.3238513768, -0.0272253379, -0.2261254787, -0.0924343914, -0.1106084809, -0.8128792048, -0.0994771868, -0.1686788201, 0.0635994375, -0.1393313408, -0.4641131163, -0.6099137664, -0.1118273214, 0.3574884534, -0.2989257872, 0.0354564562, 0.3067601919, -0.0013265322, -0.0329807661, -0.1677329689, 0.0422788262, -0.1859070957, 0.0098422430, -0.2746085823, 0.0147171728, -0.1708460450, -0.0391732119, -0.5607247949, 0.0028518569, -0.1252785176, 0.0878078565, -0.1181870028, -0.0113801826, 0.1932798028, -0.0296918377, 0.8330290914, 0.0896686390, -0.0679167807, 0.0194381066, -0.0506707244, -0.0577772595, -0.4163257778, 0.0384558514, 0.2356242239, 0.0956768692, -0.0493679680, 0.2718573213, 0.1241855696, 0.0053414931, -0.0056423489, 0.0772429705, 0.1030416340, 0.1776001453, 0.2019699663, -0.0770599693, -0.0432147719, -0.3289344311, -0.0237771142, 0.1493484229, 0.5791200399, 0.0859424248, -0.3803373575, -0.0558510497, 0.0907430872, 0.0157291964, 0.0291347429, -0.1199901700, 0.0103014093, 0.0621003509, -0.0630635321, -0.0012210108, 0.0881672502, 0.3880787492, -0.0146845151, -0.0361841768, 0.0052638939, -0.0015548319, 0.1113739237, 0.1620816141, -0.0066198884, 0.1232737675, 0.1623100340, 0.0702721030, 0.0581456721, -0.0887756497, -0.2591919005, 0.1407880783, 0.0753018782, 0.1500128359, -0.2204990983, -0.1162040010, -0.1266455650, 0.1430162191, -0.0179565307, -0.1839211732, -0.1226021498, 0.0391503237, -0.1670321077, -0.4035599232, -0.0923952460, -0.0752075315, -0.1292713583, -0.7033739686, 0.0569072329, 0.0050541791, -0.1357628554, -0.3580364585, 0.4760906398, -0.1666237265, -0.0735629946, -0.0645150244, 0.9937188029, 0.0228659380, 0.1105328575, -0.1285785735, -0.3837286234, -0.8816211224, 0.5699111819, -0.0682670176, 0.1096714288, -0.0991884917, -0.0080524283, 0.0834475830, 0.5336601138, 0.0923365206, 0.1523589492, 0.3026889563, 0.0024214548, -0.3282423317, -0.4096329510, 0.1038430855, -0.1974639744, 0.2947373688, -0.9054424763, -0.0293730050, 0.3298859894, -0.0264619719, 0.0366360359, -0.8010169268, 0.0657107979, -0.1386706233, -0.6472190022, -0.2827849090, -0.0394771546, -0.0310130045, -0.0679472908, 0.1722529978, -0.1626511514, -0.2192284912, 0.1322558671, -0.2158325613, 0.1954867691, 0.0804937035, -0.0058331597, 0.0695858598, 0.7533647418, -0.4197049439, -0.2338244766, -0.0846228674, -0.0607744977, -0.1011685282, -0.1616935134, -0.1183867455, 0.1832981855, -0.1597143710, 0.1649056822, -0.1377267540, 0.0272352211, -0.0509053618, 0.0081964917, 0.0987389684, -0.2768089473, -0.1689784080, -0.1341386288, -0.0087318989, -0.1716558933, -0.0666811168, 0.0463591330, -0.1706885248, -0.0705431476, -0.5107080936, 0.1663048714, -0.0829466805, -0.1630481929, -0.3619620502, 0.2865347266, -0.0034972131, -0.1552963704, -0.1613961756, 0.0914576128, 0.6050965190, -0.0736125335, 0.2313745320, 0.0136920605, -0.1041044444, 0.0520387478, -0.0183380786, -0.0761151016, 0.0931763873, 0.1004042923, 0.3156081438, -0.0342256501, 0.0316318721, -0.2895824313, 0.1513413340, -0.0941625088, -0.4198682904, -0.0784634948, 0.0757048354, 0.3083390296, -0.0046765292, -0.0314335525, -0.0130071593, 0.0113478210, -0.0684242547, 0.0109673813, 0.1722873896, 0.1085792184, -0.0252215043, 0.0158384796, -0.1101901233, 0.1238844544, 0.1350354105, -0.2557668090, 0.0706014261, 0.0193955600, 0.3653030396, -0.0126027344, 0.0794155821, 0.1346761286, 0.0731090307, 0.0344499461, -0.1299802959, 0.0335726738, 0.4096876085, 0.0457448550, -0.1533865035, -0.2866734564, -0.0584838316, -0.1060294211, -0.0800279602, 0.2133823633, 0.2308925092, 0.0910686702, 1.1634160280, 0.3563371599, -0.0122454772, -0.1277353615, 0.1195526868, -0.2648774385, -0.1247222573, -0.4626465440, -0.1597400904, 0.0940043479, 0.2856673598, -0.0468858629, -0.1668829322, 0.3239028156, 0.0826457366, 0.0532487072, -0.0740026757, -0.4690373242, 0.0867635235, 0.9434462190, -0.1256787628, 0.1208978072, -0.5772674084, -0.2724950910, -0.0125275236, -0.1352196634, -0.4116527438, 0.1203459203, 0.1873342097, -0.1507555246, -0.1215892583, 0.0955277234, -0.1797950864, -0.1939298362, 0.2563586533, -0.0078032645, -0.0250921082, 0.1052271053, 0.0689235926, -0.0127732949, -0.1816077083, 0.1016437039, -0.1424537599, -0.1703998148, -0.1373907775, 0.0199673567, 0.4875511527, 0.4360651970, 0.1470840126, -0.0293134693, -0.0377781242, -0.0832094550, 0.0914692506, 0.3738859594, 0.1612245440, 0.0565156378, 0.1293158233, 0.1372667700, 0.1491365284, -0.0152054457, -0.0710710660, 0.0503658392, -0.2456686497, -0.2348377854, 0.2464852184, -0.3864526749, 0.1280059367, 0.0453578010, 0.4304322004, -0.0686840713, 0.1469394714, 0.1401079297, -0.0986389890, -0.0829129070, -0.6000142097, -0.1239176914, -0.2163182795, 0.0350967385, 0.1351881772, -0.1640633196, -0.0568403937, -0.0656826422, -0.0618692823, -0.1828726530, 0.0843724161, -0.1184666231, -0.0525830165, -0.2493041605, -0.0910946056, 0.0652731135, -0.3499534130, 0.0851499140, -0.0792119950, -0.6510460377, -0.2208676189, -0.0896715447, 0.0781900063, -0.1811827421, -0.1006860286, -0.0927925631, -0.3093233407, -0.1127538756, -0.1418964416, -0.0390197337, 0.0544565842, -0.0865403563, -0.2371725142, 0.0542880185, 0.1447561532, -0.0048580454, -0.1714002341, -0.1735369563, 0.0557320006, -0.0203294475, 0.4335470796, 0.0384879559, 0.1034743115, -0.1077390164, -0.0899662003, 0.6807796955, 0.2626636624, -0.2370994985, 0.1024330109, -0.2561370432, 0.0461529382, -0.3080152273, -0.0954902321, -0.0625622123, -0.3324337900, 0.4320641756, -0.0836631581, 0.1146090254, -0.2101294845, -0.2231251746, 0.0154319145, 0.5446705222, -0.0806260929, 0.0113801453, 0.0068371794, -0.0116983047, -0.0704371333, -0.3337496519, -0.0585263297, -0.1133373529, 0.2613342404, -0.5249632001, 0.0575556085, 0.1537616849, -0.0055146646, 0.1408222467, -0.5772004128, 0.6449649930, -0.0405259021, 0.0547752343, -0.1503887475, -0.1882177144, -0.0010337034, -0.0093711987, -0.0678198636, -0.1211529449, 0.0766570717, -0.2913475037, -0.0714447200, -0.0411552936, 0.1304068118, 0.0792865604, -0.0827021971, -0.3696633279, -0.3083766997, 0.2179131359, -0.0522978976, 0.1317443103, -0.1115655452, 0.0106912106, 0.1006275788, 0.2766603529, 0.0297963936, -0.1012827903, 0.1218217760, -0.1150723696, -0.0264192726, -0.0530157983, 0.1661003381, 0.6176974773, -0.0649953038, 0.0427964851, -0.1230696067, -0.0553135313, 0.1045434251, -0.0204000361, -0.1861194670, -0.1678765416, -0.2264991403, -0.2046502680, -0.1569771171, 0.1227880865, 0.3197593391, -0.0974060521, -0.0747970641, 0.4042723179, 0.1129009202, 0.1109664440, 0.2212652564, -0.0674462989, 0.0902663693, -0.1277872026, -0.0246474296, 0.1787642241, -0.0446542278, -0.0272538457, -0.1349483132, -0.0837693587, 0.1440199912, -0.1514360607, 0.0142449550, -0.2290018648, 0.0752714723, -0.1448949277, -0.3292123675, -0.1456356496, -0.0668486059, -0.0533466041, 0.1392843425, -0.0211515427, 0.4132491648, 0.0525066890, 0.1109737083, 0.0363234207, -0.2063139528, 0.1012326255, 0.1149065122, -0.0693480149, -0.0577472262, 0.1203988567, -0.1687550992, 0.1259454638, -0.0562448762, 0.4862677753, -0.3256070018, -0.1813088655, -0.1315054446, 0.0402464159, 0.3910948634, -0.4316077828, 0.0382026732, -0.1629233062, -0.6254321933, -0.2719094753, -0.0633905455, 0.2398188114, -0.0584890284, -0.1325661391, 0.1515981704, -0.0788568407, 0.0667194575, -0.0393969342, -0.4117858112, 0.5306024551, -0.1142633110, -0.0081461146, 0.0268500894, -0.1243828535, -0.1036423966, 0.2860614955, -0.0540753417, -0.1795822680, -0.0058410731, -0.0975573584, -0.2889863849, -0.5284249783, 0.0367953666, -0.0175204072, 0.2797519267, 0.7659190297, -0.0614333972, -0.9443351626, 0.0165246204, 0.0548555888, -0.3564137518, 0.6660047770, 0.1241098195, -0.4083279967, -0.2064756751, 0.1179372817, 0.2910253406, 0.0916831866, -0.1217219234, -0.1234524697, -0.1060235947, 0.1539983898, -0.1560886800, -0.1579877883, -0.0308328960, 0.0723785162, 0.0831083432, -0.3592476547, 0.3144415617, -0.4181238711, 0.1408554018, -0.0170983132, -0.0762872547, 0.4293499887, -0.3180189729, 0.0883879587, -0.1664821953, -0.0246742312, -0.1539313942, 0.0501524024, -0.0036087816, 0.2570627928, 0.0026685719, -0.4824767411, 0.0487498492, 0.0163827837, 0.1867996305, 0.0804717839, 0.0235643759, -0.0791465342, -0.1077671796, 0.0215173010, 0.0440416932, 0.9111773968, 0.1471268982, 0.8736129999, -0.4274263084, -0.0526525751, -0.0680961907, -0.0137266470, 0.0415117741, -0.2609993815, -0.2968908250, -0.0477343835, -0.3140079677, 0.0661720261, 0.0391616076, -0.1313017011, 0.0866296589, -0.1571062207, -0.0644617081, -0.1001185030, 0.2515964210, -0.0395660698, -0.0801108778, 0.0724153668, -0.0414855629, 0.0565789193, 0.0039228392, 0.0593217947, -0.0078556510, -0.4784294367, 0.0556526072, 0.1367378980, -0.5644645691, -0.2621398866, 0.0259541459, -0.1198614463, -0.3196029961, 0.0430507548, 0.0642147586, -0.1386325210, -0.0368866324, -0.0745962262, 0.3232382834, 0.0194445681, -0.0898357183, -0.0154150836, -0.2332608104, 0.0739466771, 0.0843414590, 0.0048382776, 0.8051996827, 0.1052121297, -0.1475003213, -0.0438416786, -0.1857861876, -0.6128110290, 0.5679569244, -0.1801648885, -0.0444268957, -0.5512618423, -0.1061804444, 0.2071229666, -0.3131560683, -0.3102413416, 0.4278918803, -0.0665601864, -0.1399948150, -0.0862419456, 0.1536568403, -0.2431146950, -0.1538823247, -0.2808176577, -0.0100214332, -0.0575903952, 0.0801129341, -0.1851888597, -0.1537427008, -0.2012940049, -0.2451593429, -0.0919105858, 0.1650124937, 0.0101811634, 0.0243147090, -0.1168709025, 0.0168666337, -0.0864167884, 0.1663195938, 0.6095266342, 0.1311186701, -0.8579701781, -0.4055008292, -0.2193077803, -0.3146001995, -0.0478536300, -0.0279720277, 0.0623045526, -0.1800257564, -0.3728910685, -0.1530207843, -0.2653888166, -0.0694512427, 0.4576279819, -0.0156506635, 0.4594960809, 0.1949717253, 0.2236105800, -0.0991841108, -0.1624482870, -0.1602195203, -0.0069308178, 0.2305744141, -0.2838537991, 0.0835515186, -0.0297802947, 0.0504221618, 0.0217417739, 0.0944605395, -0.1934279203, 0.1406470686, 0.0293076225, -0.1304923892, -0.1609119475, 0.0263905842, 0.1643196195, -0.1414597183, -0.0608391687, 0.1674462855, -0.0970986560, -0.0547725074, 0.0648573786, -0.1013584957, -0.1724603921, 0.1546990275, 0.2805287242, 0.0815626383, -0.2837715149, 0.1332704127, -0.2344065607, 0.3809783757, 0.0877017751, -0.3413722515, 0.0468237549, 0.0578411669, -0.0102143763, -0.0216270369, -0.2304592878, -0.1813778877, 0.0181977749, -0.0250768047, -0.1655612886, 0.0747325122, -0.0839855522, -0.1482629478, 0.1347691417, -0.0582117401, 0.1159171537, -0.0622529462, 0.3928191662, -0.0954673514, -0.0444562361, -0.0999901891, -0.2857933342, -0.0640147701, -0.0018999521, -0.0140446573, 0.0047440478, 0.1031569317, -0.0682886243, 0.0110428864, 0.0291118380, -0.3800925016, -0.2240531743, -0.0928689390, 0.2804699540, -0.1419674903, 0.0592818148, -0.1819224656, -0.0255855173, -0.1413740665, -0.1503048092, -0.1743766665, 0.0379455648, -0.5150995255, -0.3628387749, -0.3077610731, 0.1579756886, -0.1704491675, 0.0946341380, 0.0617987365, 0.0555795059, -0.1840587854, 0.3106885552, -0.2736901343, 0.2556333542, -0.0596758276, -0.0788943395, -0.0256154221, -0.1188208312, -0.0081403377, 0.0194844846, -0.0578088909, -0.0432051569, -0.1162700504, -0.0577343963, -0.3539323807, -0.2359152883, -0.0863149837, -0.0140334498, -0.0980150849, 0.2655842602, 0.0555638820, 0.2613128126, -0.1118981019, 0.0117513491, -0.1776373684, 0.3141837418, 0.0233213678, -0.5521657467, -0.1996373385, 0.1727590412, -0.1112861484, -0.0295338780, -0.0072552757, -0.0918180719, -0.2667877376, -0.0266388264, -0.1518772095, 0.0159969758, 0.0539126694, 0.3216770887, 0.0839358121, -0.7747969031, 0.1544643939, -0.3671223521, -0.0524004810, -0.0217791051, 0.0382726602, -0.6149613261, 0.1037624702, -0.3718919158, 0.0035263931, 0.1145033613, -0.1663871557, 0.0201925822, 0.0381907076, 0.2918816507, 0.1836932153, -0.0310719013, 0.0791325346, -0.0646610260, -0.0409148969, -0.2160297781, -0.1635061055, 0.1187326312, -0.1405914426, -0.3260308504, 0.4362864196, 0.1249938905, -0.1271558553, -0.0412862450, 0.7581850886, 0.1872338504, -0.1349188387, 0.8016967773, 0.1233030856, -0.1810422689, -0.7218173146, 0.0306027699, -0.6201732755, -0.1169990376, -0.0242589712, -0.0132979825, -0.0613043346, -0.0349357501, 0.1559939533, 0.1094309166, 0.2154317796, -0.1126224324, -0.0955320075, -0.0293123610, -0.0326859355, -0.0166477077, -0.1212903634, 0.1162034571, 0.0065753283, -0.3372600377, 0.1950104535, -0.0918470249, -0.3406627476, -0.2900450230, 0.0499786250, 0.0202386547, -0.0561079830, -0.1343047023, 0.0470263585, 0.0654590949, 0.0086465878, -0.0925771445, 0.1308640093, -0.0325893015, 0.0894047469, 0.5750156641, 0.2022283077, -0.1340157539, -0.0709724501, -0.0352706015, 0.0780730695, -0.0955911875, 0.0133976582, -0.0249824468, 0.1760716587, -0.7776514292, 0.0001549267, 0.0980741754, -0.0808491334, 0.3620476127, -0.0720259026, -0.1905553639, -0.2369816750, -0.1837585270, 0.3378463387, -0.0443770364, -0.0633081645, -0.0338703506, 0.0043276004, -0.1034742668, 0.1319418252, -0.2299212217, -0.1501699239, 0.1362552643, -0.5821815729, -0.1057604700, 0.1195841059, 0.0900923088, 0.1568674743, -0.1110768244, -0.1042843238, -0.0653932691, -0.0582044683, 0.5120013356, 0.0380559191, 0.0625509322, -0.5506801009, 0.5745055079, -0.0734316930, -0.9514635801, -0.1768169850, 0.1807134598, -0.0518012308, 0.0679061264, 0.1151770130, 0.0808607712, -0.2453258187, 0.0076097986, -0.1742179096, 0.1455819607, 0.1134250015, 0.0124744056, 0.0992955491, -0.3463986218, 0.0828339159, -0.3781036437, 0.1466999948, 0.0074975141, 0.0560943186, -0.7376664281, -0.0810201019, -0.3769545257, -0.0553078242, 0.0347572900, -0.0502922088, -0.1620296985, -0.1256908774, 0.3200925887, 0.2606909573, 0.3912844360, -0.1543997824, -0.0569668822, 0.3787980080, 0.2348546535, -0.0076163174, 0.0937610269, -0.0761079192, -0.2636692226, -0.2244099379, -0.0909478664, -0.0948469862, -1.4173058271, 0.5896953940, 0.3160026670, -0.1291847527, -0.2399287522, -0.1963316649, 0.5990455151, -0.5247818232, 0.0831404179, 0.0257880148, -0.1932048053, 0.1233379096, -0.1222633272, -0.1620452851, 0.0879708007, 0.0394703634, 0.1130241230, -0.0722422972, -0.0350091718, 0.0092417141, -0.2212072760, -0.0269438922, -0.1068827435, -0.2172310352, -0.1507944316, 0.1852806658, 0.3142595589, -0.2379631847, -0.0518276095, -0.1289981604, -0.1602747291, -0.1163880304, -0.1763820797, -0.1412863433, -0.1328293383, -0.1564141661, 0.0367989764, -0.1767425239, -0.0160912722, 0.0782124624, 0.0317719132, 0.0024936667, 0.5373571515, 0.3967764676, -0.1697417051, -0.1856101006, 0.0424316823, -0.3252029121, -0.1034447923, -0.1384594291, -0.1186696216, -0.1505285501, -0.0537448265, 0.4340732992, 0.1686999351, 0.1149418876, -0.1750837266, -0.1184678823, -0.2611562610, -0.0707761571, -0.4822603762, -0.5093967915, 0.0509753376, -0.0636064634, -0.1728760749, -0.0545288846, -0.4236333966, -0.0346326157, -0.1432059109, -0.1434691101, 0.1858612597, 0.0323087573, -0.1193962544, -0.1596339792, 0.4594008923, -0.0664482340, 0.1113247424, -0.3908175528, -0.2867127657, -0.1757689118, -0.4796376824, 0.0874101818, 0.1092639714, -0.2331544757, 0.1576691866, 0.0064179269, -0.4835715890, 0.5884068012, 0.2464575917, 0.1371380091, 0.2105997950, 0.0489732586, -0.0036442382, -0.1982548982, 0.2750986516, -0.2173841894, 0.0934442356, -0.0025693080, 0.2655523121, -0.0607317351, 0.0401763655, 0.4039124846, 0.5190670490, -0.1230649203, 0.0007633063, -0.0664941519, -0.1333469898, 0.0544685312, 1.0584982634, 0.0951288268, 0.1581042558, 0.1458624005, -0.1020416990, -0.1399252415, -0.2504190803, 0.0920688584, 0.4996201098, 0.0743176490, 0.0505049005, 0.5440704823, 0.1378248036, -0.1985916793, 0.0241168756, 0.0169624668, -0.2358033210, -0.6293313503, 0.0160579067, -0.0832001120, -0.3973107040, -0.4853109419, -0.0159284770, 0.0053915977, 0.2515772283, -0.0989831537, 0.1377782524, 0.5488590598, -0.0657962114, 0.0183773395, -0.0873693749, 0.1274308115, 0.0199972428, 0.0160348229, -0.1300160140, 0.0002378954, 0.0111186048, -0.0564124435, -0.0839375705, -0.1022890061, -0.1569701135, -0.1603857428, -0.1369466931, -0.2764515579, -0.1063040346, 0.2678944468, 0.5881974697, -0.3401559591, 0.1487222463, 0.0858732611, -0.2580130696, -0.1672795713, 0.0693772733, -0.0901967213, 0.1195115000, 0.1084892377, -0.0370746739, -0.0030955027, -0.1404292285, -0.4051230550, -0.2288067192, -0.1878700703, 0.6912569404, -0.0737641156, 0.0956897587, -0.0582944155, 0.0813734308, 0.2401803285, -0.2300487906, -0.1908835322, -0.1391763985, -0.6305943727, -0.1381764114, 0.3769454658, -0.0043163025, -0.0423857868, 0.0410707258, -0.0402861685, -0.1932181269, 0.1806734204, -0.2515477836, -0.3772415817, 0.0216352623, -0.0212533940, 0.0663428903, 0.0524992459, -0.3368716240, -0.0639848039, 0.1295094341, 0.0054154694, 0.0459820889, -0.1125859320, 0.0884647667, -0.2783507109, 0.0553845800, -0.3332235813, 0.0942221358, -0.7112715244, -0.0003517373, 0.1150147691, -0.3980237544, 0.0404640436, 0.1218000799, 0.5477746129, 0.4288274050, 0.0673211664, -0.1776698530, 0.4938513339, 0.7533314228, 0.0330815166, -0.2623033226, -0.0202756133, -0.1641335189, -0.1560657471, 0.3181387186, -0.2955275178, -0.0933415592, -0.1175076813, -0.0093637286, -0.0277706459, 0.1294829100, 0.2427955270, -0.6213232279, 0.0796116218, 0.0000519417, -0.0162735805, -0.5205148458, -0.7818320394, 0.4963590205, 0.0310228765, 0.1099852249, -0.1027362272, -0.1007356495, -0.1072769538, 0.1018890664, 0.1958569139, -0.2941882014, -0.1557529271, 0.0881982893, 0.2907024622, 0.2648783922, -0.1396503150, -0.0683730096, 0.1065147072, 0.1036914662, 0.0546580404, -0.1212786362, 0.0102123953, -0.5669700503, 0.4999488294, 0.4266095161, 0.0524831861, -0.1866368651, -0.0382398181, 0.0143921468, -0.6681632400, 0.0255593061, 0.4443190396, 0.0389090888, -0.0238491148, 0.0911857113, -0.1109175980, 0.0575072020, 0.0536199845, 0.0856035873, -0.1481851935, -0.0215714611, -0.2379110008, -0.0566761270, -0.1135779768, -0.0208452810, -0.1119524166, 0.1283547133, 0.1744874716, -0.2927553356, -0.3129307330, 0.0994464308, 0.0699648857, -0.1362083107, -0.0787341595, -0.0984520987, -0.7849974632, 0.1461439431, -0.0672241971, 0.0239479095, 0.1151368394, -0.0232919604, -0.2799401283, -0.2811203003, 0.1133417562, 0.8291997910, 0.0993325487, 0.0430340059, 0.0448639505, -0.0776362866, -0.2534770072, 0.1972218156, -0.1054719388, 0.1457625628, -0.2287195027, -0.4871972501, 0.3545584977, 0.3201717138, 0.1047293022, 0.4163514376, -0.1370936036, -0.1504232883, 0.0577391237, -0.2015658170, 0.4062773585, -0.0751289651, -0.0734462291, 0.0958662257, 0.1961759478, -0.1848833263, 0.0455942564, 0.3246032298, -0.0709523186, -0.0349079557, 0.2802279592, -0.0130407568, 0.1530963182, 0.4109923542, -0.4176470637, -0.0374241173, -0.3525583446, 0.3373186886, -0.2267765105, -0.6336801052, -0.0688285455, -0.1740830839, -0.0598225296, -0.0631699190, -0.0939263776, 0.4492404163, 0.5027352571, 0.3844857216, 0.0262469016, 0.0866927952, -0.0734761655, -0.1634280235, -0.0458449572, 0.1506486982, -0.4446481168, -0.0021787903, -0.0886647478, 0.0803434253, -0.1109420359, -0.1632216424, 0.7211352587, 0.0427579843, 0.1025832072, -0.1539274454, 0.0580298826, -0.4535517395, -0.7247343659, -0.5734096169, 0.0009774519, -0.1110575795, -0.0412756503, -0.2181199491, 0.0104253078, -0.1315229237, 0.0789762735, -0.1122763604, 0.0505048074, 0.0675894544, 0.6542587876, 0.4674832821, 0.1028567404, -0.1796808839, -0.1080567315, 0.0784327313, 0.4594371915, -0.3382638693, 0.0950584933, -0.3552402854, -0.5624037981, 0.0607469529, -0.0836836696, -0.8832908273, -0.1355427206, 0.1157034263, 0.8280171752, -0.1428413391, 0.7377431989, 0.0035773641, -0.0889381170, -0.0887930915, -0.0146932611, 0.0435604900, 0.0385281369, -0.0550809242, -0.5255678296, -0.0027868669, 0.1079491302, -0.8397071362, -0.0842166319, -0.0923033655, 0.0267486051, -0.1008271277, 0.0984099433, 0.3710978627, -0.2094938457, -0.0776563883, 0.5562257767, 0.0025448014, 0.0110071199, -0.1177843958, -0.4196784496, -0.1550435126, 0.1336935312, -0.1734262109, -0.1128572449, -0.1349682659, -0.4367724359, -0.0055409838, 0.0404257104, 0.6063178778, 0.4261524379, 0.0815983713, 0.0411402956, 0.0213898942, -0.2482161820, -0.1146208718, 0.0929490849, 0.0691512749, -0.3813790381, 0.2122494727, 0.2121391445, 0.3815956712, -0.1349255890, 0.1417012215, -0.2676978409, -0.2609106600, 0.0649145991, 0.0628310516, 0.5129873753, -0.0084660500, -0.1630266160, 0.0523662157, -0.1586845219, 0.2108576596, 0.0606037639, 0.0771741346, -0.0036687437, -0.0553810522, 0.0134125967, 0.0273911376, -0.3314583004, 0.1569806486, -0.2346531600, 0.0723161623, -0.6750435233, -0.2300484776, 0.0500459597, -0.0147488331, 0.0539761633, -0.1584068239, 0.6881238818, 0.4222011864, -0.0493647419, 0.5169439316, 0.6656967998, 0.0311493184, 0.0862188637, -0.0645368323, 0.0005606882, -0.0184587464, 0.2447417825, 0.4952083230, -0.2814630866, -0.0333828777, -0.0862803608, 0.3090250790, -0.1799230278, -0.3299279213, 0.1137605831, -0.4077893198, -0.0451070778, -0.0270602573, -0.0051380079, -0.6844118834, -0.8450823426, -0.3863243461, -0.0149900215, 0.0184069276, -0.1197331622, -0.0854606554, -0.0788114518, 0.5945689678, 0.0232672300, -0.1902841777, -0.0645700097, -0.1569254249, 0.3956178129, 0.5008267164, -0.1553232670, -0.2249511182, 0.1933924705, 0.2340696007, -0.6244489551, 0.0832864940, -0.0488691889, -0.0462918766, -0.9037032723, -0.3782798052, 0.0032349825, 0.0565809198, -0.1553994268, -0.0597236902, -0.4298264682, 0.0339479595, 0.7242501378, -0.1573657990, -0.0721796229, -0.0930216014, 0.0317506082, -0.0154265072, -0.1465454400, 0.0657180473, 0.3447743952, 0.0482164696, -0.0949133113, -0.5087132454, -0.0854372308, -0.1344036311, 0.2948785424, -0.0127083547, 0.1130094975, -0.3932494223, -0.0635820627, 0.0603674054, -0.3135376573, 0.2338799536, -0.1430653930, -0.1455555707, -0.3780106306, -0.1505679041, 0.0819614008, -0.0300881881, -0.0735885426, -0.1242325455, -0.5406109691, -0.1525425613, 0.0364133157, 0.5041021109, -0.0188596919, -0.1163776219, 0.0223616157, 0.1323255748, -0.1711520851, -0.0614145398, -0.0848779976, -0.1143830717, -0.2829057276, 0.0072361394, 0.3324207664, 0.2695020139, 0.0208874438, 0.6490362883, -0.1608240455, -0.0454132855, -0.1896251589, -0.0419194810, -0.0766081885, -0.1115789264, 0.0965862423, -0.1341630071, 0.1390435547, 0.4775146246, 0.1508964300, -0.2428240031, 0.0974411666, -0.0458753183, 0.5406395197, 0.1203464568, -0.2854733169, 0.3520759642, -0.4036028981, 0.1330644041, -0.1744987816, -0.2271059602, 0.1113684252, 0.2343611270, -0.1178027466, 0.0284551121, 0.4354281127, -0.3809100688, 0.0557926409, 0.5085004568, 0.2250220478, -0.2114763856, -0.5344561338, -0.1114149615, -0.1777895093, 0.1034928784, 0.3458947241, -0.1169795468, -0.5014393330, -0.1791165173, 0.0905761346, 0.0781248882, 0.1051291227, 0.1001265943, 0.3412810266, -0.4608426094, -0.1203773692, 0.0653716698, -0.1474415809, -0.6101507545, -0.1842871904, -0.6944806576, 0.1150091887, -0.0507229380, 0.1536684632, 0.1237977073, -0.0543327332, -0.7191137671, 0.1554438323, -0.1029528975, 0.1495773792, 0.0586525537, 0.5362440944, 0.7439152002, 0.1273996234, 0.0914318562, -0.0687484890, 0.1640553474, -0.2873738110, -0.4258798063, -0.1695398688, 0.1063079759, 0.4414551556, -0.0619651154, 0.0690269768, 0.3333308101, -0.0069682151, -0.0289425664, -0.3536796868, 0.0532072894, 0.5978562236, 0.1043678671, -0.1596353799, -0.1995787174, -0.0910053998, 0.0401057340, 0.0744497105, -0.1694756299, -0.2584851682, -0.0602471195, 0.1000113040, 0.2742499113, -0.0930397287, 0.1180648133, 0.5861646533, 0.1172043607, 0.0764502734, -0.3429391086, -0.3254679739, -0.1483377218, -0.1205241084, 0.2974589169, -0.0682375655, -0.0651208758, -0.0028345729, 0.1269064248, -0.1530251652, -0.1714812517, -0.0105694467, 0.1245465204, -0.1646366864, 0.0209517926, 0.0938050747, 0.4177323282, 0.3712267876, 0.1368407607, 0.0852052718, 0.1087992713, -0.3035930693, -0.2195435613, -0.1303548515, -0.0473721325, -0.0602478683, 0.1534656733, 0.3946182728, 0.5355710387, -0.1244408339, -0.1448584050, 0.0257996190, -0.4088352025, 0.0522357076, 0.2755430341, -0.4721991420, -0.7732501030, -0.1696129292, -0.1554933786, -0.0130047407, 0.5380817652, -0.0061987406, -0.3412085772, -0.1061754599, -0.0802659765, 0.6233159304, 0.0780742615, -0.1097710058, 0.1755850464, -0.0926425233, -0.1266421378, -0.0022751947, 0.1672661006, 0.1466528177, -0.3521676958, -0.1341709644, 0.1047191322, 0.3316508234, -0.1807311773, -0.1518859714, 0.9257156253, -0.4730494916, -0.1919157505, -0.0404844731, -0.0457289591, -0.0126978336, 0.0444356911, 0.2265942842, -0.1556845903, -0.1481468230, -0.2040572762, -0.0958516225, 0.0887303352, 0.0875504091, 0.2948393226, -0.2199806571, -0.4887045026, 0.0711137429, 0.0503580309, -0.0219791122, -0.1410921216, -0.1024207845, 0.0954940617, 0.0386015512, -0.2242567390, 0.1514030695, -0.2484537065, -0.0495627411, -0.3323490322, 0.0021117367, -0.7420976758, 0.1280678362, 0.1174429059, 0.4345672727, 0.4882151484, 0.0947469845, -0.1202619225, -0.0368949361, 0.1791861504, -0.4514397085, -0.0466674566, -0.0308401622, -0.1173085123, 0.1143378094, -0.0624281392, 0.0463906527, -0.4115480781, -0.1233674139, -0.0007717597, -0.1772426218, -0.1668049544, -0.3988419771, -0.1219647899, -0.0425689742, 0.0856432989, 0.0491616353, -0.0365589522, -0.0291501600, 0.0109353261, -0.2563130856, -0.1236137301, -0.1436124891, -0.5017672777, -0.0919630155, -0.0624662302, 0.7493152618, -0.2056611031, -0.1039239466, -0.3034408987, -0.4389153421, -0.0323061049, -0.4197424650, 0.2722605765, -0.0800999850, -0.1535476744, 0.4313281476, 0.0733878091, -0.1966983378, -0.1379875690, 0.1244315207, 0.0936170816, 0.0394900851, 0.2361608446, -0.0918489993, 0.0573396757, 0.6014461517, 0.0317568965, -0.0362384096, -0.0764109716, -1.0430496931, -0.2024355829, 0.1250023097, -0.1519876271, 0.9300237894, 0.2588520348, -0.2355135083, 0.5305995345, 0.0738882273, 0.1795169264, -0.0148716560, -0.0025328109, -0.1901757717, 0.2791174352, 0.2940962315, -0.5993918180, 0.0282227155, 0.1107129529, -0.1499272883, 0.4429829121, -0.1257444173, -0.3372477591, -0.0812993422, -0.1820038259, 0.8210754991, -0.1456573606, -0.3877902329, -0.2787783146, 0.1262367219, -0.1063978076, -0.0788089633, 0.0195990950, 0.0883561671, -0.5487974882, 0.1144379824, 0.0692873746, 0.2000911981, -0.4394240379, 0.0674321055, 0.4814644158, -0.3043783307, -0.3179049492, -0.4061686397, 0.0885810405, -0.2148669064, 0.0094199553, 0.0076865410, 0.0876633003, -0.1568359286, -0.0649394616, 0.1203734353, -0.0195900854, -0.1372420639, 0.1410036683, -0.1535407007, 0.0712386370, 0.0243444052, -0.0315534025, 0.0211971737, 0.1850253195, 0.3664567471, 0.6846831441, -0.1290084720, -0.1141990647, -0.1597701758, -0.1891851425, -0.1667655557, -0.3567523062, -0.1471274346, -0.1364132762, -0.0962581411, -0.0844333246, 0.1908227950, 0.3041445613, 0.1506958157, 0.0941054001, 0.0993100330, -0.1237009987, -0.6419360042, 0.1604388058, -0.0303933155, -0.6551477313, 0.2106444091, -0.0269926377, -0.0485678688, -0.1157404333, -0.1268668920, 0.3057292700, -0.5839955807, 0.0143890018, 0.0742028803, -0.2037137598, -0.0895255730, -0.2156087905, 0.1450977176, 0.0053117895, -0.0551657975, -0.0662790313, -0.0904823169, 0.0682052895, -0.1686125994, -0.2467237264, -0.0256972760, 0.1566084027, 0.4460583925, -0.1024815142, -0.0882204995, -0.6944305301, -0.2491972297, 0.0247761160, 0.7269858122, 0.0668336451, 0.1449639499, -0.1537944227, 0.6586322784, 0.1024262235, -0.0372874737, 0.0540894084, 0.0611375570, 0.0634225458, 0.5188562870, -0.1055673659, -0.0714766905, -0.2732949555, 0.3291327655, -0.1160912439, -0.0668630451, -0.0984913632, 0.4762846231, -0.1089292988, 0.2467658818, 0.0933033749, 0.4227182567, 0.4499448836, -0.0451277345, 0.0894149020, -0.1863900870, -0.1766386181, -0.1152174920, -0.5332712531, -0.0167599283, -0.0121061616, 0.4229021072, -0.7264031172, 0.0959795490, -0.0438678898, -0.0334153250, 0.6655775309, 0.1694521904, -0.6829059124, 0.0367557220, -0.0550180189, 0.6086426377, -0.0640304387, -0.1949093938, -0.5050076246, 0.2802146971, 0.0043866788, -0.0245020613, 0.4480578601, -0.0700635388, -0.1693640053, -0.0624503605, -0.0907759294, -0.0684404299, -0.1180284023, -0.0379758589, 0.2217430025, -0.6525115371, -0.5882822275, 0.3588533700, -0.1627857387, 0.1212051660, -0.1178897545, -0.1931165457, 0.1936560273, -0.4580205679, -0.1411833614, -0.0681166053, 0.2730380595, 0.0343631245, 0.9598974586, -0.2252992690, -0.4151412845, -0.0600943491, -0.1691243649, 0.0468553230, 0.3300270736, 0.3607249260, -0.5518761873, -0.1083231047, -0.0272956733, -0.0004039163, -0.0694938898, -0.1493592262, -0.1995747089, -0.0682035312, -0.1748171300, -0.0472931117, 0.0147690931, 0.0702484995, -0.1045679450, -0.0148877678, 0.2223479450, 0.1222597808, -0.0018747877, -0.2235886455, -0.3040329814, -0.1339630187, -0.0832366645, 0.4117131829, -0.5471143126, 0.0703695565, 0.0419675745, 0.1086956933, 0.2904836237, 0.4461103976, 0.1087217629, -0.6033967137, 0.0216702856, 0.0492081642, -0.0857883468, 0.0865615606, -0.1290113628, -0.0841367617, -0.2052863389, -0.3308443427, 0.1065746248, -0.2036815286, -0.0763106048, -0.0926731527, 0.1193956360, 0.6389521956, -0.0725301802, -0.1003606617, -0.7807231545, -0.1662640721, -0.1453538984, -1.0634003878, -0.0463720672, -0.1310224980, -0.1028614193, 0.2684129179, -0.0782563537, -0.0019994203, 0.0276464149, -0.1179645211, 0.1089282185, 0.6401446462, -0.1315316558, 0.1079224944, -0.5395907164, 0.3465519845, 0.0898655653, -0.0511990488, -0.0913768485, 0.1322709322, 0.4226375222, 0.1600951105, -0.1090493724, 0.0282844473, 0.3538139164, 0.1413465887, -0.0371452011, -0.0477835722, -0.0669550598, 0.1600967944, -0.1128899902, -0.2409887761, 0.2457895428, 0.1459181905, 0.1879766285, -0.0939376131, 0.0411370285, -0.1535895765, 0.4761170745, 0.1289684623, -0.3363654613, -0.0859062523, -0.1498277485, 0.6829657555, 0.0832741410, -0.3608626723, -0.6137860417, -0.0961801261, -0.1937168837, 0.3640572131, -0.0076946849, -0.0396639332, 0.2972581089, 0.0698978379, -0.0907913148, -0.0576830134, 0.2614281774, -0.1429335624, -0.4730676413, -0.0266694091, -0.2899067402, -0.2783215344, 0.0162969362, 0.0628619567, -0.1441773772, -0.0191730652, 0.5014383197, -0.0618077368, -0.2625647485, 0.0891940594, 0.1025342420, -0.1748303175, 0.5853916407, -0.3544462919, 0.0940226614, -0.1742622107, -0.1020723209, -0.0527131781, 0.4837761223, 0.5208348036, 0.0583298951, -0.1126351655, -0.2295167148, -0.0401673764, 0.0134804603, 0.0372033007, -0.4220076501, -0.2025362849, 0.4174367189, -0.1106566936, 0.0272452906, 0.3020762801, -0.3568336666, -0.1646023989, -0.1584165096, 0.0062661278, -0.0402716510, 0.1192630678, -0.2355499268, -0.0767706186, -0.3735545278, 0.5935590267, -0.2982926071, -0.0021869242, -0.7899236083, -0.0973481089, 0.2613395154, -0.0599289872, -0.0113670463, -0.2556153834, -0.1180035993, 0.0184971988, -0.1908464581, 0.2248904109, 0.1469302475, -0.0816799328, 0.0440710448, 0.2094058990, -0.0734343007, -0.0624299273, -0.1417146772, -0.1261313558, -0.1586854905, -0.1144216880, -0.1844721884, -0.0084544187, -0.4173525572, -0.1501342058, 0.0009963512, -0.0226782039, -0.2887816429, 0.0183593072, 0.0115811713, 0.6238412857, -0.0954734907, -0.1360330880, -0.1988661736, -0.1080270633, -0.1359241456, 0.3849178851, -0.0445778258, 0.1408480108, 0.0707252175, 0.3762008548, 0.0796204656, -0.0523463227, 0.1379811466, -0.4190267324, 0.2769895196, -0.0244817138, 0.1061779261, 0.3046275377, 0.2361180782, -0.0944417641, -0.3169544637, 0.0986055285, 0.1888251752, -0.0477852300, -0.3339505792, -0.3432562351, 0.0731797442, 0.4604071677, -0.2791958451, 0.0286470782, -0.0968820080, -0.2326933593, 0.4288504124, -0.0132757500, 0.0060675032, -0.0177218765, -0.0353618227, 0.2670703828, -0.2072848082, -0.0367399082, -0.3383094370, -0.2680046856, -0.1602139473, 0.6360235214, 0.3196920455, -0.0009882390, -0.3455165029, 0.0642544180, -0.0041233203, 0.0447209217, -0.4425178468, -0.0043133404, -0.3691467941, -0.2370135635, -0.3105242252, -0.4551908970, 0.0703281537, -0.2146916538, -0.1137691140, -0.0383661687, 0.3482407331, -0.5417379737, -0.2404731363, -0.1747775525, 0.3354946971, -0.0882489309, -0.5428062677, -0.0867357925, -0.5826282501, -0.1612650305, 0.0203723703, -0.1388631165, 0.5323129892, 0.6909130216, -0.1817506105, 0.0703054294, -0.1418765187, -0.1324872822, -0.1483118832, -0.0922102630, -0.4843048155, -0.1457539499, 0.3309308887, -0.0538503118, 0.0859623030, 0.1181424260, -0.2982804775, -0.0371033587, -0.0178022757, -0.2299569249, -0.0598841086, -0.0279001854, -0.0758830532, 0.0016151620, -0.0291824993, 0.2288715094, 0.3704947829, -0.0902860388, -0.4166944623, -0.0440454185, 0.3104907870, 0.0709137321, -0.0422005132, -0.1019405797, 0.0026563462, 0.0363398045, -0.0158282463, 0.1453678608, 0.1108088419, -0.0090407226, 0.0424313508, 0.5955926180, 0.0464403406, -0.1928799003, -0.4230043888, -0.0965087116, -0.1312609613, 0.2344012707, 0.1022596657, -0.0652336255, -0.3944141865, -0.2717738748, -0.1560728103, 0.2166008651, -0.2685998976, -0.1325304359, -0.0189863145, 0.4937510490, -0.0914589539, 0.1404367834, -0.0058587100, 0.1279729009, -0.0339699239, 0.0780338496, 0.1517867893, 0.0684609935, -0.1952691227, -0.1473471969, 0.0927641690, 0.0276167262, -0.1636443883, 0.4013688862, 0.7897233367, 0.1528854370, -0.1215441450, -0.0961624905, 0.4499357641, -0.4914287627, -0.0203968473, -0.1036015823, 0.2904778421, 0.1091639176, 0.0813847259, -0.0570261739, -0.2344772071, -0.0421981402, 0.4992166758, -0.0333090462, 0.1310682446, 0.0792688653, 0.3231380284, -0.0811653286, 0.4115446806, -0.1144761443, 0.1022401229, 0.1922392696, -0.0247016139, 0.5414789915, -0.6186872721, 0.0155405123, -0.1227390468, 0.2946585417, -0.1143823266, -0.1633317322, 0.2611280978, 0.0353454426, 0.1353501827, 0.1039444059, 0.1693117023, -0.1500971317, -0.7679409385, 0.0142874932, 0.0120757930, -0.7306954861, -0.0224551782, -0.0042651752, -0.0094140554, -0.0967333391, 0.3465160131, -0.3948786557, -0.0551685132, 0.0668169707, 0.4791767895, -0.0762371719, -0.4388855994, -0.1219929159, -0.3018995821, -0.0630479455, -0.0472055674, -0.1158434972, 0.5670053959, 0.3714078963, -0.0533355698, 0.0604951493, 0.0198123846, 0.0452611446, 0.0619131364, -0.1093275547, -0.1935352236, -0.0382293276, 0.5590049624, 0.0236338433, -0.0909347981, -0.0285460986, -0.3258680403, -0.1480489671, -0.2762756944, 0.1312206089, -0.3209850788, 0.4892196357, 0.2619186342, 0.1367587149, 0.2000810504, 0.1042796597, 0.3321382999, 0.0004668236, 0.0445929766, -0.0858382732, 0.2879464626, 0.3818485141, 0.1070250273, -0.6770620346, -0.0247912612, 0.0368236005, 0.1912816912, 0.0596719533, 0.1388991177, 0.0274922810, -0.1886105835, -0.5878977180, -0.0337956883, 0.0004851492, 0.0570475422, -0.0805329606, -0.1503482908, -0.0586642921, 0.0003735072, -0.2309407145, -0.4060267508, -0.2801815569, -0.1450226307, -0.6898746490, -0.4035528898, -0.0764030814, 0.0171595402, 0.1404277086, 0.1410942078, -0.1712528914, -0.1080313027, -0.0665813610, -0.1367613077, 0.0976926014, -0.1583786160, -0.1149472818, -0.1565027535, -0.1114414632, -0.0522588789, 0.0958964676, 0.0509513244, -0.2016525120, 0.7405108809, -0.1812133938, -0.1800094992, -0.0793470591, 0.3629804552, -0.4520904422, -0.4033074975, -0.0274300501, 0.1283365637, 0.0750352889, -0.1701748967, -0.1489675790, 0.0464757122, 0.3441527486, 0.3821454346, -0.1793183982, -0.1470999718, -0.0648874566, 0.1164448187, 0.0642329007, 1.2007582188, 0.0793483183, 0.0662942901, 0.0451948047, -0.1260234565, 0.4097056687, -0.3662641943, -0.1736278236, -0.1384133101, 0.3327743113, -0.5643558502, 0.0407412611, 0.0429401286, -0.1477022171, -0.0154567938, -0.8253918290, -1.0978401899, 0.0861700997, -0.1474327594, 0.0443416648, -0.0808191001, -0.4154966176, -0.0277888011, -0.0935398862, -0.0218705628, -0.1680854410, 0.3241111934, -0.1977616847, 0.1662586629, 0.1259292960, 0.5374633670, 0.1264565289, -0.2350947857, -0.0585343540, 0.1443630904, -0.1039821059, -0.0679495335, -0.0680838376, 0.3095050752, 0.5115921497, -0.6996512413, -0.0329498574, 0.0402401797, 0.1053454652, 0.1187931895, -0.1592439264, -0.6309797168, 0.0251057111, -0.3104367852, -0.0145047335, -0.0497884415, -0.1059770659, -0.3311610222, -0.1872913092, -0.1456990540, 0.0021256711, -0.0381103680, 0.5043477416, -0.1545739323, -0.0553987026, 0.6084121466, 0.4397838116, 0.4878124893, 0.0233358294, -0.3342631757, -0.0168178454, 0.1803363711, -0.5119816065, 0.0316817686, -0.4387059808, 0.0098539544, 0.1170710176, 0.1668112427, 0.0649902746, 0.0550799519, -0.1914661825, -0.2260239273, -0.2424923480, 0.0832497850, -0.1085155681, 0.1114655882, -0.0275969505, 0.0329808891, -0.8029341102, -0.2517878115, 0.0332212374, 0.1160613224, 0.0146458074, -0.0203586668, 0.9775663018, -0.2858397067, 0.1048909351, 0.2124874443, 0.4666273892, 0.1026422232, -0.1806533039, -0.1208665371, 0.0085689584, -0.1097818017, 0.0038781769, -0.1626642346, 0.1058049276, 0.2380624712, 0.0754617304, 0.0187049303, 0.0295790303, 0.0194537193, -0.1064270362, 0.7958269119, -0.2299346030, -0.1121531054, -0.7389762998, 0.0745438188, -0.3714861870, -0.5413264632, 0.0437499136, 0.4650997519, 0.0512000248, 0.1018425822, 0.1022887081, -0.1800496131, 0.1877387017, -0.1365904510, 0.0814808011, -0.0757094622, 0.0649479628, -0.2659983337, 0.0845577121, 0.5583441257, -0.0649427623, -0.1783856899, 0.0362385213, -0.0123622492, 0.7021492720, 0.5278606415, 0.1113149151, 0.0281809103, 0.0103619695, -0.3609883487, 0.0520938858, 0.0839240253, -0.0007456977, -0.1256190836, -0.1910324544, -0.3692854941, 0.1395559162, 0.1508303285, 0.3293437660, 0.0616900958, -0.2953602076, 0.0007356551, -0.0148745384, -0.0093393857, -0.2453741133, 0.0609700382, 0.0552238710, 0.1177573428, 0.0666446388, 0.4405892789, 0.0263360031, 0.2813953757, -0.1129242703, -0.7021581531, -0.2267257273, 0.1353382915, 0.0444349125, -0.0614279695, -0.2602810264, -0.6184553504, 0.0644658133, 0.0429691412, 0.0797285959, 0.1348124295, 0.1059395000, -0.2639545202, -0.0088062473, -1.2734602690, -0.0206186324, 0.0670887157, -0.4673396945, -0.1804843694, -0.1348692328, -0.2246398926, -0.2205332518, -0.0992052406, 0.6388436556, -0.0442227907, -0.0972580612, 0.6080121398, -0.1886075586, 0.2660150230, 0.0201461017, 0.2100513130, 0.0997198746, 0.3700397611, -0.4163725078, 0.0545089357, -0.5826565027, -0.1167498454, -0.0909113586, 0.0194538925, 0.0737350062, -0.0695727468, 0.1938926280, -0.0743124485, -0.4325872064, -0.1325732470, 0.1039201766, 0.4987574220, 0.0057285428, 0.1020528600, -0.0298842490, -0.1915721744, 0.1208078414, -0.9442914128, -0.1776905805, 0.0508860350, -0.0071052597, 0.0276508033, -0.0095346821, 0.1012566984, 0.1384549588, -0.0550469942, 0.0534945354, -0.1267235130, -0.0946579427, 0.0576202385, -0.1950136423, -0.1417274773, -0.1281232238, 0.0685394257, -0.3456541300, 0.0659274906, -0.0897574723, -0.0442842171, 0.0158551335, 0.4922544658, -0.0934650972, -0.1677832305, -0.5094571114, -0.1895974278, -0.6860117912, -0.0895796046, 0.1209188178, -0.1154672652, -0.2248426825, 0.5413326025, -0.0722705647, -0.3361482918, -0.0942381099, -0.3102724552, -0.0872670859, -0.1100944430, 0.0724197477, -0.1523607969, -0.0843372196, 0.4485089183, 0.0022081716, -0.1594778150, -0.1488891244, -0.1119055897, 0.7664720416, 0.3607915044, -0.0979591236, -0.2031719685, -0.0545372963, -0.3706470728, -0.1731954366, -0.0522077046, -0.1002886444, 0.0217132792, -0.5662366152, 0.1763640344, 0.0266722664, -0.2506590188, 0.2292606682, 0.4540229142, -0.0252219066, -0.0496971086, 0.0766724870, 0.1270627230, 0.0399683900, -0.3303510249, -0.0978522673, -0.0453090779, 0.1099299192, 0.6403996944, -0.1158171818, 0.1474135965, -0.8440892100, 0.0506553836, -0.0441713966, -0.0127620436, 0.0264714193, 0.3254522383, -0.7152988315, -0.7448608279, 0.0804793090, -0.2401304692, 0.1082590595, 0.0429069735, 0.1238453016, -0.1625906825, -0.0147510190, 0.6057834029, 0.0426764935, -0.0392820202, -0.2278582603, -0.3546525836, 0.0576219223, -0.2523975074, -0.0895720050, -0.1186981425, 0.4791660309, -0.6712993979, -0.0221633539, 0.0887355581, -1.0341259241, 0.4505695105, -0.1299849302, -0.5807363987, -0.1741972119, 0.0636738688, -0.2427681834, -0.1650979519, -0.5004680157, 0.1750572175, -0.1408627629, 0.1297755986, 0.1404002607, 0.0619338639, 0.0014038179, -0.2391690612, -0.1408097595, -0.0834177211, 0.1274896860, 0.2924294174, 0.0808538198, 0.1508298814, -0.5300787687, -0.0761581212, -0.1003921553, -0.3245939910, -0.0830134079, -0.0817669705, -0.1849338859, 0.0769673735, 0.0385592096, 0.0703992918, 0.4759402275, 0.0529949851, -0.0819533691, -0.0876219422, -0.1843767017, -0.0794101581, -0.3887217939, 0.0187457073, -0.0739982650, -0.4567829370, -0.4250600040, -0.0171781052, 0.0307523143, -0.1559090614, 0.1819827408, 0.5220374465, -0.0115466509, -0.1204032674, 0.3272395730, -0.1200163886, 0.0839784443, 0.5395807028, 0.0121447416, 0.2497962415, -0.1739745289, 0.2015220374, -0.1585051417, -0.1088706553, 0.1326864213, 0.2173988223, -0.1178666055, 0.0748455524, 0.1701643467, -0.1980510950, -0.0603456572, -0.1639342457, 0.0972340330, -0.0416299812, -0.3784624040, 0.0856584162, 0.6403036118, 0.7918430567, 0.1711818129, -0.2345649302, -0.3534569442, -0.1546494812, -0.2010972351, 0.4252870381, 0.0887816250, -0.0565802343, 0.7311698198, 0.1466829330, -0.0311595574, -0.1780547649, 0.5329415202, 0.3369498253, 0.5914211273, 0.2073094100, -0.0615093634, -0.0325270109, -0.0875631347, -0.0933367684, -0.1490450650, 0.1148378849, 0.0789915025, 0.4797111452, 0.0351092815, 0.0571330898, -0.6255831122, -0.7450196743, -0.0931390002, 0.1808989793, 0.0279021338, -0.5156239271, -0.7855995893, -0.3169503510, -0.0035190273, -0.0906305090, -0.1581285745, 0.0624600314, -0.1696654856, 0.2644453943, 0.2201016396, 0.0032229959, -0.0434226878, 0.0452353433, 0.0117083732, 0.0723685771, -0.2315111905, -0.0871906206, 0.1580116153, -0.2060809433, 0.0868546739, -0.2232473195, -0.0908190981, 0.2022769153, -0.0519759245, -0.1294123977, 0.0529895276, -0.0416207314, 0.0069740261, -0.0045982264, 0.7510026097, -0.1250190139, -0.3082582057, -0.0787006691, -0.0372457951, 0.1656672657, -0.1089081168, 0.0493181758, -0.0686081350, -0.1607905626, -0.0972044691, 0.1484425813, 0.0251012780, 0.8687824011, -0.1067792028, 0.1242314130, -0.4840768874, -0.0914260894, 0.0142548131, 0.6371853352, 0.1922061890, -0.1445158124, -0.5565061569, 0.1085235104, -0.1655464321, 0.0172609091, -0.0181350335, -0.1440761089, 0.1261128187, -0.0072146035, -0.0371108465, 0.0795371383, -0.0120732021, 0.1109290048, -0.2366347462, -0.4743152857, -0.0591850728, -0.0389730744, -0.0988331363, 0.0237859245, 0.3829917312, 0.5390616655, -0.2349881530, 0.0465473309, -0.0410922654, -0.2120480984, 0.0962773710, -0.0049989768, 0.0184990168, 0.0232925024, -0.1705407053, -0.1298192739, -0.0449984744, -0.3496347666, -0.3865484595, 0.4188454151, -0.0097413082, 0.0916935131, -0.1664486527, -0.5641684532, 0.1441766173, -0.8416429162, 0.0825009272, 0.0547836237, 0.1095465049, -0.0746728405, 0.5571698546, 0.5482508540, 0.1891156882, 0.0658383965, -0.2340951115, -0.6186539531, -0.0001089960, 0.0905205011, -0.0226314496, -0.1764598489, -0.1329690963, -1.2335840464, 0.0899130031, 0.3063447177, 0.0373570658, 0.5118229389, 0.4786088467, 0.0680714324, -0.2180141658, -0.0996452644, 0.0031188435, -0.2463020831, -0.0927460417, -0.0056848209, -0.0323526785, 0.5609877706, -0.0556895025, -0.0485764816, -0.7499697208, 0.1996411234, -0.1085066274, -0.0276615731, -0.1574425101, 0.0768996477, -0.0747531429, -0.0803581178, -0.0006949832, 0.0443027802, -0.1481027901, -0.0200927276, 0.1134433076, -0.2733900845, 0.1418218166, -0.8881548047, -0.0700136200, -0.1076600254, -0.3384077251, 0.1517963707, -0.1616639793, -0.0824251324, 0.1632478833, -0.2115161121, -0.3523555696, -0.1490623653, 0.1060366407, 0.0506768860, -0.4681940377, -0.1271974742, 0.0002082735, -0.6265630722, -0.0314359963, -0.5135083199, 0.3770985901, 0.0706096292, 0.0006960404, 0.0000809272, -0.0730038211, -0.1745817959, -0.0550902225, -0.1618833244, -0.0146533335, -0.1391257793, -0.2313876003, 0.0411259383, 0.1150093600, 0.6112126112, 0.1189524382, -0.1271354407, -0.2509590089, -0.2127261609, -0.0509884395, 0.3474859297, 0.2394168228, 0.1483210176, -0.5808395743, 0.1647496372, -0.1274701953, 0.0734280124, -0.2625274062, -0.0905817449, 0.0444164760, -0.1643642187, 0.0951436982, -0.0325824954, 0.2962734997, -0.0501632839, -0.0191371329, -0.5029610395, -0.6435096264, 0.0198937487, -0.1775338501, -0.1761823595, 0.2607146800, 0.1107635573, -0.0581467748, 0.1314510852, 0.0353684165, 0.1134516597, -0.8608524799, 0.4285221696, -0.0508886129, -0.0150106708, -0.2299843580, -0.2240676731, -0.2912171185, -0.1360575110, 0.3232485354, 0.3909707069, 0.0003458371, 0.1618043482, -0.0488026142, -0.3183306754, -0.1384117454, -0.5762183666, -0.1324750334, -0.0229253992, 0.0306270085, 0.0044376492, -0.0792800337, 0.3763170242, 0.5020834804, -0.1049206555, -0.1842628419, -0.1376133263, -0.0728229657, 0.1300429404, -0.1209619641, 0.0036735998, 0.3052731156, -0.3064249754, -0.1623859555, 0.4000178277, -0.1894009560, 0.0787516013, 0.1992958933, 0.1598699987, 0.0482488312, -0.1152620986, 0.1043358967, 0.0046307049, 0.0051691211, -0.2452417761, -0.1107339486, 0.4339359701, -0.0557384975, 0.5780476928, -0.4162107408, -0.4825242460, 0.0548446439, -0.1006852835, -0.0605782978, -0.1384343803, -0.5823715925, 0.0034686530, 0.0767867118, 0.0257467944, -0.1123514250, 0.1661948264, -0.0635052100, -0.3263263106, -0.0716088638, 0.1978651434, 0.0156747699, 0.0772361755, 0.0539112166, -0.3056263328, 0.0198332090, 0.2821358442, -0.0788930878, -0.1095798686, -0.1976356208, 0.1626125127, 0.1389161944, -0.0052835881, 0.2009979934, -0.8690999150, -0.0090731382, -0.2706760466, -0.1407289952, 0.0705600977, 0.1593767107, 0.1494241655, 0.0384053960, -0.1426558495, 0.1484053582, -0.1147694811, 0.1088477522, -0.0269553419, -0.1004867479, -0.0438647866, 0.1458040923, 0.0606578700, 0.0394888185, 0.5280661583, -0.1448601037, -0.0977232680, -0.4708967507, -0.1376496255, 0.0439229794, 0.7538856864, 0.4129353762, 0.0857149214, -0.0056906096, -0.2539643645, -0.1670196354, -0.0444638021, -0.0472910516, 0.0888853222, -0.1021935195, -0.1896313131, -0.0521010719, -0.0319504738, 0.1777840853, -0.0752786174, 0.0605939701, -0.2942073941, 0.0375143513, 0.0714774504, 0.1325408816, 0.0826590881, 0.2869253159, -0.1744111031, -0.1992669851, -0.0160264149, -0.2612082958, -0.0989878178, -0.4758740366, 0.3463185132, -0.1987934560, 0.6836929917, -0.0291353967, -0.0195686426, -0.0921920985, -0.1907866448, -0.0548754744, 0.5842170715, 0.0552175008, -0.0617890209, 0.1642190218, -0.2235553116, -0.0979583263, -0.5143480897, -0.1617061347, 0.0792734846, -0.2620968223, 0.1637918055, 0.1625317931, 0.2672801614, 0.4743171036, 0.0682255402, -0.0171674453, 0.1942244023, -0.1313747913, -0.0339297801, -0.1222448945, -0.0931070819, 0.0892838761, -0.1349742562, -0.0859019682, -0.2304759026, -0.6047772169, 0.1498075426, 0.2538818419, -0.1437572539, -0.1209670976, -0.1019977778, 0.1451752037, -0.1141017899, -0.0510213263, 0.0133859077, -0.0954476669, 0.5089705586, 0.0739516243, 0.1711513251, -0.0218794290, 0.0189216323, 0.0876598954, 0.1137484759, 0.0947468802, -0.3746302724, -0.5928864479, -0.6129770279, -0.1608884186, 0.1650739014, 0.1060714498, 0.1249656007, -0.1184990183, 0.3445402980, 0.0756105483, 0.0238849688, -0.0882585496, -0.1716809720, -0.4429189563, -0.0674287602, -0.3320336938, 0.1845422536, -0.1053993851, -0.1596234888, -0.4670316875, 0.3023868203, -0.0860227942, -0.3510829508, 0.6718485355, -0.4777967632, -0.1407013237, 0.2056911886, 0.1139022037, -0.3898228407, -0.1107930616, -0.1248545423, 0.1281672269, -0.0173288882, -0.1476691514, 0.0602789968, -0.0178295597, -0.1753687561, -0.1514070481, -0.1030999124, -0.2312511206, 0.1480721533, -0.1793767959, 0.4516841471, 0.1516303271, -0.1113676280, -0.3326410055, -0.0532883890, -0.0653936565, 0.7996120453, 0.4079084098, 0.0801745355, 0.6931068301, -0.1070398614, -0.1576267481, -0.1420955062, -0.6661671996, -0.0261942316, -0.1490264237, -0.0816168413, -0.0437917411, 0.1172185540, 0.6833329201, -0.1793339401, 0.1136011854, -0.1574986577, 0.1382711381, -0.1374426335, 0.0109369066, -0.0841791183, 0.0631260127, -0.1860106438, -0.2462088317, -0.2008889467, 0.6049840450, -0.4745301306, -0.4895569682, 0.3940043449, -0.0848223493, -0.3183295131, 0.0134590231, -0.3241351843, 0.0508609898, 0.0876414776, 0.5046845078, 0.1249523759, -0.1804039925, 0.0190309007, 0.1408341974, -0.2605816722, 0.0727921575, -0.2480443418, -0.1098266840, 0.2017929405, -0.3095404804, 0.0881757811, -0.1922856867, 0.1204629540, 0.6869465113, 0.1506167650, -0.3560189009, 0.3488976061, 0.0091874432, 0.2607295811, 0.0009193100, 0.0408085287, 0.1700575650, -1.1149511337, 0.1460069120, -0.3941282928, -0.4214848578, -0.2618098855, -0.0378641896, -0.0087675843, -0.0061256713, 0.1135713533, -0.0513779633, 0.1690744013, 0.1822000146, -0.1194709614, -0.1590090394, 0.3408555090, -0.1651873589, -0.0843209997, -0.0446035452, 0.1121193245, -0.1463588476, -0.1589691490, -0.1001966894, 0.6350520253, -0.0136669446, -0.1671454459, -0.0263221506, 0.1200124323, 0.0118979923, 0.0555647947, -0.1082527414, -0.0294123925, 0.0104565946, -0.6477188468, -0.0102299005, -0.0700017288, -0.2010962665, -0.0875418559, -0.1338253468, -0.0020818058, 0.1239879876, 0.0218470935, -0.8822153211, 0.8927434683, -0.0297036972, -0.0539268777, 0.2717038095, -0.2398886681, 0.0976621658, -0.0469076969, -0.1582289785, -0.1160379276, -0.2036249936, -0.1642969549, 0.5557220578, 0.0133582009, 0.1068972796, 0.0978472084, 0.0278380644, 0.0893203616, 0.0358722918, 0.0540937372, 0.0231034290, -0.0315639265, 0.0430109017, 0.4296365380, -0.0174295008, -0.0819377676, -0.4721807837, -0.0999082774, 0.0749865472, 0.0674127564, 0.8595675230, -0.1579264998, -0.4961683750, 0.0798235387, -0.0515307002, -0.1078834534, 0.1186163500, -0.0116851246, -0.0444837548, -0.0682429746, 0.1491791904, -0.1304308474, 0.6542361379, -0.0986981541, -0.0514380336, -0.5157399178, 0.0921375304, -0.0512948520, -0.1164178625, -0.1472367197, -0.6273689270, -0.7982674241, -0.1411334276, 0.0733701438, 0.7673407793, 0.0606729910, -0.7609588504, 0.3425965011, 0.0676032230, 0.2490424663, -0.1484944671, -0.5416113138, -0.0840454623, 0.9248843789, 0.2487079501, 0.1309589893, -0.2450454682, 0.0311015602, -0.1187707186, -0.1162689030, -0.2345051616, -0.4726875126, 0.1143166646, -0.0359519646, -0.2580713928, 0.0212827846, -0.4069018364, -0.2604040504, 0.5074543953, 0.0654743016, -0.1150106490, 0.3241610825, -0.1191124544, 0.2055062950, 0.1232797801, -0.0079581765, 0.6247790456, 0.4150867164, -0.1451558471, -0.1676503122, -0.3376751840, -0.2276386023, -0.0799256712, -0.1887103617, -0.0848756209, -0.1368125677, 0.1314241737, 0.2341046035, 0.3049540818, -0.0774870813, -0.1603865474, 0.2723411024, 0.1536911875, 0.3232410252, 0.1310871691, -0.2368074656, -0.1871118098, -0.1282484382, -0.1266165972, -0.3052967489, -0.1771997362, 0.4344304204, 0.1210535914, 0.1905177236, 0.1544429660, -0.2299599051, 0.0857150778, 0.3627068996, -0.0071872007, -0.0544040464, 0.0509949327, 0.0997074842, -0.0385355838, -0.2701382637, 0.1015155688, 0.2023500204, -0.1090770140, -0.1818999350, -0.1574638039, 0.0013271488, -0.1340292096, -0.0483613089, 0.2481351793, 0.0221515801, -0.0386087224, -0.1727852672, -0.0119165042, 0.0777394325, 0.0348967351, 0.0284324083, 0.6751965284, 0.1411505640, -0.1487612277, -0.2415322661, 0.0409498215, 0.1044803262, 0.1651669741, 0.2006912827, -0.3513323069, -0.0214927029, -0.1541179419, 0.0301045720, -0.1138402000, -0.0287866350, -0.2529066205, 0.1274360716, 0.1652752608, 0.1469148695, 0.6624040008, -0.0909295008, -0.2814250886, 0.1029483974, -0.1399042457, -0.2455097139, -0.4278882444, -0.1006942615, 0.1537690759, -0.1744326651, 0.0865942389, -0.0241282489, 0.1808453798, -0.1799749136, -0.1959311217, -0.5171245337, -0.1795880795, -0.0214424506, -0.0663011298, -0.1587733030, -0.0630109832, -0.3339637816, -0.2839171290, 0.0494283363, 0.1510811299, -0.2291239053, -0.0480933264, -0.0984637141, -0.0094720498, -0.1130897552, -0.1341087669, 0.1666397899, 0.1496183574, 0.2262567431, -0.6367068887, -0.2774403095, 0.0893915892, 0.0492015965, 0.1012308821, -0.3269003630, -0.1217586994, 0.0338131785, 0.1165551990, -0.0875583962, -0.0223019961, 0.0514899567, -0.3732417226, -0.6574404836, 0.6262637973, 0.1107967198, -0.1165463328, -0.4500507414, -0.1664686054, -0.0931003317, 0.0959983766, -0.0689333007, -0.1345413178, -0.6097905040, 0.1400615722, -0.1253371537, -0.4657535255, -0.2823191285, -0.3666855991, -0.1049292535, -0.0087078474, -0.0018648988, -0.1390407085, 0.5250595808, 0.5597156286, 0.0112394588, -0.1544121802, 0.0837608799, -0.1336358488, 0.6001672149, 0.4499865770, 0.3215444386, 0.0111724483, 0.0435427129, 0.1128236502, 0.0472295135, -0.3287845850, -0.8912067413, -0.0779001340, -0.1021226496, -0.0537950769, -0.0902660489, -0.0909432918, -0.0088723628, -0.1567324549, -0.0186507888, -0.1662195623, -0.0428843573, 0.2696636021, -0.2576476634, -0.0857452378, -0.0046694479, -0.0281720366, 0.0079821898, -0.6973189116, -0.0449301749, -0.0620188527, 0.4060802460, 0.2037854791, 0.7344418168, 0.1034155041, -0.1958209276, 0.1098409668, -0.1285071075, 0.0566365160, 0.1207756847, 0.7257034183, 0.0255312175, 0.1172535270, -0.0025095481, 0.1441294849, -0.1996101141, 0.1589109749, 0.1824179143, -0.0381881408, -0.0972736850, -0.0581744723, -0.2360178828, 0.0694268942, -0.1640302837, 0.0532085262, 0.0151875615, -0.2985174954, -0.4874096811, 0.4941470325, -0.0213933438, -0.3595876992, 0.1106083244, -0.0041104103, -0.0664841756, -0.4144843817, 0.0890393108, 0.1274602264, -0.0985600799, -0.0374096669, 0.0188656282, 0.3860331178, -0.1557693332, -0.1890233904, -0.4837245643, 0.0029617341, -0.1992206573, -0.0795558020, 0.0551228151, -0.0448608808, -0.3013897836, -0.0350963324, -0.1809344739, 0.1366214156, -1.0039699078, -0.4681095779, -0.1102740318, -0.0976162180, 0.0079243183, -0.2407692969, -0.3242952824, 0.0188655667, 0.6343485117, -0.2559216619, -0.3226671517, -0.0877844170, -0.0375019200, -0.0908876956, 0.0479708984, -0.1034848094, 0.0949363858, 0.0127161872, 0.0772863626, -0.0387200676, -0.1280921400, -0.1176333427, -0.4622796178, 0.3781114221, 0.0466505811, 0.1261361241, -0.1473578364, 0.0619291179, 0.1115042642, -0.1372721791, -0.1316770315, -0.3063533306, 0.4874430895, 0.0222271364, 0.2478695363, -0.4523900151, -0.0806880146, -0.6230433583, -0.1190046817, -0.1069178730, -0.0618316308, -0.1264976412, 0.5290399194, 0.7686664462, -0.1269970983, -0.1388876140, -0.1325865537, -0.0333031677, 0.5316935778, 0.5960320234, -0.1414991468, 0.0998124406, -0.0023115287, 0.0251287092, -0.2028556317, -0.0113875875, 0.2790221572, -0.1018890142, -0.0492863245, -0.1121939346, -0.1224353909, -0.0038152393, 0.2076206803, -0.0359012187, 0.3601394892, 0.1176192611, -0.0567354783, 0.6688271761, -0.0393230133, -0.0284801424, -0.0750346556, -0.1313651353, -0.0496326461, -0.1144162416, 0.3213884532, 0.0872851312, 0.1505289078, 0.5124961734, 0.7915084362, -0.0667485371, -0.1870681643, 0.0039394479, -0.3056995869, -0.0456485264, -0.0775789991, 0.7563678026, 0.1333006769, -0.1511611044, -0.0868662447, 0.0380978473, 0.0587915890, -0.0952715129, 0.0265100114, 0.0852640793, -0.0280522425, 0.0916839242, -0.1037816629, 0.1394439191, 0.0859016106, 0.3450984359, -0.0670446604, -0.0673000664, -0.5280064344, 0.3938933313, 0.0635645688, -0.0228886567, -0.0389767885, -0.1493706405, -0.0293205082, -0.3642791510, 0.0349943042, -0.0520360917, -0.1244882494, -0.0766386390, 0.0053757308, -0.0397221334, -0.3216340542, -0.0617823526, -0.2380354404, -0.3690056205, 0.0777768940, 0.0179344155, -0.0956183895, -0.3444363177, -0.1211242676, -0.1738411337, 0.0939815417, 0.0857365280, 0.3924205601, 0.2380621880, -0.5235855579, -0.0415605158, -0.6166768670, -0.1007113755, -0.3839612901, 0.2122903764, -0.2259062529, -0.0968951136, -0.7410330772, -0.0895743519, 0.0257469714, -0.0322607495, -0.1942458004, -0.1841381192, 0.6847939491, 0.0366709717, -0.2208086699, -0.1880418062, -0.0346008129, 0.2063256353, -0.3531323373, 0.0922502205, -0.2469242811, 0.5748203993, -0.0431821421, -0.0985715389, -0.1955636740, -0.1521894038, -0.1012295634, -0.5401193500, 0.1077299193, -0.1216573194, 0.4555144012, -0.5695659518, -0.1802285165, -1.0383911133, -0.0899784863, 0.0037013215, 0.0622130707, -0.1656701863, 0.4000743926, 0.4883093834, -0.0016855026, -0.0720626190, -0.2325737923, -0.0097936336, -0.2294188738, 0.6058461070, 0.0353383869, -0.1414306015, -0.1384722590, -0.0312904269, -0.2424071431, 0.1845208555, -0.0560599044, -0.0216540173, -0.2025690079, -0.0641508698, -0.0704987645, 0.0252919123, 0.1948847920, -0.1261775494, 0.1586693823, -0.0976181254, 0.0799580067, 0.5482764840, 0.1873970628, 0.0413414463, -0.0934358612, 0.0819620192, -0.1300536990, -0.4595102072, -0.2682220936, -0.1621732563, -0.7986109257, -0.2143401057, 0.2675177455, -0.0973094329, -0.2095277756, -0.1084563360, 0.0961323380, 0.2926647663, -0.1393228024, 0.1798969954, 0.0164407454, 0.0670388043, -0.0127641065, 0.0971557423, -0.0162032787, -0.1258630902, 0.0543865487, -0.3231214881, 0.0478669442, -0.0604890361, -0.0950308219, -0.1467639655, -0.0629160255, 0.4340215921, -0.2284725457, 0.0665280372, -0.0882378221, 0.4380745590, -0.0815498009, -0.5064190030, -0.5068198442, 0.1087480411, -0.1239333451, -0.0130172418, 0.0006031701, -0.0198339317, 0.0045915134, -0.0880060717, -0.0690690875, -0.3169261217, -0.3566204607, 0.0349915735, -0.8460268974, -0.1260078847, -0.1057786047, -0.1478709131, -0.1441504359, -0.3827565014, -0.1568702161, -0.0952350274, 0.0698028728, 0.0239526313, -0.5065620542, 0.4015251696, -0.3626751900, -0.1440466791, 0.1452760547, 0.0251108315, -0.4328597784, 0.1855546981, -0.0638110489, 0.4910286069, -0.6240426898, 0.1427923143, 0.0547176898, -0.1337904781, -0.2729392648, -0.0034263670, 0.3753619790, -0.1611679494, -0.1788034439, -0.5836918354, 0.0646411777, 0.6626220345, -0.1160240397, 0.1249854565, -0.0371916331, 0.7624474168, -0.4385717213, -0.1311364472, 0.4738334119, -0.1109162197, -0.0151329460, -0.1003371552, 0.1521423310, -0.0931532234, 0.1655771434, -0.3539082110, -0.3208264112, -0.4851115644, -0.0150959734, -0.0151029462, -0.1393772066, -0.0150288912, 0.3144345284, 0.5214980841, -0.0301264301, -0.0733165219, -0.1978001893, 0.1355730295, -0.1096036807, 0.8176748157, 0.2854571939, -0.0248116739, -0.1780780852, 0.0329311527, -0.3911403120, 0.3845060766, 0.6789701581, -0.0891303197, -0.0425942652, 0.1538420916, -0.1453381926, 0.0404982753, -0.1370345354, -0.0808944032, 0.2607916892, 0.0255044010, 0.0309059620, 0.6011540890, -0.0217534583, -0.0638359934, -0.1895922720, -0.0794439837, -0.0567066073, -0.5825459957, -0.2853936851, -0.1207333207, -0.1812157184, -0.3491194844, 0.4078906178, -0.0682326034, -0.1810734570, -0.0647622868, -0.2731631994, 0.4970330894, 0.0789068043, -0.2616074085, -0.0865235999, -0.1619099081, 0.0271851663, 0.0993266702, -0.1178714186, 0.0175921973, -0.0609786063, 0.3481164873, -0.1416326165, -0.1660305709, -0.3648488224, 0.0625924319, 0.0522108972, -0.0394498259, 0.0042282520, -0.1924505085, -0.6065112948, 0.0996115133, 0.1468328387, 0.0704528093, -0.3952791989, -0.1556500643, -0.1145044640, -0.3020642102, -0.1652688831, 0.0530160256, 0.0298559424, 0.1094676331, -0.1692485064, -0.1945300549, -0.3228018284, 0.0177145675, -0.4665767550, 0.5649971962, -0.2831294239, -0.1920377910, -0.0589291975, 0.1458128840, -0.2872182429, 0.0967820808, 0.0734780580, -0.9484276175, -0.2820120454, 0.6034250259, -0.3429964483, 0.0706124976, -0.1188204214, -0.1121213809, -0.0292440001, 0.0820212066, -0.4576933682, -0.0861300752, -0.1275214106, 0.1852357835, -0.0291082915, -0.1233804896, -0.1464714855, -0.0374932997, 0.3651338220, -0.0331108719, -0.1582901925, -0.2232000381, -0.1494112611, 0.5813145638, -0.4846432507, 0.0961624831, -0.3138828874, 0.8092045188, 0.1168323904, -0.1193495467, -0.2064597011, -0.1765456200, 0.0522518754, -0.2170217186, -0.2797410190, -0.1699144095, 0.3112256527, -0.1601833403, -0.3597579598, -0.3484856784, 0.0319592617, -0.2410513461, -0.0055169854, -0.1998673230, -0.0248872526, 0.4596915841, -0.2210613489, -0.1054039523, -0.4497270882, -0.0907594115, 0.5060395598, 0.4321081042, -0.2305384725, -0.1303814054, -0.1021420211, -0.1340467483, -0.1021886468, 0.3487896919, 0.4650147259, 0.1533620805, -0.0479603522, -0.0365920663, -0.1907518208, 0.0145829143, -0.1011421159, 0.0404903665, 0.4742446244, 0.0558987893, -0.0499504618, 0.2884726822, 0.0633903071, 0.1948828101, -0.1307857037, -0.1158358008, -0.0345823951, -0.1192308962, -0.6179649234, -0.1146188974, -0.1761993021, -0.1064656228, 0.2080526054, -0.1356907785, -0.3067860007, -0.0905447677, -0.1454588473, 0.3197208941, -0.0674006194, -0.4587331414, -0.1437579244, 0.0357428193, -0.1754073501, -0.0174359679, -0.2346790582, 0.0140479738, 0.0436655432, 0.5743779540, 0.1023523808, -0.0561433695, 0.1343663633, -0.1183206886, 0.0122129815, 0.0012226009, -0.0051507144, -0.0805909857, 0.0490721986, -0.0393504649, -0.1611564606, -0.0160928387, -0.0852332488, -0.0430115946, 0.1741139442, -0.0972162783, 0.1429628581, 0.1013951451, 0.0837997571, 0.0143062957, -0.0239638612, -0.2250719368, -0.0976686850, 0.0047069900, -0.6504267454, 0.7991314530, 0.0192843620, -0.1140726581, 0.0426278561, -0.9165140390, -0.2368382215, -0.1942016631, 0.1410800070, -0.3155459762, -1.0352166891, -0.0019048456, 0.2726878524, -0.1177763864, -0.3371656239, -0.0471774936, 0.0532934293, -0.0440210141, -0.3782518208, 0.5930168629, -0.4846330881, -0.1003160924, -0.1563059986, 0.0405242555, -0.0517581925, -0.0087950667, 0.0687791854, -0.1481596231, 0.0080099842, -0.4093021750, 0.0038421638, 0.6311483979, -0.0755228847, -0.0927328542, 0.0040295408, 0.6202737093, 0.0133953290, -0.0332185514, 0.0254075397, -0.1425349265, -0.1510839462, 0.4523029327, 0.1117473245, 0.1162414774, -0.1912509501, 0.2504878342, -0.2092437297, -0.2425719202, -0.1419093609, -0.1964985281, 0.1050633937, 0.0610842258, 0.3860281408, 0.4398358762, -0.1071541905, 0.1050338671, -0.3624571562, -0.1570766270, -0.1894881576, 0.2555756867, -0.2685744464, -0.0425028205, 0.0495584048, 0.0986430719, 0.0067395172, 0.3786095679, 0.1884154230, -0.1231577843, -0.1253317147, -0.1640498191, 0.0096337516, 0.0263374690, -0.1037077531, 0.1130459160, 0.0192251839, -0.0491617918, 0.0433367230, 0.4816327393, -0.4465178251, 0.1224306673, 0.1038346812, -0.2422675639, 0.0998463258, 0.1938202530, -0.0742986500, 0.0397084393, -0.4563051462, -0.4252986312, -0.0147416778, -0.0680087805, 0.0784336105, -0.0709969625, -0.1483484656, -0.3173904419, -0.1138159186, -0.6644473672, -0.2027252913, 0.0428164601, 0.0106346542, -0.0661221519, -0.0566546544, -0.0341684408, -0.0688631013, 0.8279736042, -0.0847307965, 0.0012684983, 0.2304668128, 0.0073234141, 0.1217316166, 0.3677430749, -0.1551649570, 0.0432077572, 0.1357727051, -0.1544768065, -0.0775471255, -0.1033533737, 0.1156063229, 0.0476218276, 0.0957977623, -0.0666723698, 0.0777818635, -0.1524492949, -0.1842774004, -0.1091432646, -0.0465994775, -0.4360503554, -0.0684803054, 0.0317753591, 0.0685750097, 0.4575229287, 0.2172342837, 0.0877535939, 0.0736774504, 0.3469364643, -0.3119024932, 0.0546988249, -0.1300116181, -0.7333268523, 0.6826791763, 0.2876749933, 0.1926983893, -0.0445931666, -0.3806900084, -0.0443409160, 0.2207787633, -0.2745306194, -1.1274532080, -0.3653565049, -0.7053507566, 0.1437768936, -0.0403312929, -0.1923180521, -0.1189929917, -0.0501245596, -0.0039755427, -0.0246733241, -0.1120379940, -0.4438407421, 0.0049402583, 0.6261535883, 0.3156052530, -0.4481274784, 0.0033626023, 0.3775509596, 0.3883292377, -0.0528900921, 0.1574346721, 0.0326825157, -0.0382073931, 0.6647788882, 0.4265194833, 0.1164660677, 0.1901590824, 0.4060745537, -0.0739663392, -0.4058618546, -0.0092483098, -0.0316636376, -0.1254245937, -0.1192233190, 0.2698470652, 0.6799314022, 0.0441491827, 0.0039728447, -0.3934505284, 0.0002947062, 0.1910750419, -0.1959078163, -0.4723342061, -0.0197090004, -0.1169111878, -0.0975572988, -0.0229492020, 0.1399503350, -0.1012591347, -0.0410117693, -0.1419418305, -0.1518951952, -0.0293277595, 0.1132006273, 0.5208737254, 0.1187843159, 0.0305068474, -0.1068273261, -0.1233254299, -0.1792768240, -0.4122473001, 0.1754952520, 0.0153517034, -0.0906692967, -0.1382704228, 0.3579344153, 0.4350309372, -0.0593295619, -0.7810490131, -0.0342359841, -0.3421555161, 0.0861439705, -0.0534498729, 0.1321831346, -0.1149222776, -0.0479650013, -0.0850753561, -0.3488454521, 0.0693211034, 0.0926989168, -0.1330403239, -0.0576920547, 0.0332995430, -0.0511972979, -0.0777567104, 0.3842624426, -0.0252173804, 0.0740985274, -0.1188029870, -0.1073525101, -0.0000540869, 0.4693832695, -0.1419619769, -0.2478260845, 0.2193616778, -0.3408809900, 0.0585026443, -0.3541334569, 0.0823786929, 0.1470605731, 0.1406581104, -0.3404453099, 0.0557044968, -0.0183945671, -0.0155593744, -0.0511096977, -0.0622123815, -0.4344754219, 0.1037558988, 0.0997559875, -0.1751677096, 0.5647382140, -0.1006851941, 0.0405316204, 0.0779986307, -0.1778502166, -0.2640476227, 0.1046407893, 0.0313708484, 0.3650916517, -0.5200457573, 0.1095612869, 0.6717166901, -0.1315075457, 0.1884112060, 0.0830695629, 0.6118784547, -0.0515175797, -0.2684593201, 0.0042861067, -0.0477180518, 0.0174190123, -0.0185506511, -0.0477514304, -0.1057477519, -0.1827386171, 0.0127800927, 0.1120562777, 0.0897241980, 0.2466135323, 0.1310658306, 0.3560334444, 0.0415054224, -0.2902953327, -0.1034820527, -0.3085590601, 0.2949878275, 0.0970515981, 0.1972298771, -0.0173318442, 0.0343783684, -0.3078392446, 0.3624047339, -0.0592040159, 0.2362793088, 0.4210644960, -0.3938506246, 0.6000433564, 0.0339755937, 0.1023524478, -0.0548271276, 0.0611453168, 0.1132182255, 0.3795744181, -0.1739338189, -0.1633468866, -0.2396682799, 0.1689703763, -0.8706385493, -0.3543716669, 0.1094481274, 0.1012653634, 0.1278737932, 0.0413876958, 0.3907129169, -0.0986819118, -0.2509237826, -0.1057601050, -0.1134588867, -0.1368847638, -0.1700528264, -0.1195017919, 0.1399891526, 0.1619855762, -0.3381677866, -0.0206146445, -0.0580062233, -0.2656058669, -0.6815627813, 0.0437684208, -0.0735851079, 0.0916163698, -0.1010341495, 0.3441860974, 0.3846312761, 0.0170947835, -0.0307892077, 0.3158583939, -0.0652086660, 0.0204441845, -0.4990261197, -0.1702328920, -0.0366918705, 0.5990620852, -0.1688818038, -0.1488908082, -0.0836359262, -0.1044539362, -0.0626767129, -0.0843603984, -0.0079992143, -0.1690583527, -0.0310142823, 0.5534423590, 0.1325370669, -0.1314313859, -0.1449561268, 0.1303283423, -0.1624197513, 0.5488114357, -0.0472281687, -0.0398565605, 0.2194864154, -0.2687345147, 0.0021313876, -0.1677853167, 0.2920700014, -0.1178477257, -0.1241071299, 0.1106202453, 0.0561546236, 0.1308437288, -0.0329673514, -0.0878704935, 0.1091496646, -0.2001209706, 0.1028264314, -0.0033607127, -0.4237514436, 0.2443594337, -0.0903940126, 0.1468153745, -0.1550666094, 0.2341227084, -0.0851483345, 0.0086562047, -0.1469507962, -0.2140770257, 0.4706176221, -0.0491956994, 0.9145435691, -0.0148696760, -0.4081351757, -0.1900585443, 0.6225032806, -0.2314946800, 0.1987475604, -0.0087464293, 0.1810036749, 0.0662208498, -0.0571101643, -0.1427347064, -0.2628026307, 0.0481084846, 0.1333962381, -0.0070577301, -0.0589415543, 0.2284509540, -0.1347919106, -0.0379062966, -0.5109496117, -0.2476568520, 0.0421138741, -0.7659012079, -0.1201610640, -0.0543983467, 0.0051594512, -0.0998497978, -0.1641348302, 0.6326205134, 0.3225562572, 0.0744858235, -0.3673869967, 0.3562695980, -0.3046873808, 0.3889597654, -0.0183987897, 0.1487833709, -0.1067385525, -0.1777413338, -0.0977661237, 0.3612046242, -0.0419270359, 0.1414546967, -0.2463935614, -0.1479760557, 0.3688623905, -0.3176917434, 0.1331867129, 0.0008359454, 0.0417344198, 0.0922081247, 0.2132833004, 0.0360987894, 0.1631269604, -0.0037249832, -0.0202361252, -0.0915976018, -0.0521224514, 0.0449195094, 0.0205997769, -0.0807093829, -0.1517924964, -0.0192061160, 0.0387714878, -0.3590365648, -0.5913646817, -0.0105848592, -0.1609771252, 0.0624378696, -0.1657189429, 0.2798919082, 0.1981664300, -0.0337522700, 0.1749914587, 0.2966427505, -0.3978865445, -0.0943602249, -0.3794783056, -0.0509351566, 0.4491964281, -1.0295146704, 0.0021791498, -0.3120728731, -0.0541041642, 0.0249937475, -0.2426627427, 0.0983756408, -0.0984073058, -0.0110699134, -0.0425803065, 0.3264342844, 0.0842044726, -0.0209401269, 0.1686147600, -0.1224739775, -0.0303507168, 0.4203590751, -0.0473949276, 0.1644157171, 0.1874209344, -0.1497923881, -0.0924979150, -0.0678172559, -0.0126918145, 0.0361110233, -0.1018870398, -0.4325703681, -0.0818699524, -0.0064537008, -0.1722712964, -0.1233960912, -0.1358209550, -0.3057990968, 0.1001656726, -0.0593876019, -0.0520404540, 0.4316491187, -0.0114027914, 0.1453690976, 0.0330918431, 0.1321366280, -0.2026278079, -0.1094941273, 0.0204359703, -0.2254309207, -0.4399766624, -0.1218114793, 0.6710037589, -0.0195739120, 0.4300048351, -0.0362036563, 0.8279018998, -0.1862587780, 0.3154571950, 0.1449225098, 0.4271501601, -0.2379464954, -0.1905702800, 0.0468309820, -0.3169434965, -0.1015436873, -0.2426823676, -0.0727422759, -0.0641517118, 0.3589820862, 0.0049042315, -0.2066959441, -0.1597140878, -0.3125495315, -0.0424207449, -0.4044098854, -0.3883083761, 0.1079282686, -0.0037288670, 0.1208822727, 0.1107045412, 0.0447811335, -0.1906338185, -0.1262396723, -0.4746172130, 0.5445828438, -0.1437191069, 0.5983117819, 0.0158146918, 0.2034875304, -0.0003110005, 0.0774682835, -0.1087506711, 0.2333737910, 0.1437305063, -0.0433081314, -0.2329112589, -0.0676655173, -0.0313919336, -0.7174655795, 0.5080920458, -0.1142523885, 0.1296406537, -0.1243770197, 0.0611466691, -0.3064651191, 0.2379468232, 0.1504575312, -0.2358689457, -0.0328413658, 0.0587787144, 0.0285542756, -0.2604087889, -0.0489213355, -0.4772198498, -0.0648013055, -0.1955749840, -0.3063999414, -0.3323698640, -0.0976897553, -0.1079639718, -0.2261919975, -0.0842083320, 0.1667916626, 0.0688597783, -0.0428127721, 0.8226166964, 0.7317847610, -0.2065382749, 0.0502745062, -0.4258714616, -0.0052343649, 0.4090237617, -0.2146041393, -0.0349180996, 0.5532270074, -0.1318475604, 0.0283910185, 0.0712712035, 0.0778006837, -0.0383424126, -0.0918042138, -0.0121954186, -0.6383722425, 0.1275074184, 0.0187293794, -0.1433616430, -0.0683998764, -0.1011518762, 0.4886162281, -0.2596535385, -0.3405675888, 0.5167712569, 0.2442749441, -0.0868519023, 0.4940772951, 0.1779206097, -0.1311900169, 0.1666532755, -0.4364155233, 0.0308697950, -0.0594421402, 0.0472833477, 0.1484250128, 0.0897889361, -1.0073498487, 0.1633916646, 0.1274520010, -0.3745059371, -0.1654898822, 0.0487623215, 0.0987251326, -0.1281796396, -0.2275942266, -0.0380437225, -0.2997085750, -0.1956318170, -0.6668842435, 0.1078788042, 0.2717803121, 0.6745994687, 0.0455323979, -0.2368962914, 0.0624257028, 0.5809355974, -0.0079614706, 0.2759166956, 0.0455754511, 0.3854134977, -0.1972444504, -0.0337983780, -0.0437062532, -0.2232816815, 0.1607264280, -0.1382090598, -0.1872666329, 0.0539155714, 0.5038720369, -0.0988084599, -0.2336594462, -0.1724209338, -0.4141854346, 0.0852358192, -0.1505837888, -0.1008439809, 0.0732706487, -0.1752215326, 0.0349998921, -0.1417105198, -1.1869676113, -0.2373724878, 0.0284608472, -0.4399454594, 0.6293067932, 0.1080570519, -0.1396624148, 0.1607722938, 0.0145577863, 0.0223634299, -0.2194126248, -0.0618981123, 0.1485435367, -0.0545153469, -0.1095273867, -0.2330378592, -0.1138895303, -0.5717713237, -0.5366700888, 0.4481792152, -0.0408422947, -0.0657921135, 0.1457624286, 0.1121217981, 0.0980906263, 0.0435067154, -0.0597128309, 0.0580764711, 0.1335735917, -0.1490706205, -0.0375699773, 0.1042977720, 0.0864289328, 0.4690125585, 0.0249550417, 0.0119210267, -0.6467850208, 0.0910012573, -0.1402842104, 0.1201943085, -0.0223834589, -0.0803727359, -0.3062516153, 0.2681809068, 0.1103011891, -0.5038469434, 0.0785807967, 0.0625144020, -0.0855061486, -0.2570810914, 0.0513749272, 0.5607649088, 0.1906165034, -0.0591547266, -0.0718804523, 0.0013711915, -0.1528202891, -0.0869861171, -0.0569234937, -0.1165979058, -0.0221868958, -0.1332777441, -0.0342160352, 0.0138729038, -0.1080954522, -0.2458827794, -0.1592166275, 0.0578118414, 0.5064213872, -0.0332214609, -0.0761927217, -0.0182459839, 0.4076598585, 0.1440117508, 0.2046512514, -0.0804167688, -0.1618894935, -0.1571995020, -0.0267987903, 0.1027213410, 0.1004764661, -0.0337006934, 0.0741987973, -0.1371778250, -0.4111493528, 0.1695853919, -0.0039826441, -0.2233602107, 0.1339787692, -0.1447219700, -0.0298041888, 0.0017015204, -0.2869965434, 0.0378770344, 0.0348548293, -0.1152809188, 0.3403937221, 0.0761305094, -0.1129277125, 0.2057121396, -0.0786890388, -0.9179175496, 0.1556230187, 0.4083489776, 0.0684048012, 0.1520161033, 0.5411710739, 0.3675850928, -0.0571507327, 0.0800725296, 0.0371669233, -0.4706737697, 0.0004625799, -0.5300781131, 0.0892143324, 0.0204481930, 0.6328950524, -0.2132994980, -0.3529532254, 0.4506374896, -0.2720964253, -0.1336220950, -0.0973157883, -0.1858043075, -0.0747445077, -0.3082694411, 0.1637099683, 0.0022493035, -0.8118402362, 0.1419343650, -0.0810970068, -0.0267492402, 0.3610968292, -0.0941824466, -0.1237151176, -0.1770237982, 0.0511071980, 0.0806535706, 0.0621288940, -0.0573033206, 0.1371241957, -0.2392578423, -0.0514707491, -0.6887974143, 0.0658506304, 0.2862253785, -0.4377412498, -0.0867293254, 0.0701195300, -0.0859104246, -0.1111517325, 0.3167389035, -0.4349035323, -0.3771466017, -0.1313111484, -0.2812449932, -0.0386724435, -0.1253409386, 0.0498392172, 0.0160577055, 0.1112246513, 0.4618227780, 0.1343859434, 0.0075766169, -0.4299298525, 0.2275409549, 0.0659640357, 0.1458930969, -0.0016843508, 0.0361305661, 0.6020000577, 0.3122193813, 0.1352234036, 0.1483509988, 0.4448466003, -0.2037049383, 0.1325149983, -0.2773257196, -0.0969321579, 0.7610868216, -0.3351716101, -0.0707028136, 0.1717896312, 0.1503145248, -0.1551747322, -0.1283660084, -0.0758060738, 0.0169763770, -0.0999950990, -0.1027072668, -0.0092210369, -0.0605811030, 0.0217683576, 0.3507871628, -0.1617440730, -0.0917286277, 0.0740307644, 0.0078833699, 0.0473494567, -0.1378764659, 0.4932927489, -0.1278603524, 0.2317107320, -0.3322995007, -0.0909437835, 0.0688959211, -0.1310168505, -0.1672004014, -0.0217841305, -0.1951183826, -0.0856532678, -0.1392969787, -0.0734675080, -0.0328136533, -0.0745535567, -0.3052220047, -0.3324047327, -0.1624275893, 0.0159390587, -0.1774222255, -0.7369204760, 0.4097634554, -0.1743167341, 0.0567560419, 0.2224516422, -1.2185791731, 0.3580548167, -0.3444879651, 0.1226376593, -0.5160169005, 0.0604692660, 0.4326609075, 0.0870365575, 0.6095426679, -0.2035553753, 0.8517464995, 0.0554014593, -0.1168424785, -0.1887824386, -0.4047856927, -0.1978125274, 0.1074118763, -0.1236965433, 0.1058859751, 0.1816999018, 0.0024795453, -0.3811774850, 0.5823991895, -0.3744064867, 0.0254761223, -0.1790584773, 0.1472325474, -0.0465916134, 0.1510203183, 0.0107093044, 0.0452329665, 0.3624126315, -0.3455999196, -0.0310007241, -0.7635945678, -0.3578580320, 0.2151416689, -0.0852723494, -0.1771096140, -0.0142045347, -0.0755378753, -0.0408035628, -0.0710448027, 0.1304598749, -0.1142696068, 0.0345995724, -0.2995488346, 0.0747013465, 0.6872842312, -0.1881124228, 0.6935805678, 0.1173624620, -0.0373725258, -0.1549004912, -0.1720073819, 0.2309846282, 0.3217239380, -0.1651283950, -0.1664288789, 0.1474121511, 0.0555849411, -0.0046831402, -0.3304600418, 0.0910127684, 0.1573207974, 0.0144676855, 0.0040606237, 0.0550245792, 0.0138116367, -0.1578833908, -0.1764350384, -0.0080731343, -0.1229898110, -0.1486977190, 0.4175704718, 0.0255648494, -0.0262742601, 0.0001102612, -0.5653152466, -0.0315117240, -0.2084793746, -0.0598545410, 1.0187382698, 0.9150314927, 0.1451515257, 0.0781564340, 0.0580331236, -0.1272354573, -0.0614820160, -0.0291508678, 0.0301576816, 0.0227846783, 0.1548768580, -0.5162395239, 0.0112259751, -0.0356812887, 0.1436967105, 0.1198065430, -0.0038566131, -0.1599971354, 0.0820671096, -0.3132631481, -0.3237985969, 0.6284348369, -0.0607758686, 0.1784610599, -0.1319326013, -0.1135281324, 0.0299915150, -0.3627695143, 0.1013565734, -0.1459425241, -0.1879302263, 0.1442089528, 0.1266563833, 0.0853611976, -0.1009636149, -0.0338180177, -0.1766299605, -0.4641579390, -0.1956129223, 0.0415167622, -0.0506124422, 0.9447268844, 0.1587146968, -0.0049520941, 0.1154143810, -0.5766964555, -0.2515896559, 0.4206947386, -0.2802754045, -0.0462132208, -0.7780688405, -0.0403873399, 0.1588064730, -0.2064518631, -0.5145250559, 0.3103353679, 0.5244673491, -0.0042674569, -0.0288245603, 0.0010870062, 0.2193282396, -0.0640752614, -0.0381876081, -0.0420012251, -0.0480575636, 0.3090530336, -0.0741221309, -0.2439686954, 0.4899125695, -0.3977147639, 0.0523052886, 0.2631525397, 0.6210265756, -0.1352144629, 0.4581808150, 0.0466270410, -0.1319211572, 0.0128098959, -0.0063833874, 0.0450324565, -0.4647772908, -0.1245782077, 0.3517739773, -0.7954697013, 0.1615858227, -0.1907744557, 0.0830771551, 0.0138714146, 0.4150279462, -0.1286382079, -0.0323390178, -0.0434075221, -0.3651864529, 0.0747525916, -0.7904636860, -0.0365806781, 0.1894717366, 0.0719972625, -0.1377900541, 0.1576683074, -0.0553175397, 0.4091686904, 0.0519301482, -0.0921390355, -0.0120213283, -0.0956685841, -0.1457105428, 0.0874235556, -0.1562513709, 0.1361987293, 0.1797540933, 0.0462059453, 0.0179719646, -0.3842063546, 0.7335361838, -0.1149783432, -0.0090479301, -0.1848792732, -0.0351541266, -0.2088930607, 0.4043456018, -0.1234299690, 0.2358542085, -0.4820947945, -0.8838097453, 0.0029589087, -0.0378351994, -0.0509439930, 0.4445470870, -0.4255959988, 0.1390908360, 0.1598855853, -0.1998340338, -0.0260623842, 0.0921126455, -0.0798386559, -0.0731958970, 0.1027204990, 0.1014695019, -0.1316101104, -0.1276583374, -0.1986341178, 0.2461359650, -0.1059704795, -0.1175741479, -0.2765099704, -0.0476755351, -0.3508082628, -0.0854059756, 0.6629364491, 0.0554593056, 0.2281712443, -0.0954913124, -0.0926745608, 0.0485069640, -0.1254273206, -0.1669749469, -0.0569723025, 0.1025339663, 0.0125376722, 0.1089370996, -0.1382051706, -0.0284007955, -0.0818575621, -0.7992898226, 0.1351016164, 0.0322210863, -0.1508566439, 0.0812345222, -0.0638973489, 0.1384855211, -0.0708349943, -0.1520891786, -0.2808072865, 0.1441282332, 0.1124863327, -0.6136223078, 0.0657083690, -0.1496217698, 0.0659965575, 0.0606912263, -0.2525644302, -0.3302444220, -0.2891300917, 0.3724632859, 0.1584865600, -0.0236851629, -0.1725354791, 0.3771813810, -0.1893386990, -0.5338704586, -0.0587140508, -0.0548401028, -0.1001884341, 0.0384611748, -0.1641691476, 0.6896944046, -0.3673187792, -0.0724479184, -0.1048801318, -0.2357715070, 0.1269163638, 0.3547288477, -0.1142476201, -0.0415100046, -0.8985081911, 0.7049595714, -0.1688470840, 0.2852056623, -0.4185803235, 0.8194711804, -0.3649545312, -0.1600562036, -0.0229584500, 0.0440460034, -0.2606211007, 0.0716714188, 0.1078701243, -0.0608877353, -0.0972998962, -0.3095670044, -0.1316350698, -0.4879674911, -0.3580566645, 0.1121637449, -0.0098005030, -0.1281590760, -0.1013738960, -0.5520519614, 0.3640522659, -0.0391679555, -0.1454518139, 0.1809045821, -0.1514204293, 0.1261467338, -0.1380149126, -0.0855730921, 0.1487641037, 0.3238289058, -0.1470173448, -0.0965290070, -0.3518109620, 0.7558978796, -0.0436000004, -0.1711143702, 0.1202953681, -0.1394020766, 0.0696067661, 0.0394998454, 0.0413992107, 0.1403021663, 0.0452775434, 0.0156965870, -0.0812382624, 0.3184711039, -0.0818461850, 0.3983735144, -0.4427377880, 0.1309751123, -0.0593401827, -0.2342603207, 0.1269126087, 0.2010208815, -0.0754630268, -0.0127400849, 0.1193532646, 0.0878544003, 0.1846498102, -0.0446987897, 0.0109214913, 0.6104915738, 0.0738129765, -0.1139668599, -0.3941620588, -0.1516608745, -0.1665980220, 0.3145927787, 0.3906067014, -0.1620458663, 0.4385195673, -0.2487819493, 0.0330445431, -0.1115616336, 0.0486138724, 0.1273767501, -0.0464918055, 0.0313162506, -0.1275019795, -0.1234974265, -0.2655456960, -0.1077344194, -0.1079992801, -0.8236512542, -0.0758003816, 0.1045427024, -0.0637679771, 0.0780015886, 0.2586816251, 0.2111990303, 0.0721210688, -0.0066953055, 0.1301464885, 0.1256411821, 0.0782974362, -0.5100058317, -0.2061306238, 0.2850091159, 0.0307167247, -0.2779321969, 0.0390763693, -0.1361585855, 0.3609037995, -0.2733152807, -0.1405893415, -0.0097676730, 0.0262208860, 0.1613984257, 0.0824073032, -0.3707996905, 0.0615174547, -0.0556149967, 0.0659475848, 0.0765142292, -0.1670863926, 0.3005163372, -0.1105488390, -0.1421674341, -0.0980604365, -0.5253665447, -0.1885792166, -0.7507640719, -0.1053559482, 0.0827636793, -0.2309671640, -0.0167602412, -0.0932860970, -0.1159180105, -0.4982028008, 0.7922722101, -0.1558281183, -0.2483859956, -0.1676273048, -0.1243692562, 0.0481921099, 0.2519874573, -0.1107305437, -0.0595440231, -0.0923824161, -0.1931959838, -0.0192212071, -0.6124003530, -0.0315390378, -0.0096892146, 0.1307061762, -0.1305599809, 0.1140115410, 0.3133824766, 0.3262189627, -0.0247767512, -0.1045621708, -0.0657583773, 0.0960262492, 0.0059094639, -0.0473293550, 0.0110977432, 0.1126751006, 0.4513735473, -0.0400284380, 0.0046809153, -0.3450252712, 0.5878245831, 0.0703913867, 0.1098112166, 0.1185411066, -0.1167862415, -0.1552500278, 0.2375682890, -0.1513068676, 0.2089616060, -0.2347316593, 0.2523956597, -0.1238255650, 0.2272756845, 0.0268591736, 0.2543047667, 0.1277441829, -0.0819126144, -0.1531009525, 0.0653500408, -0.0492031723, -0.0128673650, -0.0448943079, 0.0882756263, -0.0392964706, -0.1393616647, 0.2834608853, -0.0565284230, -0.0683612749, 0.6792697310, 0.0379559398, -0.0465060249, -0.5559906960, -0.1186622605, -0.1571833789, 0.2594009340, 0.0388892852, -0.0119221061, 0.2559435964, -0.1614231914, -0.0343828052, 0.0693158284, -0.0377699211, 0.1040249690, 0.0370563604, -0.0220891796, -0.1183894724, 0.1264229566, -0.0123396600, -0.0699216127, -0.0524736978, 0.0569520146, -0.0235901605, 0.0454222076, -0.0287996624, -0.1491102427, 0.4339746535, -0.2933239639, -0.1372308731, 0.0306561906, -0.2399706244, -0.5951861143, -0.0011807344, -0.2781819701, -0.0188930649, -0.0789444223, 0.0312599614, -0.1253926158, -0.0557456836, 0.1840490699, 0.3728478253, -0.2985568941, 0.0292375963, -0.0367190354, -0.1489915401, 0.3790901005, -0.1667044163, -0.0688515827, 0.0714688599, -0.0605896674, -0.1577918679, -0.0046217069, -0.0199824981, -0.4007025659, 0.0307048913, -0.1833401173, -0.3012323678, 0.0318465196, -0.0320292264, 0.5463619232, 0.0922452509, -0.0549867861, 0.3093003333, -0.2514799833, -0.0962249786, 0.4171720147, -0.5677796006, 0.6905763149, -0.6166383624, -0.1689869910, -0.0075029866, 0.0240530092, -0.1061730310, 0.4389963746, -0.2441133708, 0.1387643069, -0.0980616361, -0.2541497648, 0.0704634264, 0.1062534973, 0.1557706296, -0.3666000366, 0.1243951693, 0.1029433385, -0.1110819280, 0.0603202581, 0.7799199820, 0.3965947926, 0.1142933220, 0.2566419840, 0.1128803268, -0.0997174084, 0.0894593820, 0.7703410983, 0.0515078455, -0.0272968672, -0.0834885389, -0.0679462329, -0.3128949702, -0.3435190618, 0.0572338551, 0.1297452003, 0.1875052303, -0.0985461026, -0.0787583590, 0.2856650651, 0.0111739142, 0.0865998492, 0.0209157020, 0.1440749019, -0.0398247167, 0.0371818766, 0.0954739824, -0.2378362119, -0.3891648650, 0.0948111266, -0.3430086970, -0.2184344381, 0.1578459293, 0.1175928712, -0.0027561944, -0.0628760308, -0.0326827727, 0.0220950488, -0.3819707930, -0.1090617329, -0.0792329013, 0.2602959871, 0.0141421407, 0.0896289274, -0.2447865456, 0.0836324394, -0.0576865636, -0.1900151670, 0.2038325816, -0.0716253147, 0.0952836648, -0.0208755583, 0.1339389682, -0.0886450633, -0.1518726200, -0.1688469797, -0.0787940621, -0.1394294649, -0.0686543807, 0.0553427972, -0.6117961407, -0.2697585821, -0.0306694154, -0.0698033050, -0.0179810319, 0.0168260876, -0.0056847264, -0.0077987267, 0.0841683820, -0.3389906883, -0.2808914483, 0.0087512583, 0.5233231783, -0.2576731145, -0.5142067671, -0.1584373415, -0.1000366434, -0.5698689222, -0.2227197587, -0.0069008865, -0.0354525819, 0.8106713295, -0.1686781496, 0.0245359764, 0.0818068907, -0.1294287741, -0.0188587066, 0.6410291791, -0.0868369713, -0.4433424473, 0.1250745207, -0.0655195788, -0.0352011621, -0.0968180448, -0.2175152600, -0.3037752509, 0.5044973493, -0.2500039041, -0.3666894436, -0.5284562111, -0.0397593006, 0.4212839305, -0.1346806288, -0.1502472311, -0.0900964215, 0.0808647722, -0.0276429430, 0.3315518796, -0.1021152735, 0.8129925728, -0.2614445686, -0.1293304861, -0.0793680251, 0.0524269529, -0.0119809173, -0.0223688539, -0.1326213181, 0.1554439962, 0.1045039669, -0.4295853376, -0.1798911840, -0.2607071102, 0.5102747083, -0.3248875737, -0.1614011973, 0.0246707685, -0.1551500410, 0.7435474396, 0.1575868428, 0.0344224274, 0.0642202422, -0.1393628567, -0.0958539620, -0.0945783183, 0.0855154917, 0.8900582194, 0.2572698295, -0.1291970611, -0.0747063607, 0.1077797785, -0.2408558726, 0.0635639131, 0.0371910930, -0.1823769808, 0.1164035797, -0.1242474541, -0.2286334485, -0.0331224985, 0.0657103956, 0.5672729611, -0.6196531057, 0.1971873194, -0.1290295124, 0.4169750214, 0.0059047542, -0.0822531953, -0.2995477915, -0.1297433525, 0.0405875854, -0.2435328960, -0.0209203213, -0.2158600539, -0.2170229852, 0.0526884869, 0.0872864649, -0.0986932293, 0.1111428216, -0.1461249143, 0.0151044112, 0.1403145790, -0.1518733352, 0.0975160822, -0.7285873890, 0.0749212056, 0.0765483528, -0.3301280737, -0.1795873344, -0.0671495795, 0.2503239214, 0.1497918367, 0.1276648045, -0.0067185471, -0.1594723612, 0.0920581371, -0.0526122935, 0.1010990068, -0.0624794215, -0.0681865066, 0.0646875054, -0.0082821194, -0.0593446121, 0.3210741580, 0.6041719913, 0.0893257037, -0.1462558210, -0.0012368746, -0.0173081700, 0.0365120918, 0.1102715358, -0.0133464895, 0.4840608537, 0.2425829023, -0.3583675027, -0.3056128919, -0.0328598954, 0.0996180624, -0.2091764957, 0.3098020554, 0.1674591005, -0.0909336954, 0.7474519014, -0.3782698810, -0.1817854792, -0.1516871005, 0.1228319854, 0.7839233875, 0.0568522252, 0.3967354000, 0.0376950540, -0.0544659868, 0.0034128928, 0.0005099872, -0.2117927670, -0.5639351606, 0.4150817394, -0.2200493813, -0.1312393546, -0.3317307830, -0.1433591396, -0.9918533564, 0.0640151128, -0.0137619115, -0.2265951335, 0.3082595468, -0.0874380320, 0.1925739348, -0.0356748141, 0.4333423972, 0.4066697955, -0.0861663297, 0.0797607303, -0.0908660665, -0.1390326768, 0.0520240180, -0.2445911318, -0.1747770756, 0.0267215166, -0.2614053488, 0.0789906606, -0.0442990921, 0.3652763665, -0.2137325704, -0.1566025615, -0.0128741581, -0.1459954232, -0.3473321795, 0.2557984591, 0.1386484802, -0.0911658704, -0.0958616436, -0.1631656289, -0.2544181943, 0.0675802901, 0.6934440732, 0.1780856103, -0.2151039988, -0.1128080264, -0.0448265895, -0.2364135981, -0.4309520125, -0.0833705887, -0.2006654590, -0.0967577770, -0.0645298660, -0.1275593191, -0.3423372507, 0.0460361168, 0.2421834171, -0.3718054295, 0.5265378356, -0.1363358200, 0.2622720301, 0.0083095217, -0.0508324243, 0.6312593222, 0.0170229394, -0.2675334811, 0.1402800381, -0.0275862068, 0.0134846997, -0.1019952744, 0.0084107984, 0.0492373407, -0.1367251724, -0.0440965891, 0.0901794583, -0.1640751809, 0.1574555933, 0.0431168675, 0.1115626618, -0.3576497436, 0.0739600658, 0.2381108403, -0.1848115325, -0.1448424309, 0.0370020568, 0.0445376709, 0.1525898427, -0.0251243375, 0.0510955490, 0.2259630859, -0.1476169080, -0.0824581385, 0.1496479809, -0.0763039216, 0.1397495866, -0.3022797406, -0.2764824331, -0.0015930173, -0.0092149591, 0.5013816357, -0.1407874078, -0.1583382785, 0.1216121167, -0.4447801709, -0.0570768937, 0.0979935452, -0.2037818283, 0.2098961473, -0.1231627315, -0.3697182238, -0.1036504731, 0.0268210620, 0.5527769923, -0.1161688641, 0.6070280075, 0.1984376609, -0.2210085839, -0.7328070998, -0.3514925838, -0.1287488341, -0.0336566083, 0.1162808910, 0.2975935340, -0.2120375782, 0.5841948986, -0.0029405735, -0.0774961263, -0.0095413420, 0.1657735705, -0.2941046655, -0.6057837605, 0.6068584323, 0.0783770606, -0.4461596310, -0.1456314027, 0.0756764188, -0.0964653045, 0.0428075716, -0.1188513935, -0.8322968483, -0.2521935999, 0.0068544289, 0.1639411300, 0.0274252649, 0.2855983675, 0.5031943321, 0.1738979667, -0.1016611755, 0.0253321137, -0.0461579040, -0.4132239223, -0.3302816749, 0.0461114198, 0.0147481058, -0.2350205779, -0.0876640603, 0.3822259009, 0.7195098400, 0.0684387162, -0.0930270776, -0.0096642477, 0.0667875111, 0.0954818949, -0.4017246664, -0.1317323148, 0.1235148162, -0.1095973924, -0.1228769943, -0.1873621494, -0.1483549923, 0.2686643898, 0.2964864373, 0.1446215361, -0.0144190248, -0.0019703929, -0.3527380526, -0.3994675577, 0.1922842711, 0.0996832103, -0.0639753565, 0.0615751818, -0.3666831255, -0.3999660015, 0.0222333875, -0.1433303952, 0.0212546382, 0.5554891229, -0.1272216141, 0.1057982743, -0.1707513779, -0.2661596537, 0.3943060338, 0.0404109806, -0.0822965875, 0.0902156383, -0.0678621531, 0.0145012280, -0.2291261256, -0.1054684967, 0.0773607343, -0.1468879730, -0.4196517467, -0.0666347966, 0.1493274868, -0.2600192726, 0.0845422447, -0.1111595258, -0.0085068978, 0.0115240039, -0.3199753761, -0.2632894516, 0.0659476444, -0.0908081681, 0.2036425620, 0.0064214026, -0.0915913060, -0.0250858050, 0.6277309656, -0.0896490067, 0.0933840051, -0.0751420110, 0.0506863445, -0.1499041617, 0.2598836124, -0.1903097779, -0.0446842685, 0.2372394502, 0.2275918275, -0.0632277131, -0.0511754453, -0.0013675847, -0.5842744112, 0.1193455085, -0.2334223688, 0.0066267578, 0.4545811415, -0.0756299049, 0.1490563750, -0.1345557570, -0.1431933790, -0.2381640673, -0.2418725640, 0.6720269322, 0.1838135421, 0.0010210411, -0.3361319602, -0.3354583383, -0.1872475296, -0.1470870078, -0.0818521976, 0.2753302157, -0.1337914318, 0.3133959174, 0.0359863378, -0.2032169402, -0.0723147541, -0.1004747599, -0.3841518462, 0.0095255543, 0.5880757570, -0.0057433285, 0.1176682934, -0.2243734747, -0.0782993883, -0.0471597090, -0.1787815243, 0.0248043928, 0.0801760852, -0.3690735102, -0.0897455290, -0.0246294197, 0.0916612223, -0.1302576363, 0.8959800601, 0.3506807685, -0.0273633264, -0.1481505632, 0.0595096350, -0.2152858377, 0.0332015865, 0.0326760337, -0.0575133674, -0.2052005082, 0.1364566684, -0.4768540263, 0.1901092678, 0.2044367194, -0.2493673414, -0.1185594723, -0.0275093783, -0.4018281400, -0.4067016542, -0.2483485192, 0.0560327061, -0.0496743061, -0.0212849043, -0.0299247056, 0.0074006766, 0.1724954098, 0.0984693095, 0.3818064332, 0.1428539157, -0.1632125527, -0.4172207117, -0.2092084438, 0.0945318714, -0.2040155381, -0.0621794388, 0.2100751102, 0.1453855783, -0.5647056103, -0.0254830848, -0.1347165853, -0.9720152020, 0.4441270232, 0.1484880000, 0.1232195422, 0.1507416368, -0.1158991382, -0.2089952379, -0.1119388565, 0.2675858438, 0.0465408377, -0.0412494838, -0.2108754814, -0.0615393072, 0.0555213764, -0.0888969675, 0.0390185080, 0.6245554686, 0.0276414938, 0.0744128451, -0.1056269035, 0.0342694372, -0.0493665412, 0.0915027410, 0.1624928117, 0.0814591348, -0.1083241105, -0.2695197165, 0.0078005344, -0.1309926659, -0.1865056902, -0.0132831465, 0.0251247250, 0.9468987584, -0.0887084156, -0.0722854733, 0.0932073519, 0.0677831322, -0.0336985774, 0.3497591317, -0.2369093746, -0.0181840807, -0.0629258230, 0.0085213343, -0.0212754477, -0.2148318738, 0.0467755608, 0.2895493805, -0.1878802478, 0.0785077736, -0.1571689099, -0.1832577586, -0.0908474028, 0.4153226912, -0.1640990824, 0.0981872231, -0.0650541559, 0.0438951701, 0.3205676079, -0.1733056754, -0.0808797181, 0.0154740969, -0.6441776156, -0.0863112137, 0.0175079182, -0.2145853043, 0.2721654475, 0.0421853773, 0.2441702634, -0.1443324536, 0.1153776497, -0.4138048291, -0.0647926629, 0.0197881293, -0.5350184441, 0.4788522720, 0.0888180658, 0.3978332877, 0.0653912127, 0.1446969062, 0.1970092803, 0.0437184088, 0.0952382535, -0.1538648605, -0.1953976303, -0.0708367005, -0.0961560085, 0.4888844788, -0.2162364423, 0.7513957024, 0.2984533310, 0.0248950515, 0.0552487187, 0.0109057724, -0.1432940364, -0.0731795952, -0.1217024922, -0.0688842013, -0.1965842694, 0.0577102378, 0.0615182556, -0.0319076627, -0.0477790385, -0.2536449134, 0.1049904227, 0.1161492616, 0.0483129174, -0.2142435312, -0.2140473276, -0.0285232030, -0.1284516603, 0.0513307005, -0.0692676455, 0.0217144471, 0.0478881486, 0.0896290988, 0.0360015519, -0.0585276373, 0.0679171532, -0.0392314196, 0.1043298542, -0.0920674056, -0.2127383500, -0.0403520353, 0.0537510440, 0.2205074131, -0.2901237607, 0.0353201404, -0.1136048362, -0.1154718995, 0.5434459448, -0.0623168573, 0.3972114623, -0.0175489187, -0.2050426900, -0.4775540531, -0.1736132801, -0.1534311324, 0.1007028446, -0.1268274188, -0.0668522343, -0.0130259860, 0.0570530109, -0.1549103111, -0.0527428202, -0.3835075200, 0.0825250447, -0.0280328766, -0.3901597857, -0.0048636943, 0.0237810109, -0.0488903858, 0.1322631538, -0.3671823740, -0.2413663864, 0.0586716235, 0.1058207601, 0.1007568389, -0.1379158944, 0.0902273580, -0.0947398096, 0.7197457552, -0.1432050914, 0.0298438761, 0.0047717267, 0.1668823957, -0.0177082308, 0.6124730110, 0.1120356023, -0.1214166880, 0.1609011292, -0.2524921000, -0.2720734179, 0.0030550708, -0.0571355931, -0.7491179705, -0.0778949708, 0.0005674937, -0.2273047119, -0.1621804833, 0.2086748183, 0.6440020800, -0.2124752253, -0.0519751012, -0.1089491174, -0.1428113878, 0.4104368091, -0.0669294000, 0.0119778458, 0.2602118850, 0.0105800452, 0.0926513076, 0.0390752442, 0.0127497735, 0.2077981383, 0.0872196853, -0.5724143386, -0.0670238435, 0.1563925147, 0.0894077867, 0.0075098393, 0.0254018269, 0.2343635410, 0.3105674088, 0.0675352290, 0.0121914158, 0.2175742388, -0.0088269450, 0.3932850361, -0.0772367343, -0.1437239349, 0.6247169375, 0.4870717525, -0.0288912710, 0.4812274277, 0.3128677011, -0.2407495975, 0.0300574526, 0.2598892450, 0.0337589681, 0.1202910319, 0.2446934879, 0.1420251429, -0.2360698581, -0.1875321865, 0.1433720440, -0.1323393732, -0.0182496663, -0.4643552303, 0.5305359960, 0.2731494009, -0.0385144912, 0.0863721445, 0.0075383326, 0.2124492824, -0.4413313270, -0.4209266603, -0.0992531925, -0.1083830446, -0.0221389942, 0.1245936975, -0.1554693580, -0.6054580808, 0.0506043434, 0.6412959099, 0.1138749868, -0.1175020710, -0.2488891035, 0.0325499102, -0.1439868659, -0.2566006482, 0.0357223041, 0.1399339586, 0.1225717813, -0.1110541970, -0.1323490143, 0.4991356730, -0.2293338776, 0.0673472956, 0.1615892798, 0.1432622075, 0.1188385412, -0.3975052238, -0.2814066410, 0.1585613042, 0.4941940308, 0.0070206807, 0.1129422039, -0.2621707022, -0.0307067502, 0.1112601683, -0.0325304419, -0.0000122373, 0.2464722544, -0.0303008389, -0.1638938487, -0.0241221562, 0.1413199753, 0.1197534725, -0.1593871266, -0.1111958250, -0.1748049110, 0.4974253774, -0.2001347095, -0.1600558013, 0.0846178681, -0.1222718582, -0.1157935336, -0.1578717679, 0.5932867527, -0.2120749652, -0.1208191663, 0.0242987555, 0.0543983951, 0.1323575675, 0.7034111023, -0.1078389138, -0.0493083633, 0.1555891782, 0.3149254620, -0.0318817422, -0.1823502630, -0.1312452406, -0.7114086151, -0.0210957061, -0.2292763144, 0.0857215673, -0.2704196870, 0.0120024737, 0.2311438620, -0.4483323693, 0.1605128050, -0.5383643508, 0.1268327534, 0.1668521911, 0.1342183053, 0.1698699296, -0.2388727218, 0.0749988630, -0.0415174589, 0.1150565967, -0.1804566830, 0.2269910127, -0.1594724357, -0.2075728476, 0.0717369244, -0.0811712593, -0.4589789510, 0.1174819916, -0.2304543108, 0.1843768805, 0.1443869174, 0.1673653424, 0.5542372465, 0.2555784285, -0.1750470549, -0.3017447889, 0.1238819659, 0.0080474978, 0.4692688882, 0.0904200003, -0.0084212702, -0.3481260836, 0.2506560981, -0.0644448549, -0.2264354974, -0.0753823742, 0.0819436312, -0.0435956605, 0.0981557295, -0.0715112835, 0.0355922244, 0.0891838670, 0.0532401092, -0.1983837634, -0.1775427312, -0.1531701684, 0.0304796826, 0.2475739419, -0.0164913852, -0.1893593371, -0.1090858355, 0.1985358745, -0.1333680004, -0.2128228396, -0.0858659893, -0.0491893254, 0.0075205253, -0.1305743456, -0.0943865553, -0.3642469645, -0.0064428309, 0.4429814816, 0.1406249255, -0.0493267886, -0.2465461791, -0.2171264142, 0.0832814723, -0.0618377924, 0.1259076744, 0.0960108861, -0.0902088657, -0.4321810007, -0.1514836699, -0.3860921860, -0.4169980884, -0.2333942354, 0.1468779892, -0.2307306230, 0.1337159723, 0.1864984035, 0.0862413496, 0.0554107465, 0.2157392353, -0.1572258472, 0.0689776242, 0.0078197485, 0.0510941222, -0.1841836125, 0.0997871161, 0.0478818454, -0.3143829405, -0.1445769519, -0.1786510944, 0.0078089880, -0.0870476067, -0.1245080158, -0.0488968939, 0.0702680051, 0.0061647799, -0.1533417553, -0.1851713955, 0.0048831552, 0.0533821434, -0.1606697589, -0.0159215480, 0.0625891536, 0.3236124218, -0.0798645765, -0.0207654182, 0.0103291916, -0.0891624913, 0.1418947726, -0.4531565011, 0.0265389197, -0.0805218369, 0.0807164982, -0.2917379737, -0.0102985669, -0.1381506473, -0.1744974405, 0.5005652905, 0.2228225321, -0.1928351521, -0.0251994375, -0.5377240777, 0.6028273106, 0.1876257956, 0.2512716353, 0.1321662515, -0.1714882702, -0.0255830698, 0.1309607923, -0.1020273417, 0.4717627764, 0.4664496481, 0.1092459708, -0.0717197135, 0.0697173476, -0.0649978593, 0.1814434081, -0.1253993660, -0.1778590381, -0.0199649688, 0.0458469205, -0.1968328506, 0.1360223144, 0.0160040185, 0.7179419994, -0.0934233144, 0.1797744185, 0.2984713912, 0.3935288787, 0.1233660579, -0.3379137218, -0.0574744716, 0.1103537381, 0.3545084894, -0.2704422474, 0.0440885387, -0.7825965285, -0.2991211414, -0.0474150740, -0.0913945884, -0.0015065956, 0.0283771064, -0.0223728847, -0.0265098847, 0.1237682551, 0.0404296964, 0.1742710024, -0.0302446131, -0.2898579836, 0.1035159379, -0.6712278724, 0.2765908241, -0.1476037800, 0.0154584488, 0.1045039296, -0.0794076920, 0.2360385060, -0.3456918895, 0.0984659865, 0.1008205712, -0.1609428525, -0.1192616895, -0.0598871000, -0.0421130024, -0.8159579635, -0.0940724239, -0.2622040212, -0.1148883998, 0.1013927609, 0.1305989772, -0.1451961398, 0.1159496456, -0.1679286510, 0.1322967559, -0.0814001262, 0.0562688746, 0.1824432760, 0.0169668309, 0.0949436799, -0.0929634273, -0.3893707097, -0.0957950130, -0.1001045331, -0.1119044274, -0.3946758211, 0.3367688656, -0.0170310829, -0.1296890229, -0.0183503907, -0.0941024497, -0.1151897684, 0.1358231008, -0.1843582392, -0.0853751972, -0.1285301447, -0.2904256582, -0.0809472650, -0.0223702714, -0.0938925594, -0.1334230900, -0.0211621281, 0.1437781006, 0.0017257091, -0.0820986405, -0.2860674858, 0.0539829098, -0.0000513196, -0.0042187134, 0.0631977469, -0.1184282973, -0.0333568864, 0.2144051194, 0.0017362781, 0.0808573663, -0.0322514437, -0.0189465638, -0.0883448347, 0.2527406216, 0.0211638287, -0.0649963915, 0.4222979248, -0.2099977285, 0.0356200151, -0.0720009133, 0.0342140719, 0.1270727068, 0.4451919794, 0.1002897024, 0.0113218185, -0.7821039557, 0.6102907062, 0.1974270940, -0.2588536441, 0.0240965765, -0.0736872926, 0.0023269616, 0.2612628639, -0.2781486809, 0.5165649056, 0.0147065865, -0.1717876941, -0.0518565997, -0.1295467466, -0.3048234582, 0.1209971309, 0.0925096422, -0.7133681774, 0.0686485395, -0.0517844707, -0.1894233823, -0.1059788764, -0.0254045781, -0.0358629115, 0.2190811932, 0.1653004140, 0.2095052004, 0.3895782828, 0.1098382398, -0.1316955537, -0.1575278938, -0.1782825142, -0.3071102798, 0.0197855365, 0.0066581285, -0.2098322362, 0.0168464296, 0.1355665326, -0.6157947779, -0.2815393507, -0.1355485469, 0.0641257167, -0.0853990763, -0.0510377288, 0.0910004526, 0.1166285276, -0.0202872790, -0.3009125888, -0.1413602829, -0.4065250754, -0.0296172425, 0.4505397081, -0.1730271578, 0.1031415612, -0.1505021453, 0.4254882336, -0.2146311551, 0.5437859297, -0.0076496899, 0.0534928702, -0.0932255760, -0.2228628248, -0.0645220727, -0.5056316257, 0.0131883761, -0.5243628025, 0.1008951962, 0.0655494779, 0.2790994048, -0.2137362957, -0.0979280025, 0.0102644069, -0.2163600624, 0.1061809883, 1.0069611073, -0.3734420240, -0.1720169485, -0.3661824763, 0.6987242699, -0.3487309813, -0.0939062014, -0.4418682754, -0.1830029041, 0.0692069456, 0.2366346717, -0.0900702402, -0.0102025000, 0.0882216096, -0.0088118762, -0.0569035597, 0.0107285054, 0.1086833626, -0.0461561047, 0.1293934584, -0.0206280556, 0.0604531430, -0.0514129587, 0.6226722598, 0.0941814333, -0.0594295785, 0.1497697383, 0.0896345600, 0.0171911996, 0.3776305914, -0.1809036583, -0.1360338032, 0.3184915185, -0.1203450114, -0.0600132532, 0.1193725690, 0.1514542997, -0.0768498108, 0.0669794977, 0.0277346335, -0.0609188341, 0.1448452622, 0.4131392837, 0.1037201509, 0.0418004692, 0.0643708259, 0.3820075989, 0.1701476574, 0.0184753966, -0.0189299006, -0.2914685607, -0.1538812071, -0.0800980926, 0.0473925322, 0.4548518956, 0.4531205893, -0.4606732130, -0.1493771821, 0.0679660589, -1.1491463184, -0.0138967587, -0.4633818567, -0.2387938201, -0.5874280334, -0.1522858590, 0.1055019423, 0.0393195339, 0.0350409076, -0.1949074417, 0.1294673532, -0.0860714018, -0.1087725759, -0.1105259135, -0.0126013923, 0.0902742594, 0.0763265938, 0.0190546755, -0.2587703764, -0.2146691233, 0.2011789232, 0.0263342150, 0.3864252567, 0.0987955183, -0.3058682382, -0.0031709727, 0.1496867537, 0.3991558552, 0.0129789757, -0.1242148355, -0.0500921272, 0.2768355310, -0.0969318897, 0.0935412496, -0.1712569296, -0.0489896312, -0.0681941733, -0.0449200310, -0.0726191700, 0.0323611163, -0.0165351164, -0.0282814428, -0.1203068718, 0.0989468545, -0.5690333247, -0.0001924544, 0.4400181174, -0.0084885331, -0.1096131653, 0.0435165763, -0.2998650968, 0.0978239030, -0.5313664079, -0.1510912776, -0.1195090860, -0.1399061829, -0.1545392871, 0.0732141212, -1.1319918633, 0.0807807148, -0.1235470399, -0.1643316746, -0.0480427369, -0.5853748918, 0.1154724211, -0.0068416833, -0.0944672450, -0.0243966766, -0.0768736675, -0.0708000436, -0.4937361479, 0.0123605700, -0.0255365893, 0.1023872495, -0.5260363817, -0.1535701156, -0.0709677637, -0.1452959329, -0.6160858274, -0.0602761544, -0.0385888964, 0.2384961843, 0.0220334120, 0.0001360625, -0.0725751668, -0.0242544357, -0.1377319545, -0.0493667535, -0.1547946930, -0.1079416201, -0.1448583156, 0.1373136044, 0.1111414805, -0.1003532410, 0.1381678283, 0.2856893539, 0.0508977473, -0.0947969109, 0.4482343793, -0.1646753848, -0.1493539065, -0.0133026773, -0.1242834777, -0.0365290083, -0.0522933677, 0.2558137178, -0.0375693142, 0.0447575524, -0.1421392113, 0.1211948097, -0.0725455433, 0.6224607229, -0.0195719730, 0.0739991143, -0.0054877051, 0.1043651849, -0.0627513379, -0.1063176170, 0.0155946771, 0.1395168304, 0.1945946217, 0.0332962908, -0.1834150106, -0.3759163916, -0.3544467688, 0.4120438993, -0.0582228489, -0.0373099223, 0.1337178797, -0.1283669919, 0.0794041082, -0.0369252898, 0.3530822098, -1.0169334412, -0.4182508886, 0.1078093052, 0.0724066198, -0.1626670212, 0.0008228121, 0.0784044415, 0.1385800242, -0.1582846791, 0.0788062662, 0.1364325434, -0.1255341917, -0.1231850758, -0.1589360386, -0.2342604548, 0.1728826761, 0.5068314672, 0.8678523898, -0.0027084067, 0.0352805220, -0.0167464726, 0.0480678715, -0.0077459095, -0.0482273065, -0.1298595220, 0.1766149700, 0.3360828161, -0.2479287684, -0.1990669668, 0.0017461271, 0.0663313493, -0.0233502872, -0.0583621413, -0.0671375170, 0.1600687057, 0.1784408838, -0.1173986420, -0.1156915724, -0.0259708427, 0.0677799881, -0.2914594412, 0.5678299069, -0.1107820794, -0.1622992009, 0.0016565660, -0.4009971321, -0.1017374396, -0.6117922664, -0.0923859477, 0.0129400920, -0.0937693715, -0.0296696853, -0.1663594097, 0.0050981827, 0.1766875237, 0.1106781512, 0.1394259483, 0.0638376996, -0.3515781462, 0.2837604284, -0.1120795533, -0.0477257706, 0.1022819057, -0.0953420997, 0.7300559878, -0.1786081791, -0.0098108239, -0.0910895020, 0.3562441468, 0.1493764371, -0.0365479887, 0.2075349987, -0.0612941161, 0.1273110807, 0.6870090365, -0.0840756297, 0.0060620112, -0.0526058599, -0.0036465824, 0.0384799056, -0.0898338556, -0.1133509278, 0.0747012943, -0.0303779934, 0.0502600446, 0.0693791360, -0.0366497003, 0.4373131394, 0.0342337042, 0.0138544515, 0.0822209492, -0.1916886866, 0.0327383913, 0.4653590620, -0.2633950710, 0.1066417545, 0.2517157793, 0.1909234673, -0.0034621938, 0.1201535463, -0.1798754930, -0.2084551156, 0.0098024756, 0.0053992006, 0.0432296880, -0.1101893485, 0.0434640907, 0.0203074701, 0.0695959926, 0.4420035779, -0.0481793135, -0.0015025171, 0.0972332284, -0.1276748776, 0.4824209809, 0.2969076037, 0.0095892986, 0.1190502048, 0.9122772217, 0.0114374524, 0.3581991494, -0.0488672256, 0.0791046917, -0.5313013196, -0.0765355825, -0.3988856673, -0.0334386155, -0.8701578379, 0.2587572634, 0.0151631040, -0.0693835467, 0.0320695378, -0.0789677724, -0.1373087764, 0.0484851077, -0.6833819747, 0.0369453989, 0.0408309326, 0.2784498036, -0.1218955070, -0.0829257071, 0.1292771548, -0.1860492378, 0.0643740967, 0.0989778712, 0.3584145010, 0.0861227363, -1.4835515022, 0.1277171820, -0.0283129774, -0.5566078424, 0.0119274072, -0.1511632800, 0.2259305865, 0.3267861307, -0.2171401232, -0.1758075058, -0.1803659350, -0.1911242157, -0.0893945917, 0.1285634786, 0.1988052577, 0.0647727698, -0.0507770702, 0.0461460128, -0.0801299959, 0.0221985858, -0.5882303715, 0.3621360064, 0.5302329063, -0.1623369753, -0.0425353199, -0.1087822244, -0.4059506357, 0.0413831919, 0.0029527873, -0.1535451859, 0.1451082379, -0.0991311818, 0.0421001986, -0.1071130931, -0.2315367907, 0.0451768115, -0.6624960303, -0.1445224285, -0.0093213981, -0.1405844092, -0.3758056760, 0.0093948254, -0.0121353120, 0.0277317911, -0.1356903911, -0.1784230173, -0.1779192537, -0.1402526647, -0.7604957819, 0.0119684208, -0.3501739502, 0.0689384490, -0.1347246766, -0.0516074561, -0.3003303707, 0.1266754121, 0.1339761615, -0.0161580555, 0.1033753157, 0.0869112760, -0.0020735576, 0.0498484299, -0.0842059627, -0.0605465509, -0.1572673768, 0.0480781831, -0.1375752836, 0.1069272310, 0.1775521189, -0.0780614093, -0.1641633809, 0.2230050862, -0.1113928556, -0.0774107650, 0.0195895359, -0.3024698496, 0.0857676864, -0.5952777863, -0.0060437024, -0.1166550592, -0.1928837150, -0.2547470331, -0.0597304218, -0.0606762022, 0.0672608092, 0.0286740698, -0.0928182229, 0.0489505157, -0.0710034147, 0.0947477221, 0.2829437852, -0.3387174606, -0.1759048551, 0.1205620915, -0.1704851091, -0.3960434794, -0.0788457617, -0.2367680520, 0.0831809565, 0.2555048466, 0.3605846167, -0.2151193321, -0.0671761557, -0.0836737603, 0.6815281510, -0.0231809430, -0.1385454386, -0.0966797769, -0.4613432586, -0.7582667470, 0.1326864511, -0.1779658943, 0.0080109267, -0.1695236862, 0.2748936117, -0.0818373188, 0.1017724648, -0.1021544635, 0.0167894494, -0.2275772095, -0.0814937428, 0.0209729820, 0.1435228735, 0.0707799941, -0.0851563886, 0.3261719346, 0.5441566110, -0.1708704084, 0.2841484845, 0.0701226145, -0.0811584145, 0.5653696656, -0.0293747876, 0.1094112322, 0.0578377880, -0.3612860739, 0.0348179489, -0.4270495772, -0.2009370327, -0.0009808721, -0.0251367837, -0.0473945588, 0.2272916734, -0.0367165841, 0.1366481334, -0.0802969560, 0.1758152843, 0.1209552214, -1.3394563198, -0.2161653340, 0.2232320458, -0.1511738598, 0.1188374981, -0.0330935158, 0.0282790437, -0.2058686018, 0.3155958652, 0.1515622139, 0.0811245069, 0.0622373968, -0.0011672183, 0.0798173323, -0.3036205173, -0.1306348592, 0.4595772624, -0.0859779567, 0.1064438149, 0.1100324914, -0.1738424897, -0.0858610868, 0.1361596435, 0.0586832128, -0.1713837534, 0.2847068310, -0.0134456130, 0.0971311256, 0.4223072529, 0.3148726821, -0.4148712754, -0.0708896071, -0.1787764877, 0.0608993247, 0.2106562108, -0.5259243846, -0.0491104536, -0.0093661956, 0.0931958780, 0.0726755708, 0.0850920230, 0.2184993923, -0.1006259844, -0.0765778720, 0.0385099091, -0.3614782691, -0.0723770931, 0.0733761415, 0.0936202779, 0.0774823725, 0.1100112721, 0.0749091804, -0.0744260326, -0.2375694215, -0.1223539785, -0.1186316013, -0.0491336659, -0.1516587734, 0.2333271950, 0.0216209032, 0.0380484909, -0.1433495879, 0.1369937360, -0.1663135141, -0.2305405736, -0.1884622574, -0.1025923043, -0.1380340010, -0.0661126599, -0.1218433380, -0.0758082867, 0.0350463316, 0.1090321317, -0.0637935996, 0.0425329059, 0.8761909008, -0.4987080395, -0.0247194115, -0.1352872998, 0.5271520019, 0.5615118146, -0.0851688236, -0.1623649001, -0.1163304299, -1.4024358988, -0.0111034252, -0.1388319880, 0.1216464937, -0.3407523632, 0.4181988835, -0.1040356532, 0.1198855713, -0.0418037847, 0.0793892667, 0.0335965827, -0.1535461545, -0.1476545185, -0.1134921759, 0.0570330136, -0.4606105089, -0.1494891047, 0.0607834235, -0.3104560673, 0.2113512307, 0.0965541676, -0.0694493502, -0.3360916376, 0.0763267875, -0.6332949996, -0.0438649170, -0.0803647041, -0.2187826782, -0.0665491223, -0.0360637829, -0.1181602776, 0.3266498744, 0.3197757006, -0.1899102181, -0.1489007622, -0.1960808784, 0.1002755910, -0.1893270761, -0.3029734194, -0.3297145665, -0.1576547176, 0.0071259392, 0.2155305594, -0.1389360428, 0.3442485332, -0.1833771914, 0.1291409135, -0.1522517651, -0.0894723386, 0.0277532190, -0.1618879884, -0.3862710297, 0.9000777602, 0.1154555380, -0.0723809898, 0.0720470771, 0.2256898433, -0.1312676668, -0.2622168064, -0.0729487762, -0.0477770306, 0.0686590150, -0.0659911558, 0.0830557495, 0.2680030763, 0.0316032842, 0.0612126626, -0.1281605363, -0.1639365256, 0.4345696568, 0.0480442159, -0.1302478760, 0.5929509997, -0.7867543697, -0.2702195346, 0.0154336691, -0.0666639283, 0.0578026697, -0.1909641623, 0.0560012460, 0.1143641025, 0.2967103720, -0.1486992836, 0.1331266314, -0.0788110644, 0.1728646457, 0.0052237739, -0.0324646607, -0.0698564276, 0.1155371666, -0.0842912495, -0.0399120823, 0.1955489665, -0.1286365092, -0.1591257900, -0.1598712057, -0.1146062165, -0.1280756593, -0.0627211556, -0.0505024344, -0.1388301998, 0.3356698453, 0.1645491570, 0.0565860681, 0.0521773770, -0.2588559687, 0.1454749107, -0.1376785785, 0.0546208359, 0.0613300167, 0.0874080360, -0.9197025895, -0.0106725916, -0.0581400096, -0.2457455695, 0.1278356165, -0.0959250703, -0.1769592315, 0.1224668100, 0.5286525488, 0.3696294129, -0.1421480477, -0.1709220707, -0.2240903080, -0.2641308010, 0.2881848514, 0.4694823325, -0.0652102455, -0.2242412269, 0.0348531678, -0.1029810011, 0.2840484679, -0.0186836012, 0.8249589205, 0.1885014921, -0.1198074743, -0.0870229527, -0.0496263541, 0.1289316863, -0.0892338753, -0.5016787648, -0.1984975487, -0.1952778101, -0.2433729917, -0.0490386933, -0.1965200901, 0.0245312788, 0.1632219404, 0.0326043740, 0.2533462942, -0.3163430691, -0.0370924287, 0.3402142227, -0.0116693573, -0.0278767087, -0.1288447529, -0.2333879620, -0.0347364470, 0.1675499231, -0.7082173824, -0.1358697414, 0.4803853929, 0.0462762639, -0.0584137924, -0.0957783461, 0.0894321427, -0.0740200877, 0.0380143672, -0.0576441772, -0.0146565028, -0.1364989877, -0.1072363779, 0.5069182515, -0.2342852950, 0.2671274245, -0.0152688995, -0.1844434291, 0.0744743794, -0.4443989098, -0.1176040843, 0.3309873641, 0.1091842949, -0.1709174514, 0.1454184949, -0.1600943655, 0.0484884009, -0.2385581881, -0.0632837713, -1.0983599424, -0.0279008429, -0.1235579997, 0.3080739677, 0.4621214867, 0.0890322998, 0.2508266270, -0.0810695812, 0.1034978852, 0.1758175939, -0.0830232799, 0.1070516631, -0.5339738131, -0.5940724611, -0.4044621289, 0.0084618926, -0.7724251151, -0.0075443848, -0.0823857263, 0.0643093884, -0.0881653503, -0.0632101446, -0.0225674603, 0.1448989362, -0.0394957624, 0.1622717977, -0.2270734161, -0.1526397169, -0.1845304370, 0.0183393601, 0.0909000188, 0.0645324513, -0.0573674701, 0.1191307753, 0.1325580776, 0.2879447937, 0.0175246298, 0.0270286910, -0.2166075259, 0.1598806381, 0.1423314065, 0.1585557908, 0.0629514679, 0.0278392453, -0.0265346169, 0.2185933292, -0.1240302995, -0.1130281761, 0.0340885334, 0.0678779185, -0.0267647784, 0.3476384580, -0.0886687934, 0.0526708364, -0.4236783981, 0.0399514884, -0.0069362917, -0.0820704848, 0.0929897726, 0.5984316468, -0.1157499179, 0.1133899540, 0.0238432400, 0.1665314287, -0.4250516295, -0.0733429343, -0.0393924415, 0.1263354868, -0.4522696137, -0.0232297052, 0.0832466185, 0.0916918516, 0.1271513253, -0.3587284386, 0.1284605265, -0.0496458560, 0.0141187888, -0.1274927706, -0.2480878681, -0.0136103621, 0.8418304920, 0.0623031668, -0.1216739193, -0.1661546379, 0.0130613111, -0.3179219365, -0.1691474915, 0.0459237173, 0.1334642768, 0.3280326128, 0.1766073406, 0.1041556671, 0.1844502687, -0.0955438539, 0.0672852471, -0.0713028535, 0.4068078697, -0.0652245730, 0.4766954482, -0.2683490217, 0.0508978218, 0.2242550403, -0.0130138826, 0.1448891610, -0.1661483496, 0.0212383624, -0.3102898002, -0.0491882525, 0.0535462759, -0.0325303450, -0.0428988822, 0.1211082488, 0.2164304703, -0.1074311957, -0.4739066064, -0.0108499452, -0.1029554904, -0.1161940396, 0.2508584559, 0.2738657594, -0.8691483140, -0.1518689543, -0.2241481990, 0.0257945694, -0.0777292401, 0.1087165698, -0.1717394441, -0.0888631195, -0.4428823590, -0.0743108094, -0.1089650020, 0.1187179089, -0.3763905466, -0.0720027909, 0.0246579945, 0.0223830771, -0.0752194449, -0.0145071018, -0.1359909177, -0.0500614196, -0.1152323335, 0.2118195891, -0.3585740626, 0.1191431433, -0.5155980587, 0.0168369114, -0.0260686204, 0.0843606964, -0.1143169254, -0.4397446811, -0.0269048773, -0.1036028564, 0.0732688680, 0.1712643653, 0.1263002455, 0.0822512135, -0.0053690495, -0.0483350381, 0.0124885645, -0.1009356305, 0.0111696133, -0.1077866182, -0.0190884061, 0.3990702629, -0.0274638459, -0.2674378157, 0.5227362514, -0.0835603029, -0.1143271774, -0.3557612896, -0.0411679819, 0.1163372025, 0.0356356241, -0.1257165074, -0.0397681929, -0.1733245105, -0.0209206305, -0.1548034549, -0.1678014696, 0.4562107921, -0.1540524662, 0.0816310346, 0.1524994969, -0.0345573239, -0.1237896383, -0.1031897143, 0.1270957291, 0.6013018489, -0.3785882592, 0.0169216320, -0.1825744659, 0.2808884382, -0.7947403193, -0.1626486480, 0.0466945469, 0.0263194647, -0.2672716677, -0.1650439203, 0.1776283383, -0.0097376220, 0.0868278146, -1.9210511446, 0.0639815256, 0.0340450257, -0.0747214332, 0.0548563935, 0.0205229167, -0.1076548398, -0.3525637090, 0.0472131744, 0.0913336352, 0.1441095620, 0.1140414923, -0.0156708173, -0.0228106324, -0.0141139384, -0.1261068583, 0.2082801908, -0.4210662544, -0.0052816458, 1.0584652424, -0.0767995194, -0.0734516680, 0.1046039164, -0.3773436844, 0.0549580865, -0.0102515304, -0.4982629716, 0.1524637938, 0.1545576453, -0.2596274018, 0.0301351212, 0.0957140625, -0.1544548124, 0.0130988732, 0.1038129851, 0.1656189412, -0.1573672146, 0.3112754226, -0.0707160085, 0.1293697804, -0.3051563203, 0.5347917080, 0.0141772842, -0.0176415425, 0.0912011117, 0.0937726274, -0.5862204432, -0.0737295151, 0.0669282898, 0.1817167848, -0.1632750034, 0.1557338238, -0.1483440399, 0.4721736014, -0.0948628858, -0.1305854023, -0.0868944973, -0.2180169374, 0.1974364519, -0.3182500601, -0.0904522315, 0.0508452021, -0.0138197020, 0.0389507264, -0.4773382246, 0.4820113778, -0.0180886053, -0.4918875098, 0.2553861439, 0.0222804695, 0.0514477342, -0.1533608288, -0.0463657379, 0.1006370485, 0.1765194088, 0.0681167766, 0.1620721221, -0.0675956160, 0.0474214554, 0.0254089758, 0.2157421559, -0.0583228394, -0.1150979623, 0.0352134742, -0.2276140004, -0.0664106160, -0.1788671315, -0.2895991802, -0.1286076307, -0.1576018184, 0.0260208771, 0.0002907841, 0.1300707757, 0.2803081572, -0.2425349057, -0.0430588871, -0.7741545439, -0.1524090022, -0.0047502359, 0.0003354873, -0.5673824549, 0.1204250008, 0.0174187832, -0.2136924565, -0.1343618929, -0.1273143739, 0.3993692100, -0.1080595255, 0.0635058135, -0.6359025836, -0.0671000034, -0.1319971234, -0.0166354794, -0.0924602449, -0.2850029767, -0.3016424179, -0.0966152698, -0.0959551409, -0.2357548475, -0.0137593020, -0.2088349164, -0.2708097100, 0.1127233952, 1.1644407511, -0.0496778153, -0.1590882689, 0.1405153722, 1.0649687052, 0.3124935329, -0.1666991115, -0.0541085787, -0.0234982669, -0.0231359303, 0.1880045384, -0.1230013371, 0.1904018074, -0.0389396697, 0.1299414635, 0.0319690295, -0.0275409706, -0.0391240455, -0.0177005194, -0.3175891936, 0.0011194046, 0.4689805508, 0.3620838225, -0.1161738336, -0.4927110374, -0.1093032360, 0.1076321453, 0.0309443045, 0.7403662205, 0.1155425906, -0.3727783263, 0.1422815770, -0.1141070202, -0.3339784443, 0.0023503392, 0.1029879153, 0.0950715989, -0.0739299282, 0.0397011600, -0.1901609302, -0.0514320359, -0.0074332035, -0.2041877359, -0.0910537988, 0.1663028598, 0.0496683307, -0.0292260889, 0.0628251061, -0.1061986908, -0.1586760730, 0.1356847137, 0.1497762501, -0.0285952631, -0.0074402867, 0.0392106734, -0.0633699745, 0.0514830723, -0.0341900811, -0.0046107806, -0.0127312252, 0.0561673306, -0.1326671094, 0.0604027174, -0.1245909259, 0.1669736803, -0.0930037275, 0.0499010980, -0.0998587012, -0.1097032204, -0.1595567316, -0.0500475317, 0.0228057578, -0.0679320544, -0.5253071189, -0.2115222514, 0.1114409715, 0.3893590569, 0.0346329100, -0.2186234593, 0.2658132017, -0.0980019718, -0.1339732856, 0.1504694074, 0.0456807017, -0.1751177758, 0.1266489029, 0.0251327474, 0.0474269465, -0.0030868624, -0.2054900378, 0.0929746851, 0.0102223931, 0.0674230382, 0.1372830421, -0.0611236095, -0.0086830314, -0.1692945808, -0.0676659122, 0.0148580605, -0.0867189616, 0.1389878541, -0.4951609671, -0.0559903793, -0.1350803375, -0.1195854917, -0.3436454237, -0.1580606848, -0.1790431738, 0.0748344064, -0.0075466405, 0.1454196125, -0.1223184988, 0.1957763582, -0.1324522346, 0.1746812612, -0.4575305283, 0.0623291023, 0.0473890714, -0.1196022928, 0.0884938762, 0.0547637343, -0.1556258053, 0.1578897536, 0.3081033528, 0.1494837701, 0.1130722389, 0.0406345911, -0.1802409440, 0.7105131745, -0.0744049102, -0.0762097538, 0.0262091327, -0.3160869181, 0.5475432873, -0.0676756427, 0.0435302667, -0.0763284191, -0.0838387534, 0.1309548020, -0.1415586472, -0.0218125861, -0.0018411909, -0.1927403808, 0.1406476498, 0.0441077910, 0.0265147183, -0.1472395808, -0.0489385091, -0.2327563614, 0.0936852247, -0.7316169143, -0.0541732945, 0.3405200541, -0.0007033257, 0.0353554189, 0.6683698297, 0.8401665092, -0.1366319954, -0.2168359011, 0.3990322649, 0.0455276333, 0.1899699420, 0.0741093904, -0.0089497166, -0.1099208593, 0.0094524045, -0.1283317506, -0.1456194073, -0.1630718857, -0.0005434288, -0.1451798379, 0.0623653457, -0.1781863570, -0.2282958031, -0.3034539223, -0.0883309618, -0.1716746539, -0.1269105077, 0.1407408714, 0.0717567652, 0.3972812295, 0.1516393572, -0.0893224105, -0.0269867592, 0.1372531354, 0.1357986480, -0.2749065459, -0.1364236474, -0.0973550305, -0.0738605633, 0.0332338847, 0.0950010642, -0.4406587481, -0.1066161767, 0.1718951762, 0.2545511425, -0.0406523943, -0.2135915011, -0.3569816649, 0.0747937113, 0.2277760804, -0.2641412616, 0.1800322235, 0.1516479999, -0.3863794208, 0.0874185413, -0.2311587781, -0.5297201276, 0.0269835833, -0.0658016577, 0.0975864083, 0.1259764284, -0.1522372663, 0.1908500493, 0.0662138313, -0.2217485905, 0.0792718902, 0.5919983387, -0.0617900975, -0.0775350034, -0.1983965635, -0.0571169853, 0.0698223338, 0.4671186507, -0.0089796642, 0.1990988702, -0.1577920020, 0.0455781445, -0.1540556699, 0.5738633871, 0.0116312848, -0.0397167690, 0.0921577662, -0.3000919521, 0.1454585642, 0.0776002333, 0.0762889832, -0.0517474525, -0.0265052188, 0.1237431839, -0.1430503726, -0.1079339832, 0.2017888725, -0.3857876956, -0.0753105581, -0.0013584571, -0.1080425084, 0.5061392784, 0.0125191929, -0.1707755327, -0.1793562919, 0.4994418323, 0.6558804512, -0.0083425492, 0.0721194446, 0.0741747990, 0.1135746315, 0.0755929276, 0.1638791710, -0.0218199268, 0.3067809939, 0.2924079597, 0.2855444252, 0.0885162354, -0.0008819010, -0.1895084381, 0.0360878780, 0.0668476447, 0.2975268066, -0.0409356318, -0.1601145118, -0.0417463444, 0.1417055726, -0.0569675155, 0.4389747977, -0.0581431054, 0.0026754600, 0.1165432557, 0.0962655619, 0.0262928922, 0.2528913617, 0.0358502343, -0.1291915923, -0.5732731223, -0.7267723083, 0.0538650900, -0.1383465230, 0.1094130054, -0.1593405753, -0.3181844652, -0.1825359315, -0.0038589577, 0.0150391599, -0.1420435160, -0.0532893911, 0.0432667397, -0.0789903328, -0.0388658792, 0.1101985574, -0.0757230073, 0.3815174997, 0.0914390087, -0.1582894176, 0.0709697381, -0.0833302587, -0.0017060763, -0.1837277412, 0.1213235557, -0.1587675363, -0.0445827954, 0.1086555123, 0.0814898089, -0.1683295071, 0.0309842862, 0.2371947318, 0.0743796676, 0.1749410182, 0.0563945994, 0.0234475099, 0.2481447458, -0.2006761283, -0.1504265368, 0.1932720542, -0.0252888910, 0.0308156013, 0.7085699439, -0.1770870835, 0.1364555359, -0.7205842137, -0.4968969524, 0.1678459942, -0.1602195948, -0.1197833717, -0.0564633273, 0.0314965360, 0.2755865455, 0.1318058521, 0.2359969616, 0.1014084145, 0.0563417077, 0.0052967006, 0.0637385249, 0.0091815311, 0.0034677533, -0.0658252463, -0.1722936183, 0.0910201147, 0.1180375963, -0.0459650196, 0.0534504801, 0.0276002120, -0.0556356646, -0.0903096646, -0.0454951674, 0.5857485533, -0.3368389308, -0.0405107215, -0.3446095884, -0.0843507946, -0.0143179698, -0.0600373484, -0.2196860611, -0.1107609719, -0.1689222306, -0.1388940662, 0.0049511134, -0.1369277984, -0.0251959991, -0.0928080976, -0.0459405445, 0.0267649759, 0.1109850630, -0.2922682166, -0.0470442250, 0.1144256070, -0.9799373150, -0.1318144947, -0.0255174786, -0.0478995703, -0.0733067989, -0.4411235154, -0.1367938370, -0.1934568286, 0.0400632843, 0.0363335758, 0.1166892275, -0.0488487594, 0.0881060511, 0.0579693392, -0.1708664000, -0.0402443297, 0.0529737175, 0.0513424315, -0.1154339761, -0.0107163563, -0.0168715958, 0.3477868438, -0.0187912025, -0.0173749439, -0.1482959688, -0.1336344481, 0.1259739250, -0.0663845912, -0.0936789066, -0.0288334880, -0.6916498542, -0.0624897443, 0.0709739849, 0.1458425224, 0.0555287302, -0.1662959158, 0.1615096480, -0.5539819598, 0.0765730813, -0.6343794465, 0.6623281240, -0.3630414605, -0.0075698169, -0.0099374084, 0.1047719046, 0.0997318476, 0.1563383788, 0.2398141176, 0.1322867125, 0.0987040624, 0.0000847232, -0.1800578535, 0.0892252624, 0.0096269865, 0.3929223716, 0.4078094065, -0.0869387612, -0.1117550135, -0.1402758658, 0.0923642591, 0.4088311195, -0.5582080483, -0.0395574495, -0.0736333132, -0.1112750918, 0.0622407794, 0.0460106768, -0.2679009736, 0.1193214431, -0.2347942293, -0.0861137286, -0.1429787874, -0.4400873482, 0.2157838643, 0.0082697459, -0.0164996199, -0.1367666572, 0.0363737866, 0.1097232625, 0.3531502783, -0.0016558535, 0.8849270940, -0.0412276052, -0.3565482199, -0.1608862281, 0.1741319597, 0.0521300845, -0.0157312062, -0.0340799391, 0.0401007533, 0.5935264230, 0.0276768561, -0.0236891806, 0.1458435208, -0.0128708659, 0.0652502999, -0.1222254187, -0.1479304284, 0.4508742392, -0.0865263566, 0.0785627812, -0.0818799436, 0.0305298418, -0.0834073573, -0.0691875741, 0.0213081297, -0.0471856892, -0.5599100590, -0.1835187525, -0.0549864471, -0.5187573433, 0.2053656876, -0.1512714475, -0.0200691465, 0.0909466147, -0.1198227555, -0.1084237024, 0.1013607010, -0.1746537387, -0.0410920270, 0.6445380449, -0.0582293533, 0.0508412458, 0.6603922844, 0.0071009244, 0.1006089672, 0.0919631720, -0.0176977403, 0.2273164988, -0.1285038888, 0.0656851158, 0.1258010566, -0.2722742260, -0.1406531781, -0.2552681267, -0.3317924142, -0.1066469252, 0.2112537026, 0.1890127063, -0.2928448915, 0.0749841779, -0.6892309785, 0.0544208810, -0.2028449774, 0.1114786267, 0.0724932253, -0.0207675509, 0.2542250156, -0.2086784691, 0.0463374145, -0.1618692428, -0.0719216764, -0.3673295081, 0.1095546335, -0.0030313386, 0.1423364282, 0.1475261301, 0.1255783439, 0.2974655926, -0.0292636156, -0.0539826974, -0.2568015754, -0.1595088392, -0.0322982185, 0.2689157724, 0.5476220250, 0.0981426314, 0.5306978822, -0.2573180795, -0.2396175414, -0.0259444825, 0.0031389189, -0.0882141441, -0.0145904711, 0.2418015599, -0.4864667654, -0.1667050421, 0.1534011066, -0.0397662446, -0.0082647195, -0.1747489572, 0.7179142833, 0.0795911625, 0.1298119128, -0.1392284185, 0.1164772660, -0.0722274035, -0.0480964519, 0.5426166654, -0.2048025429, -0.0364497453, 0.0082584489, 0.0725995675, -0.1037270650, -0.0198360141, -0.4217894077, 0.0696804002, -0.7360820770, -0.1641159803, 0.0506952740, -0.2274750918, -0.0359150134, 0.0314476006, 0.0838247016, 0.0963345692, -0.1151500940, 0.1619186848, -0.1945869476, 0.1240271628, 0.4956338108, 0.0759393051, -0.2312691510, -0.0527005047, -0.1224292889, 0.0551334992, -0.1916173249, -0.1913480759, 0.1203933954, -0.0778063685, -0.1439342350, 0.0253938884, -0.0536567867, 0.0271399356, -0.1590228826, 0.0514502861, 0.0688400269, -0.0399510302, -0.0899551585, -0.0352281444, -0.1489810646, 0.0985169858, 0.0797008798, 0.1739389896, 0.1601243615, 0.0149481595, 0.2370989919, 0.1700243950, -0.1469481885, -0.0253499057, 0.0660387203, 0.0826004073, -0.0169015545, -0.0919761956, -0.1671232730, 0.0952301100, -0.1967517287, -0.0096548377, 0.0968346223, -0.0069582630, 0.1859093904, 0.1107457206, -0.3639483154, 0.4514255226, -0.2299390733, 0.1961390674, -0.1364268363, -0.8791694045, 0.3415225446, -0.1711922586, -0.0129596591, 0.4919753671, 0.6465014219, 0.0219968334, -0.0667284429, -0.1188028082, 0.0872085318, 0.0194179360, -0.1998802572, -0.1657607257, 0.4950863421, -0.5581328273, 0.1493011564, 0.0272785276, -0.0315002203, -0.0053364085, 0.0545266196, 0.0901931524, 0.2261203527, 0.1279403865, 0.1850167066, -0.1067006290, 0.0374925174, 0.1893638223, 0.0634161085, -0.2548950315, 0.1963685453, -0.5816451907, -0.1212502047, -0.1316082329, 0.2240268290, -0.0623439886, 0.0617133938, -0.9432576895, -0.6174269915, -0.0039725471, 0.5576034784, -0.0829583779, 0.1419301927, -0.1330090016, 0.1210380346, 0.0793632939, -0.1587525755, 0.0368889757, 0.0506151132, 0.3678868413, -0.0772152543, -0.1512973905, 0.0343120024, 0.0524876267, -0.1308898777, 0.3926090598, -0.0266162138, 0.1233571917, 0.0825911015, -0.0204653870, -0.2100678831, -0.1815280318, 0.6450167894, -0.0283231214, -0.1507874280, 0.0957572535, -0.0377866924, 0.1014780030, -0.6148141623, 0.1558980197, 0.4614432454, -0.0961608067, -0.0615647323, 0.0660649613, 0.2247816175, -0.1280526519, -0.0261488557, -0.0096494500, 0.0635856539, -0.3107853234, 0.3634276986, 0.1010224894, 0.3574117422, 0.2546413839, 0.0479708351, -0.1206728071, 0.1274159998, -0.0026637535, -0.1547185928, -0.5465688705, -0.0811385736, 0.4783462882, -0.0749142990, 0.0640532076, -0.0534312353, 0.0283769779, -0.0567455515, -0.0059854663, -0.1506682187, -0.3064606786, 0.0599337257, 0.0646229163, -0.5069497824, -0.0162432790, -0.1417670697, -0.1438944042, -0.1671425104, -0.0432450324, -0.8005930185, -0.1263242215, -0.1042091846, 0.7293133736, 0.0215027947, 0.1417373419, 0.1071332321, 0.1304004788, 0.0745380521, -0.1632569432, -0.0348048285, 0.0827519670, 0.1006797701, -0.3058151007, 0.0230191238, -0.1490362585, 0.3977855742, -0.5340266824, -0.0675014034, -0.1226572245, -0.0771813616, 0.2350587696, -0.1002002284, -0.1269673556, 0.0913768411, -0.0273500811, -0.2268107235, -0.0666879043, -0.1722900867, -0.1458100677, 0.3548042476, -0.0191703718, -0.0010921960, -0.1175735667, -0.4010248482, -0.9312092066, -0.0953943282, 0.0797829106, 0.0240551643, -0.1224533319, 0.0531471409, -0.0550909378, 0.4996845722, -0.0134307556, -0.1796831340, 0.1356556267, 0.0815631002, 0.2782115340, 0.0292468518, 0.2796430290, 0.0614952855, -0.1692904681, -0.0785764977, 0.0155145628, 0.5847948790, -0.0991462916, -0.0052881814, 0.3816896677, 0.2887873054, 0.1224661395, 0.2627890408, 0.0226446800, 0.1255819499, 0.2486380637, 0.0651238561, -0.0227150936, 0.0067829108, 0.0934813544, -0.2724822760, -0.0348773226, -0.2923477292, 0.1195074469, -0.2831997871, 0.1014426947, -0.1175040603, 0.3163584471, 0.1374121755, -0.1116692796, 0.0798991323, 0.1180321202, 0.0698234588, -0.1799667329, 0.1659156084, -0.0827593878, 0.0696127936, -0.0773847252, -0.0809163973, -0.1479893476, 0.0824001729, 0.0719795823, 0.5988013148, 0.0274055358, -0.0664780661, -0.1786177605, 0.0128697446, -0.0993905514, 0.0609490275, -0.2206950188, -0.0626851618, 0.0681937784, -0.0804066062, -0.0532779172, -0.1379932463, -0.8481692076, -0.1596833467, 0.1279379874, -0.2251559794, -0.1380814165, 0.3278353214, 0.9870324135, -0.1179486290, 0.4174555540, 0.1022202522, 0.0876839459, 0.0254681278, 0.0212096889, -0.1679068506, -0.1662217975, -0.1498510092, 0.2215530723, -0.1682556868, -0.0282729007, -0.1775457710, -0.1460445821, -0.0690152124, 0.1220237538, -0.0056966282, 0.2395716757, -0.1629669219, -0.1989551932, 0.1257943362, -0.8740902543, 0.1163255498, -0.0005269934, 0.0757299066, 0.0736650527, 0.0311199371, -0.0446824692, -0.0583852306, 0.0408083051, -0.0342086256, -0.2502006292, 0.0806021318, -0.1418068558, -0.0770356283, -0.0088933501, -0.0211432707, -0.0550890490, 0.1086882949, 0.3309386671, -0.3963380754, -0.2669315934, -0.2276196778, -0.2133706957, 0.0259672757, 0.0307799559, -0.0713317245, -0.0195883587, -0.8793313503, 0.0829747766, -0.2352086306, -0.0619183704, -0.7764247656, 0.5413003564, -0.1144587621, 0.0120933382, -0.2083115727, 0.0596848577, -0.1148649529, -0.2157427818, 0.3212626576, -0.0950177833, 0.1188093275, 0.0185424667, -0.1553861499, 0.0371706598, 0.4872859716, 0.3250755370, -0.1507773101, 0.0750116408, -0.1285945326, 0.0439978875, -0.1806167513, -0.1193674728, -0.1056566611, 0.4159502983, -0.0320734009, -0.1552386582, 0.4722908735, -0.0973576158, -0.1546344161, -0.0736902282, 0.0606452636, -0.0260321908, 0.1212245226, -0.0256234221, -0.2089642733, -0.2445612252, -0.1765135825, 0.1441220641, -0.0767900199, 0.0793992057, 0.1267938316, -0.0520466007, 0.3116836548, -0.0075352727, 0.1144629642, 0.1234693453, 0.3408534825, -0.0439928584, -0.9413105845, 0.0486498140, -0.1297741979, -0.0283946358, -0.0569444373, 0.0885418579, 0.3256137669, 0.0519109480, -0.4256136417, 0.0796944425, -0.0337304100, 0.0944442227, -0.2494311929, -0.0021998470, -0.0080741988, -0.2530142963, 0.0883302838, 0.0788406730, 0.0152123701, 0.0102305030, -0.0462262444, -0.3193638623, -0.5174037218, -0.1226697192, -0.2823720276, 0.0790117979, -0.2321380675, -0.0503416434, 0.0977917239, -0.0802357718, -0.1615195274, -0.0556500182, -0.0210666824, 0.0850848034, -0.1848275214, -0.1622354239, -0.0076560006, -0.2261697650, -0.1200271398, 0.1047514528, -0.2488430589, 0.0584648252, -0.1028933674, 0.0809812471, 0.0859110281, -0.0029403539, 0.0486374311, -0.0590873063, 0.1407427937, -1.0013693571, 0.0725073963, 0.1107990965, -0.1550723910, -0.0493458956, 0.0089100916, -0.0504760705, 0.0411715135, 0.0637827516, -0.0849668011, 0.4193114340, 0.0231022462, -0.1361216754, -0.0096914116, -0.1767354906, -0.0007268675, -0.0499783307, 0.0751045793, -0.2490618676, -0.1134964898, 0.0411193557, 0.0021951634, 0.5911088586, -0.7830706835, 0.2567608356, 0.2427367568, -0.1350984275, -1.3583457470, 0.0096714320, -0.0037838288, 0.1731301844, -0.1240735203, 0.0045224526, 0.0529628694, -0.0381239653, -0.1651057452, 0.1582168490, -0.1944653392, 0.0873360559, 0.3906018436, -0.0146989319, 0.0974045545, -0.3134435415, -0.0725177974, 0.1003399789, -0.5661642551, -0.1091243401, 0.2072639763, 0.2942861617, 0.3840048909, 0.0893472657, 0.8416395783, 0.0484027229, 0.1383222342, 0.4079451263, 0.9020935297, -0.1211734042, -0.3323811889, 0.1014508903, -0.1946674585, -0.1267350018, -0.1070365235, 0.1572273970, -0.1237924471, -0.0061067496, -0.1206604019, 0.0566926934, 0.1325607002, -0.1513407826, 0.1690036952, 0.1276001185, -0.4801351428, -0.6717429161, 0.1823447794, -0.0304851402, -0.1474283785, -0.2040893137, -0.4132325351, 0.0094729820, -0.7262165546, -0.1162740886, 0.0979598463, 0.0839729980, 0.0368060656, -0.0848380774, 0.0443599038, -0.1473633945, -0.0444843210, -0.0202984307, 0.1480762661, -0.1034843624, 0.3505049944, 0.0215266254, -0.1740278453, -0.0525792427, -0.1807570755, 0.3609879017, 0.0880221575, 0.0858810022, 0.5524628758, -0.0053234445, 0.4381930530, 0.0866760761, -0.2515915334, 0.0709098428, -0.0913535580, -0.0835119337, 0.1296749860, 0.3289162219, 0.0417064168, 0.0868525952, -0.1398602426, 0.2578995526, -0.1535510868, -0.0707812011, -0.1589341313, 0.2210998386, -0.0745775625, -0.1411105841, -0.0193790160, 0.0233964473, 0.0501610339, 0.2365551591, 0.0434204303, -0.1151385680, 0.1228157803, -0.0442914441, -0.0052528679, -0.8299108148, -0.0716800466, 0.1266339719, -0.0024754331, 0.1142372787, -0.1854666173, -0.1108911335, 0.0307731088, 0.0947435051, 0.1099530160, 0.4582932591, -0.1254401803, -0.0507564843, 0.1563363373, -0.2197663337, -0.0736185685, 0.0343675949, -0.0517080165, -0.6710717678, -0.4638324380, 0.0306543373, -0.0456738770, -0.3387710750, 0.0429383069, -0.2011529654, 0.1701472402, -0.0202415865, 0.3349264860, 0.1062682495, -0.2248736024, -0.0488897860, 0.6658428311, -1.3990473747, 0.4985036254, -0.0622769706, 0.1426690817, -0.1783488542, 0.1781704128, 0.0318365395, -0.1702271998, -0.0501497500, -0.1591338515, -0.0387186110, -0.0417219922, 0.1729775369, 0.4931144118, -0.3251130879, -0.1037746519, 0.0616274662, 0.4969905317, -0.2315149903, 0.0399454944, -0.0549002513, 0.1218010932, 0.1984770298, 0.3405069113, -0.0903816745, -0.0993758962, 0.1016377881, 0.1895262450, -0.1270812303, -0.0686000511, -0.1182791293, 0.1380719095, -0.2349837571, -0.2164681554, -0.0982806459, 0.1524925679, 0.0956665203, 0.2325040698, 0.1557837129, 0.4849065542, 0.3745159507, -0.1835602671, -0.0315627418, 0.1050705612, -0.1742370427, -0.1435736865, 0.1334216744, 0.8277180195, -0.1275982112, 0.0593774207, -0.0835951045, -0.0584070534, -0.1384643763, 0.5068855882, -0.0709334835, 0.2208374590, -0.1015306711, -0.0349062011, -0.1607591063, 0.0489393286, 0.0541176200, -0.1283398718, -0.0903430879, -0.0581984930, 0.4141945243, 0.1349081844, 0.1282637119, -0.0660476759, 0.2660845816, -0.1915336102, -0.0210456848, -0.0401761010, -0.1424344778, 0.0616665110, -0.0334427804, -0.1557645351, 0.0313428491, -0.0817114487, 0.0599740595, -0.1384718120, 0.1887973249, -0.2283277214, -0.1521372944, 0.0957008824, 0.3471366763, -0.1270038635, 0.0798818544, -0.3573967814, -0.1565863937, -0.0446395986, -0.0855928287, 0.0618719310, 0.0176318660, -0.1425934285, -0.0655385479, -0.0455728695, 0.4589281082, -0.0808026269, 0.1299675405, -0.0239278935, 0.0627634376, -0.1599146426, -0.0213632416, -0.1563982964, 0.0546136685, -0.1300501078, -0.1414262354, -0.1023410782, -0.1002973840, -0.1442319006, -0.3009021580, 0.0838456899, -0.0869764909, -0.1639915109, -0.2306536138, -0.2262577713, -0.1130424365, 0.0994440764, -0.2798864245, -0.5874111652, -0.0276742168, 0.1995749474, -0.0986619145, 0.5822031498, 0.0630262420, -0.4044274390, 0.1115178913, -0.2229540795, -1.0163249969, -0.2774376571, -0.1400345862, -0.0372421592, -0.1388842911, -0.2603091598, -0.0836665630, 0.2223327905, 0.1441015154, -0.0677834675, -0.1571442485, 0.0611285008, -0.1910394132, -0.2325808406, 0.1090514511, 0.0322399326, 0.1125664711, 0.3885391355, -0.1663544476, -0.2277306616, 0.1014983431, 0.0203152932, 0.2251216471, 0.4888401628, 0.0559853949, 0.3441438973, -0.2250887901, 0.0039544599, -0.1257719696, -0.0465893075, -0.1057753786, -0.0174123086, -0.1009619832, -0.1589277387, 0.1117691100, 0.0952580720, -0.0566433407, 0.0591722578, -0.0637064800, -0.0874197483, -0.3263834715, 0.1610143930, -0.1308513135, 0.0667608008, 0.0126395673, 0.3581953943, 0.0923703313, -0.0931240842, -0.1655487567, 0.1472967565, 0.0917517617, -0.0084419865, 0.1090294346, 0.4099477530, 0.0507501997, -0.7482305169, 0.1232566983, -0.1277153045, 0.1253608763, -0.3153647780, -0.0009262934, 0.0032141220, 0.0186555721, -0.0486072265, -0.2723703086, 0.4866341352, -0.1072772965, -0.0013480091, 0.5149310827, 0.1969946474, 0.0115575343, -0.0271962285, -0.0495285317, 0.1515284330, -0.0634599999, -0.0323598199, -0.1625367850, -0.0080752699, 0.0429388732, -0.0288744811, 0.0871823356, -0.1828044504, 0.0315281898, 0.0390263610, 0.1517664194, 0.0966034234, -0.1044690758, 0.0335449800, 0.1286387593, 0.1203387678, -0.2955304980, -0.0643957183, -0.2131714225, 0.5327724814, -0.1321570575, -0.0478418693, 0.3051941693, 0.0830089226, 0.0323417448, -0.1233730540, 0.0312446281, -0.0988193676, 0.1083235443, -0.1533927172, -0.0559098758, -0.0289035775, -0.0843667313, -0.1297039688, 0.0843254551, 0.3349374533, 0.1481164843, 0.0430653654, -0.0194917116, 0.1130883098, 0.0432377979, 0.1302831918, 0.0578932054, -0.1686422825, 0.1632074416, -0.6431661844, 0.0054795942, -0.3178687394, -0.0437222272, -0.5931497812, -0.0801498815, -0.0425564609, 0.0793025196, -0.7545285821, -0.3856925964, -0.0352270380, 0.0092893131, -0.1846990883, 0.1296190023, -0.1584542543, -0.1727350801, -0.4238154292, 0.1179599985, 0.1026420668, 0.1401985139, 0.0733815059, -0.1669819206, -0.3100627065, -0.4442811608, -0.0992153361, -0.0682613775, 0.0403591357, -0.0414504930, -0.4067523777, -0.0955706611, -0.0082073575, -0.1619286537, 0.0069429697, -0.0234856196, 0.1753221452, 0.6471905708, 0.0033930547, -0.3235868216, -0.0509692356, -0.0492286496, -0.0140386764, -0.0860560313, -0.0832592025, 0.1684706062, -0.1500312835, 0.1317955106, 0.0069550159, -0.0646666586, 0.8872799277, -0.1288206279, 0.3007514775, 0.1680394113, -0.0680653751, 0.0301723517, 0.1817190200, 0.2688866258, -0.3162350953, -0.0170444567, 0.0962905288, 0.0353025049, -0.0061950651, -0.0807387829, 0.5684323311, -0.0185950603, -0.0533045940, -0.0382554941, -0.0234270189, 0.2495124340, -0.4071461558, 0.0216546450, 0.1146313697, -0.0831138715, 0.0921305865, 0.2770633101, 0.5136280656, -0.0883664116, 0.3593837619, 0.2148541212, -0.1086993665, 0.0657749325, 0.1824225187, -0.1672293842, -0.1296641231, 0.0839700028, -0.1327843964, -0.2316028476, -0.0209143348, -0.0452291891, -0.1707531363, 0.1635222882, -0.2163112611, 0.1038133428, 0.1273609847, 0.4306143522, 0.0154915499, 0.0037838372, 0.0878580734, -0.0550124347, 0.1016424224, -0.2333576977, -0.2072878331, -0.3270642757, -0.1156708971, 0.0737565309, -0.0707126185, -1.2809025049, -0.2086690217, 0.0817838237, 0.1133326069, 0.0875548273, 0.1459475756, 0.0920682028, 0.1190709919, -0.0598792955, -0.1754560471, -0.1318216175, 0.0551476665, 0.0227696877, -0.2779459059, -0.4798221588, -0.0601872280, -0.1560170799, -0.0159568619, -0.0108092539, -0.0273177773, -0.2393281907, -0.0121180592, 0.4749171436, 0.0666974634, -0.4886684120, 0.4186713994, 0.0565312468, 0.4179445803, 0.0465548895, -0.1594975591, -0.1023056209, 0.1139254719, 0.4030245841, -0.3967244625, -0.1006502509, 0.0864951313, -0.2150596529, -0.1236886904, -0.0658280030, 0.0318187289, -0.0560921542, 0.0542130917, 0.1389221400, -0.0281979851, -0.2113979459, 0.3010732830, -0.1003537551, -0.1067069173, 0.1048392653, 0.4131154120, 0.0724803209, -0.1082448512, 0.1075749844, -0.0513105467, 0.0887403041, -0.4060952961, 0.0983776897, 0.3899548948, -0.1172914952, -0.4080824256, 0.1989382356, 0.0364665836, -0.2180227339, -0.1540977508, 0.1361801028, -0.1633707732, -0.3152706325, -0.1075480878, -0.0788401738, -0.0437607169, 0.0765457451, 0.5798336267, 0.2025565952, -0.1414048374, 0.0392674766, 0.0439644903, -0.0512956604, -0.2939679623, 0.0046612788, -0.7318074703, -0.1058719009, -0.0513368100, 0.1248395666, 0.1065342426, -0.0179830976, 0.4282352626, 0.0966229737, -0.1822781861, -0.0184717011, 0.1141346246, 0.1488405764, -0.4730226696, -0.0415170677, 0.0271388255, -0.0491403043, 0.0293530114, 0.3666966856, 0.4431524277, 0.0383336060, -0.0240375064, 0.4178785384, 0.3997760713, -0.0737438202, -0.5037928820, -0.0538431481, -0.2001816481, -0.0553466529, 0.0634266287, -0.0658308715, -0.1234659180, -0.0988258272, -0.1161917076, 0.0223747510, 0.0446014889, 0.1426288784, 0.0678291395, -0.0595327839, -0.0797279924, 0.0861193091, 0.3010250330, -0.1295651048, 0.0398901105, 0.1394861937, -0.1195256785, -0.1382237375, 0.1235091612, -0.0284746699, -0.0212833136, 0.0809936523, -0.1413179487, -0.0610804521, -0.1343313903, 0.1289529204, 0.0465828069, 0.0123302629, -0.0024958656, -0.0260473918, 0.0680213347, 0.1422354430, 0.0126771256, 0.0630295053, 0.0698576123, 0.1515844315, -0.1015638635, -0.0370336771, -0.0217591766, -0.3439794779, -0.0533150360, -0.0747249648, 0.0619419254, 0.1274806708, -0.2552167177, 0.1487775296, -0.2074972391, -0.0381960720, -0.1447536945, -0.1459063739, -0.1360996217, -0.1083689556, 0.6641196609, -0.1639771312, -0.0330406502, 0.1458556801, 0.0681885779, 0.0477382988, -0.1437820643, -0.0891649872, 0.6288100481, 0.0430230461, -0.1760134548, 0.0744346827, -0.1381390244, -0.0158532932, -0.0866444632, 0.0401903726, -0.0837142467, -0.1370469034, 0.6583837271, 0.0182702020, -1.9421012402, -0.1250917912, 0.0350793973, -1.0573445559, -0.1630828381, -0.1239553988, 0.3322199881, -0.2243909836, -0.3501193821, -0.1118392944, 0.0139023801, -0.1750317365, -0.0727728605, -0.1842921972, 0.1720822603, 0.3329086304, -0.0000385520, 0.0641393736, 0.0833480656, 0.1278171390, -0.7703729272, 0.0562676154, -0.2334349006, 0.1110688522, -0.0201307032, -0.0656177476, 0.2943232954, 0.4165169597, 0.3106787801, -0.1259828955, -0.0618285388, 0.0327574313, 0.1071048453, -0.1596488357, 0.1523050815, 0.1271674037, 1.0488369465, 0.0276185852, -0.0065613952, -0.0777644515, 0.2098859847, -0.1392086893, -0.1718911231, -0.1099073216, 0.0787105411, 0.5491207838, -0.3677046597, -0.0356649384, -0.5984307528, -0.2477266788, -0.3292035162, 0.0227964967, -0.2544023395, -0.0845970809, -0.0318918340, 0.1292178631, -0.0603885353, -0.0276352484, 0.0031587996, -0.0917676613, -0.1400363445, 0.0003591486, 0.1220241934, 0.0385041870, 0.0734796971, -0.4597780406, -0.0678224489, -0.0301032048, 0.1403288096, -0.1250052452, -0.1588611603, -0.3649460673, -0.1798343211, 0.0501496643, 0.1146994159, -0.3850739598, -0.0378021225, -0.6356426477, -0.2415032089, 0.0627742782, 0.1371325552, 0.0569173545, -0.1832644492, 0.0931080803, 0.1109763384, 0.0116983997, -0.0279585123, -0.0282653924, -0.1565355062, 0.1281003654, 0.3416596353, 0.1001682431, -0.1003902778, -0.0231650844, -0.0017311488, 0.1687455773, -0.4453075826, -0.1151737273, -0.0661441386, -0.1643920392, -0.5687199831, -0.1019695103, 0.0861923471, 0.0517661907, -0.8175626397, -0.0381709337, -0.1807683259, 0.2157768905, 0.3887903988, 0.2066650689, 0.3365387022, -0.1511120051, -0.2057494074, 0.1587756276, -0.1805635244, -0.0731109157, -0.2251596600, 0.0592198931, 0.0432855785, -0.0909956247, -0.1601171941, 0.0559482239, 0.5533725619, -0.3089683354, -0.2144069374, -0.3265643716, 0.1711970121, 0.1386644989, -1.0100432634, -0.1675941199, 0.0915518627, -0.5994175076, 0.6155027151, 0.1236685589, 0.2022739351, 0.1975112855, -0.1610908955, -0.1129958406, -0.0051893182, -0.1792236865, 0.0470257923, -0.1071747392, -0.3507101536, -0.0255746711, 0.1075132862, 0.0519076549, 0.1708577722, 0.0283945967, 0.2967304885, 0.1673609018, -0.4106607139, -0.1678264141, -0.1175643727, 0.1255810261, 0.3121240735, 0.0436630957, 0.8096229434, -0.0969607159, -0.0078751519, 0.0179217197, -0.0782689899, -0.1521661431, -0.0092957877, 0.0841985866, 0.0273942649, -0.1019553319, 0.1187265888, 0.1727057993, -0.0567701869, -0.2374147624, 0.0395326652, 0.1089147627, 0.0852161571, 0.4409354329, 0.2587410808, 0.0707203969, 0.5399929285, 0.2127486169, -0.2548029125, 0.0938781649, 0.0685495064, 0.1360153556, -0.6052719951, -0.5058109760, -0.0063962890, -0.1517963558, -0.0474555343, -0.1021094769, 0.0368002765, 0.0892215818, -0.1883534342, -0.1129414886, -0.1534166932, -0.2014187127, -0.0574442036, 0.0617030263, 0.2947840393, 0.1589891762, -0.1057292148, 0.1659627110, 0.1011766493, 0.2284781337, -0.5406317711, 0.0141852740, 0.0365524441, 0.8017581701, -0.1203083917, -0.0084698442, -0.1666431874, 0.0968641788, -0.0086536761, 0.0503138267, -0.1220286116, -0.0415307432, 0.1292874664, 0.1871172488, 0.1603180468, -0.1548527181, 0.0326448046, -0.0885168985, -0.0679159462, -0.0666873977, -0.1350857615, 0.0363968723, 0.0364129469, 0.0045552491, 0.1010509282, 0.2143806815, -0.3860181868, -0.0967876688, -0.1809534431, 0.0554310866, 0.3382580876, 0.1396588832, 0.0567098558, 0.1093149483, -0.0136823626, 1.0061696768, -0.2739668489, 0.1123364195, 0.0552903041, 0.0213618074, -0.0356456600, -0.1405438334, 0.5768503547, 0.0366349407, -0.1573198140, 0.2269020081, 0.1411556453, -0.1638130248, 0.1263063103, 0.1550340056, -0.0326484479, -0.0527866781, 0.0353424735, -0.1036162525, 0.0211897474, -0.1388244331, -0.1734065562, -0.1465114206, -0.2388729453, 0.0491757281, -0.5686321259, -0.6485443115, -0.2095824778, 0.1367170662, -0.1153694615, -0.0025642212, 0.0187545177, -0.0540771037, -0.2729947567, 0.0638257489, 0.0591538362, 0.0212684516, -0.1877736300, -0.1652618051, -0.4029412568, -0.0532042272, -0.4698294103, 0.0373045169, 0.1566930115, 0.0888565555, -0.5061079860, 0.1991643161, 0.8055587411, 0.0224931538, -0.2142157853, -0.0839060619, -0.0878223628, -0.0176647045, -0.1790972948, -0.0211487487, -0.4205849469, 0.0561210699, -0.1711663753, 0.3838329613, -0.0570591949, -0.0867550522, -0.1641895473, 0.0844977871, 0.1165244654, 0.3672674000, 0.3862219453, -0.1331535280, 0.6276286840, -0.3883679509, 0.6514836550, -0.0380902588, 0.5794249177, 0.0652973130, 0.0172260683, 0.2142195106, -0.0689992085, -0.1650244594, -0.1142138392, 0.1049768776, 0.0189477783, 0.1472662687, 0.1451568007, 0.1118898541, 0.0324961916, -0.2514715195, 0.0011479135, -0.0130796889, -0.1014200523, 0.0089897215, 0.0119332271, -0.0844000056, -0.1203591302, -0.1952914149, 0.2398937494, 0.0101406313, 0.0087969601, -0.4597309828, 0.1489947289, -0.0012539156, -0.0261347573, -0.1560679823, 0.1104775518, 0.0767145827, -0.0462128818, 0.0195937864, -0.1577034742, -0.0785704106, 0.1738520563, -0.0583591424, 0.0792461336, 0.0463068374, -0.1551159918, 0.0299694296, -0.1053526998, -0.2072865367, 0.2976347506, -0.1771555841, 0.0737178475, 0.3356675506, 0.4012358785, -0.0890816227, -0.2149230987, -0.1447084993, 0.7539654970, -0.1892507821, 0.0550112389, 0.0228606891, 0.2257501632, 0.2746478915, 0.3392536640, -0.1282591075, 0.0682012811, -0.0829538926, 0.0117858453, -0.1473620832, -0.2146656513, -0.0153293358, -0.0342312194, -0.1015116870, -0.1388194412, -0.2077551335, 0.4420242310, -0.1365613937, -0.0430672094, 0.2419420332, -0.2486317158, -0.0421988927, -0.0192086697, 0.0360638425, 0.0216330383, 0.2912564874, 0.1587745100, 0.0792732984, 0.4415195286, 0.2533408999, 0.0766697004, -0.3042119741, -0.2532628775, -0.0979727581, -0.1567253470, -0.1606045365, -0.2112078816, 0.0018008339, -0.0885433629, -0.0994134843, 0.1116469279, -0.1797493100, -0.2568760514, 0.2755022645, 0.1853522807, -0.0700608194, 0.0011500254, 0.1131529137, -0.5635995269, -0.1920016110, -0.1631192863, 0.0264877528, 0.0886769369, -0.0375273079, -0.0687984601, -0.1286000758, -0.0373242237, -0.1057807729, 0.0138222072, -0.0924171209, -0.0418767743, 0.1075933352, 0.2466651648, 0.0339725576, -0.0939615890, -0.2594550550, -0.0272139404, -0.6805557013, 0.1992399693, -0.0460784920, -1.2065075636, -0.2282819152, 0.7418883443, 0.0957848281, 0.4599505067, -0.0560635254, -0.1780059338, 0.0409427583, -0.1005161405, 0.1301065683, -0.0561739914, -0.0639833584, -0.1695795506, 0.2172777951, -0.0274519231, 0.0105696190, -0.1009241417, -0.5238429904, -0.0598659515, 0.1413746774, -0.1424420774, 0.0533991903, -0.1003924906, 0.1828837246, -0.2221373469, 0.1779504716, 0.3096951246, -0.0730945468, 0.0268525779, 0.2563087642, 0.0693273768, 0.0889493749, -0.0273046289, -0.2097426057, -0.1946727335, 0.0832975656, -0.0072953147, -0.1038919017, -0.1285175234, -0.6106995940, -0.1574313641, 0.0142572122, 0.0025158857, -0.0358565338, -0.0692517310, -0.0212028585, -0.1509634554, -0.3270462751, 0.0517639518, -0.0386347473, 0.0371860415, -0.4827359915, -0.3860225976, 0.0682557970, 0.1225937158, -0.1079473943, 0.8286141157, 0.0433397815, 0.0734800175, -0.1282344013, -0.4960208833, -1.5929900408, -0.2121555656, -0.1765774041, -0.0688592643, -0.0727096945, -0.1679884195, 0.0302267894, -0.4060500860};
# 18 "firmware/parameters.h" 2
# 1 "firmware/weights/b2.h" 1
# 12 "firmware/weights/b2.h"
model_default_t b2[128] = {0.0091578383, 0.3875782788, -3.0967524052, 0.0856144130, -1.7530295849, 0.7835469246, -1.9539134502, 0.4838931262, 2.9244723320, -0.3115911782, 0.6646181345, -0.1430331469, -0.0298186932, -0.0107755559, 0.9180214405, 1.6295468807, -0.0029752939, 5.0546145439, -1.6251498461, 0.5677705407, 0.8919630647, 0.5049057007, 0.4804704785, -0.0151106277, 1.0193500519, -3.4723198414, -4.1809663773, 0.9159045219, -0.0156303179, -3.1473767757, 0.2666823268, -1.7204735279, -0.8938208222, 0.1171720773, 0.3358182013, 0.3734935522, 0.4025105238, 0.0123702548, -0.1680475771, -1.1603310108, -0.0074616973, 0.6355409622, -0.0055588125, 0.4666038454, -0.0074812886, 0.3752532899, -2.5474846363, -1.0074284077, -0.0078215795, 0.7135077119, -3.2632572651, -2.2773919106, 0.5178546309, 0.4609689713, 1.3706570864, 0.3080162406, 0.9417778850, -2.4563357830, -0.0148931295, 2.6269438267, -0.3718152642, 1.6252243519, 0.0000000000, 0.2432685643, 0.2100860327, -3.7805602551, 1.2965414524, 0.0543715730, -0.8554210067, 0.2011522502, 0.0000000000, 1.1446174383, -2.2860169411, 0.2826586962, 0.9116984606, 0.1009530574, 0.8040983677, -0.0110493666, 0.8628247380, -3.2891676426, 0.0000000000, -0.0051261443, -3.4120092392, -0.0207911134, 0.4887482226, 0.3683825135, -3.3621721268, 0.0000000000, 0.4605242014, -0.0295227487, -0.0057815262, 0.5249351263, -2.1949381828, 0.0914412960, 0.2737594247, 0.3843483627, 0.5385629535, -0.0132359788, -2.6130521297, 0.2017444074, 0.3070446253, -2.7415189743, -4.9467644691, 0.0454913191, -0.0476372242, -0.0175144318, 1.5036118031, 1.1532508135, 0.5796478391, 0.1063619703, 2.1605541706, 0.9241333604, 2.0300507545, -2.6974847317, 0.1891667098, -0.1951070130, 1.1417847872, -1.1698333025, 0.8202671409, 5.5714282990, 0.4961552918, -0.1856904626, 0.3751883209, 0.0878971815, 0.9761484265, -0.0784506127, 0.0137611702, 2.9229803085};
# 19 "firmware/parameters.h" 2
# 1 "firmware/weights/w4.h" 1
# 12 "firmware/weights/w4.h"
model_default_t w4[32768] = {0.0247200150, 0.0268468838, -0.0847161040, 0.0214154422, -0.0159942526, 0.1244947612, 0.1571942717, -0.1180707514, -0.0459688567, -0.1253150553, 0.0116879093, 0.0118066519, 0.1137179732, 0.0446064472, 0.0147326393, 0.1239163131, -0.0916856453, -0.0730783418, -0.1272950917, -0.0408113301, -0.1249426454, -0.0467574894, -0.1020422205, 0.1085243225, -0.0061377301, 0.1400382072, -0.0381877944, -0.1117286086, 0.0754187182, 0.0616028681, -0.1392625570, 0.0166535564, -0.0075602946, 0.0264872201, 0.0431445539, 0.1223450154, -0.0444351956, 0.1130313575, -0.0348273367, -0.0566914529, -0.1203250587, -0.1061953902, 0.0072169644, 0.0485860221, 0.0118932836, 0.0091985455, -0.0302368905, -0.1389325410, 0.0154048456, 0.0733879805, 0.0880361572, -0.1129978299, 0.0612715185, 0.0508887805, 0.1047590598, -0.0570324361, -0.0788851455, -0.0859924257, -0.1264451146, 0.0051774587, 0.0010362982, -0.1220103428, -0.0399012379, -0.0100346981, -0.0749049336, -0.0948919654, 0.0662825853, 0.0265894439, -0.1073004305, 0.0996885523, -0.0912107229, 0.1236187890, 0.0540504456, 0.0686042309, -0.0743862092, 0.0543256700, 0.0515558831, -0.1125528514, 0.0123774111, 0.0270382706, -0.0972875655, -0.0123187844, 0.0334166959, 0.0605368465, 0.0509268604, 0.0388365611, 0.1037246883, -0.0075482572, 0.0014296174, -0.0079188049, 0.0638158917, -0.1340496093, -0.1023981050, 0.1170020401, -0.0727693737, -0.1054665148, -0.0674108341, 0.0285479575, 0.0716596022, 0.0916105881, -0.1187761500, -0.0225122683, -0.0130475163, 0.0376715697, -0.1190462857, -0.1117819175, -0.0266504511, -0.1216457784, 0.0760231540, 0.0286019742, -0.0758053362, 0.1166065857, -0.0569166839, -0.1087396964, -0.0024308998, 0.0387003087, -0.0171708576, 0.0322069451, -0.0556946099, -0.0289132390, -0.0453096628, 0.0896601602, -0.0504872240, -0.0931978226, -0.0681620389, 0.0401630178, 0.0114223044, 0.0583624542, 0.0107912747, -0.0535304546, 0.0763742924, -0.0396016873, -0.0486742854, 0.0417139754, 0.0137335062, -0.1020459607, -0.1013079658, 0.0455115288, -0.1182655245, -0.0615523458, -0.0292922910, -0.0016086850, -0.0150998617, 0.0783759132, 0.0778353959, 0.0198692121, -0.0749173164, 0.0269635916, 0.0822483599, -0.0833280981, 0.0123323845, 0.0875806361, -0.0912549198, -0.0542141944, -0.0316000432, -0.0527859181, -0.0569980778, -0.0062483912, 0.1292213351, 0.0603591166, -0.1022379100, -0.0881463587, 0.0727246776, -0.1077771783, -0.0148472926, -0.0017110109, 0.0196187198, -0.0354400687, -0.0513308980, 0.1029627025, -0.1040310785, 0.0796836242, 0.0208820850, -0.0048325160, 0.0042763129, -0.0033534372, -0.0501954891, 0.0666262656, 0.0757430494, -0.0493807942, -0.0940331593, 0.0148859201, -0.0621818490, -0.1084813997, 0.0572814047, -0.1234245896, -0.0646024048, -0.0411725044, -0.0711136237, -0.1086352915, 0.0077424049, 0.0554784536, 0.0424669981, 0.1131931692, -0.1026058495, -0.0580407605, 0.0465549678, -0.0272898059, -0.0885862112, -0.0122567881, 0.0653001368, -0.1107715890, 0.1116459221, 0.0615193956, -0.0161333308, 0.0179791488, -0.0576238558, -0.1096207276, 0.0508008525, 0.0730306134, 0.0187395066, 0.0027305968, -0.0314562097, -0.1127863973, 0.0463514924, -0.0002723471, 0.0072737862, 0.0871937796, 0.0158097092, -0.0454536714, 0.0736177713, 0.0620946884, 0.0455760509, -0.0849956647, 0.0698206946, -0.0725542083, -0.0038742423, 0.0675837845, 0.0731722713, -0.0458229184, 0.1256955713, -0.0706032366, -0.0250695646, 0.0797339827, 0.0991339386, 0.0844677389, -0.0765404329, -0.0022010328, 0.1095807031, -0.0665570274, -0.0314861909, 0.0964274034, -0.1314675659, -0.0009569440, 0.1141777337, -0.0151784131, 0.0176526196, -0.0098522305, -0.0652109757, -0.0648049861, -0.0943826735, -0.0813742727, -0.0780436471, 0.0019377257, -0.0509259403, 0.1238277853, 0.0076343054, 0.1541643143, 0.0680180192, 0.0928765759, -0.1424859911, -0.0263556112, -0.0527400672, 0.0856266096, -0.0223710202, -0.0274459291, -0.0997842625, 0.0762234554, -0.0665666386, 0.0175550319, 0.0474108048, 0.1373932809, 0.0214113630, -0.0381439552, 0.0412781164, 0.0651144981, 0.0111086946, 0.0446905568, -0.1241146103, -0.1181833521, 0.0468447395, 0.0835673064, -0.1520375013, -0.0384837314, 0.0070986361, -0.0699535832, 0.0369160213, -0.0613467433, 0.0195501968, -0.0939962640, 0.0534283482, 0.0994239450, 0.0232538674, 0.0238080099, -0.1090553626, -0.0117925014, 0.0807526782, 0.0593562387, 0.0871667489, -0.1184804142, -0.0532850027, 0.1331317127, -0.0901509151, -0.0282762535, 0.0478404276, 0.0797106102, -0.0856700316, 0.0474447906, -0.0837250650, 0.0189686753, 0.0187496655, -0.1998958290, -0.0164629165, 0.1345067769, -0.3201379180, -0.1483814865, 0.1100134775, -0.0974925458, 0.0008722607, 0.0993427709, 0.0134273171, -0.0781401172, -0.1368919313, -0.0471811369, -0.1166226119, 0.0452382006, 0.0335850604, 0.0872491747, 0.0484290421, -0.1864035875, 0.2718982399, 0.1824664921, -0.1321600676, 0.0271866024, -0.0008082471, 0.0690504462, -0.0860694498, -0.1429519206, -0.2109645754, -0.0240783375, -0.1620109677, 0.0814841762, -0.0454303585, -0.0892120376, 0.0912657976, -0.0405644365, 0.0726479441, -0.0336206444, -0.0345696174, 0.0424016640, -0.0660762861, -0.0093340240, -0.2090514153, -0.3370160162, 0.0083232960, 0.0049268338, 0.0406306796, 0.0614645816, 0.0252323151, 0.0107626608, 0.0605548881, 0.0794923156, 0.1031400561, -0.0106026530, 0.0388673134, -0.2679232359, 0.0388904251, 0.1126966923, 0.1140621826, -0.0879548118, -0.1050361618, -0.0000460165, -0.0575351119, -0.0532729886, -0.0266606472, -0.0660941601, 0.1045708805, -0.0751659647, -0.0131062986, -0.0603208467, 0.0603464097, -0.0991139263, -0.1128207520, 0.0977513641, 0.0523318201, 0.2168108672, 0.0041464171, 0.0706047788, 0.2206418514, -0.1206716374, 0.0291009713, -0.0111283744, 0.0069505963, -0.0795878842, -0.2063585222, 0.0493825711, 0.0920179486, -0.1091840416, -0.1091161743, -0.0575175732, -0.0171534140, -0.0093084769, -0.0239421315, 0.0772980303, -0.0982428566, -0.1486654729, 0.0463042967, -0.0905396491, -0.0160842575, -0.0114713302, 0.1099334657, -0.0256988276, 0.0781321302, -0.1275295913, -0.0275033731, 0.0616271347, -0.0868221819, -0.0456566364, 0.1186514422, -0.3691263795, -0.0858538970, 0.0701052472, -0.0257620383, 0.0518955737, 0.0765698999, 0.0101309149, 0.1084514037, 0.0204037316, 0.0715196207, -0.1025120392, -0.0853352100, 0.0556798317, -0.0486631952, -0.1038558036, 0.0781639367, -0.0135632278, -0.0721168667, 0.0510554351, 0.0419527143, 0.0272330418, -0.0005145660, -0.0452556014, 0.3285475075, -0.1123043224, -0.2060052156, 0.1290022135, 0.0249401182, -0.0669993609, -0.0415669940, -0.0545003042, -0.0021104822, -0.0620094500, -0.0133324014, 0.1044687703, -0.0664248466, -0.0651353002, -0.1085599586, -0.0282053426, 0.0275093969, 0.0241351034, 0.1231526732, 0.0205656029, -0.0722413883, -0.1077546030, -0.0455532223, -0.3082156479, 0.1085705236, 0.0580936000, -0.0107385265, -0.0511327274, -0.0036733211, 0.0118417908, 0.0978176519, -0.0645258501, 0.0695705265, 0.0006231866, -0.1097650006, -0.0053759255, -0.0593313277, -0.0658223629, 0.0140978182, 0.0264999717, 0.0001566356, -0.0722653717, -0.0120867947, -0.0557868853, 0.0693959668, -0.0647715405, -0.0065870048, -0.1857961416, -0.0495198593, 0.1194406971, 0.0736342147, 0.0521011315, 0.0251837764, -0.0012654166, -0.0513278693, 0.0285442881, 0.1851983666, 0.0675067678, -0.1039309949, -0.0751675367, 0.0169167090, -0.1670524031, -0.0715228170, -0.1007876024, 0.0663419440, -0.0797570348, 0.0212338977, 0.0973342285, 0.0944738463, -0.0785466060, -0.1657635123, 0.0565047376, -0.1856317073, -0.0457114428, -0.1025592014, 0.3498878777, 0.0337905586, -0.1007172912, -0.0003505925, -0.1457490474, -0.2079983503, 0.0207342748, -0.1432024688, 0.0189442504, -0.0284676645, 0.2725426555, 0.3050300777, -0.0226721298, -0.0948969722, 0.0279395338, -0.0764248297, -0.2073206306, 0.3577269018, -0.0558283590, -0.0219787546, 0.2074917704, -0.0188151840, -0.0494054668, -0.1227026805, -0.1291927248, -0.0659264624, -0.4681592286, -0.1026547179, 0.2880736291, 0.0279739797, -0.2088533193, 0.2262464166, -0.7209392786, 0.0192067809, -0.1583027691, -0.1368156075, -0.1523690373, -0.3292809427, -0.0964362323, 0.0226545557, 0.0028939629, -0.8881755471, 0.0066988468, 0.1073695049, -0.1460665762, -0.0384190716, 0.5780329704, 0.2691124380, -0.0246109441, -2.4609315395, -0.1244531721, -0.2497083992, -0.2713043094, 0.0452976488, 0.3439744413, -0.0470559783, -0.0391932614, -0.0744752139, 0.0733843148, 0.0286023077, -0.0321883634, -0.0084431255, -1.0207604170, -0.0737272352, -0.0396729186, -0.1346183270, 0.6130788326, -0.0197694022, -0.7124145627, 0.0803906843, 0.1400836110, 0.4123519957, 0.0270488188, -0.0835950077, 0.0125185363, 0.0059925281, -0.1028563455, 0.0861880854, -0.3848082423, 0.0749099180, -0.1485592723, 0.0523975566, -0.0734369978, 0.0965702757, -0.0861512721, 0.0467731468, -0.2213275135, -0.0564040169, -0.1400997937, -0.0085545927, 0.0173417423, -0.7489884496, -1.3577580452, -0.0010019746, -0.0063102394, -0.1264236569, -0.1198883653, 0.0120584406, -0.0919240564, -0.1069957018, -0.0585001707, -0.0062834355, -0.0883548707, 0.1777788550, -0.1165150478, -0.0736455694, -0.4305372834, -0.0360418148, 0.0817878991, 0.2503930628, 0.1115266085, -0.1674909294, -0.0878642723, -0.0859863162, -0.0219399668, -0.1260659248, 0.1175918952, -0.5576258302, -0.5725816488, 0.0277280267, 0.1861597300, -0.1234089956, -0.0459185652, -0.0280303750, -0.1937289238, -0.4403441846, -0.1566127390, -0.0373521075, -0.0701254681, -0.2378580719, 0.4509539902, -0.0331525207, 0.0305700544, -0.0337829888, 0.3489996493, -0.0756784454, -0.7058042288, -0.3420448899, -0.0935383886, -0.7485403419, -0.2252004147, 0.0115265893, -0.0745103508, -0.0384800509, -0.0804925859, -0.2647540569, 0.2761211395, 0.0235637650, 0.0379935093, 0.3584661782, 0.0336589552, -0.2532387078, 0.0101629607, -0.9510018229, 0.0096928924, 0.0116553875, -0.0091918027, -0.1166321263, -0.1034154296, 0.0432029963, -0.1766149551, -0.0637203380, 0.2436713874, -0.5140844584, 0.0281282477, -0.1499686092, -0.3902946413, -0.1735463887, -0.1076147333, -0.0737199411, -0.3362047672, 0.0265857130, -0.0773397684, 0.0140908659, -0.8335097432, 0.0548873693, 0.0093760062, -0.3576536775, -0.0541915819, 0.0776736289, -0.1459378153, 0.0319046751, -0.0606541224, -0.4022701979, 0.1429929286, -0.0433948375, 0.0694717914, -0.1040531099, -0.3900822699, -0.4764310122, -0.1265688539, 0.6397728324, -0.5521255136, 0.3807139993, 0.0141870808, 0.0129309939, 0.1683790684, -2.6524937153, -0.4884081185, -0.3099050820, -0.2134169936, -0.1559189409, 0.0009799124, -0.0077961045, -0.0338885300, 0.2671613097, -0.0197603274, -0.0231701024, -0.3245965242, -0.1077948064, -0.0301874094, 0.0559147969, 0.5090388060, 0.1092262864, 0.0217013489, -0.1141415313, -0.0011152705, -0.4626052976, 0.0099116256, 0.0206421819, -0.1302931607, -0.1103883907, 0.1572254449, -0.3453325927, -0.0757601634, -0.1231559664, -0.1604587436, -0.2272159159, 0.3903929293, 0.1680592149, -0.0022344547, 0.1999953687, 0.4534856379, -0.0978948101, -0.2041499019, 0.3027109802, 0.3259627521, -0.2568135858, -0.1359028220, -0.1065539196, 0.0345478505, -0.2247992307, -0.0514577851, -0.3984960914, 0.4311153889, 0.0135817127, 0.3492653370, -0.0659675077, -1.1677368879, -0.1752217263, -0.4441678524, 0.0798045099, -0.0536641628, 0.0937039331, -0.0799288377, 0.0400219969, 0.0226672143, 0.0023186174, -0.0128204115, 0.1035438702, 0.0617718846, -0.0570758320, 0.1416151375, -0.0227541775, -0.0937861651, -0.1039082259, 0.0698816478, -0.1007838994, 0.0383276567, 0.0626713634, 0.0304817203, 0.1080470160, 0.0691290200, 0.0720817819, -0.0246077832, -0.0402619839, 0.0508878529, 0.0761791393, 0.0429391414, -0.0782879069, 0.0338351652, -0.0019946597, -0.0820687711, -0.0080634858, 0.1194095090, -0.0121515896, 0.1319904476, 0.0714436769, 0.0318297483, 0.1077687815, -0.1180903912, 0.0459540896, 0.0174140334, 0.0066710077, 0.0657391995, 0.0392226875, -0.0059732692, -0.1057720408, -0.0647050515, -0.0733525902, -0.1073455289, -0.0498788469, -0.0237358250, 0.1095351204, -0.0699040368, 0.0890535265, 0.0166819841, -0.0724488124, -0.0212233644, -0.0152133843, -0.0510667637, 0.0448832363, -0.0329674780, -0.0484343208, 0.0166118890, 0.1129909456, -0.0523164421, 0.0400055014, 0.1551826596, -0.0822593197, -0.0897405595, 0.0336127058, -0.0557044037, 0.1228994429, -0.1019758657, -0.1246269569, -0.0775098130, -0.1384883523, 0.0017613076, 0.0235030018, 0.0448684767, -0.0010510492, 0.0331836045, 0.1098896861, 0.0069690966, -0.1123432294, -0.0788751021, -0.0497354865, 0.0360143259, -0.0863464698, -0.0780970827, -0.1126837209, -0.0977016687, 0.0528712459, -0.0428955667, -0.0072841905, -0.0812367946, -0.0739167929, -0.0611229092, -0.0273581203, 0.1216101348, -0.0481185541, -0.0149753494, -0.0743192360, -0.0028588520, -0.1000483856, 0.0868901536, 0.1327513456, 0.0625822917, 0.0489406660, 0.0989408940, -0.0827966183, 0.0878889263, -0.1128833070, -0.0436127745, 0.0138503201, -0.0021924854, -0.0839179531, 0.0158426668, -0.1138878688, -0.0673828870, -0.0611147322, -0.0744708106, 0.0508790463, -0.0691772774, -0.0451053269, -0.0867962316, 0.0737076551, -0.1005002782, -0.1282249838, 0.0308278818, 0.0276678689, -0.0719610527, -0.0748501793, -0.0966719463, 0.1107060239, -0.0159338973, -0.0631639585, 0.0648310110, -0.0105786026, 0.1079677045, 0.0354800411, 0.0335233919, -0.1269205362, -0.0762596503, 0.0919939727, 0.0186459888, -0.1171404123, 0.0521715879, 0.0291901529, -0.0200449750, 0.0027743739, 0.0997291133, -0.0642229989, -0.0457451642, -0.0314449966, 0.0391071141, -0.0786314458, 0.0051010191, 0.0189620350, 0.0042526219, 0.0670515373, 0.1003065631, 0.0801364928, 0.0059698657, 0.0753526017, 0.1151099280, -0.0112689259, -0.1123623922, 0.0071452460, -0.0232838839, 0.0147127425, -0.0851610377, -0.0702957362, 0.1884288341, -0.0917650536, 0.0055850637, -0.0265635457, -0.1188050732, 0.0216665287, 0.0909470990, 0.0564789996, -0.0048633590, 0.0792867541, -0.0387132354, 0.0073382119, 0.0963869318, -0.1493544728, -0.1093157381, 0.0240225904, 0.0616919398, -0.0181223322, -0.0653997958, -0.0220206138, -0.1239515394, 0.0074166553, 0.0344540812, -0.0091652330, -0.0505792871, 0.0229997039, 0.0690604970, 0.0949091092, -0.1162515804, 0.0076559251, -0.0911156386, -0.0630793273, -0.0547226854, 0.1805739850, -0.1304908097, 0.0872129649, -0.0758378878, 0.0738898963, 0.0093439836, -0.0111918803, 0.0026119431, 0.0319414288, 0.0228097029, -0.1063929796, 0.0416433923, 0.0588370413, -0.1032089144, 0.1127457619, 0.1192234531, -0.1132956967, -0.0428197533, -0.0148711568, -0.1044830531, -0.1025334448, -0.1232161373, -0.1075040922, -0.0641680732, 0.0871374905, -0.1017238721, 0.0093128486, -0.1035251319, -0.0130244391, 0.0461462401, 0.0553296208, 0.1230976433, 0.0874885693, 0.0782242566, -0.0047889138, 0.0511452593, -0.0949625745, -0.0674632117, -0.0716169924, 0.0736923069, 0.0929831639, 0.1366806179, 0.0190628562, -0.0462607220, -0.0958763286, -0.0022224060, -0.0201879907, -0.0111412574, 0.0214955229, -0.0079947244, 0.0256473515, 0.1019407362, -0.1500480622, -0.0377372093, -0.1265214533, -0.1872943491, -3.3932731152, 0.1310319901, -0.0263304450, -0.2078052163, -0.1144496948, -0.1018593162, 0.6856493354, -0.0450742543, -0.0184270367, -0.0958330780, -0.1101481542, -0.0019949172, -0.1858610511, -0.0251508541, -0.1866400391, -0.0203492027, 0.1210947633, -0.2928231657, -0.0051734103, -0.8607550263, -0.1959266812, -0.1774612516, -0.0414628386, -0.0778098851, -0.3271713555, -0.5165364742, -0.0307055302, 0.1903810948, -0.0905075446, 0.0114176366, 0.2048011273, -0.1398636103, -0.0004180159, -0.0232459418, 0.0084951306, -0.0230511744, -0.4117400944, -0.2265890241, 0.0198353082, 0.0219276082, -0.0439231656, -0.0161222573, -0.1061768681, -0.1556442231, -0.0108714439, -0.7405833006, -0.0269191470, -0.1855781674, -0.1661027521, 0.2744843364, -0.0810527653, -1.6360592842, 0.3188582361, -0.1457764655, -0.3246096373, -0.0717520490, 0.1396907270, -0.4559026062, 0.0047741849, -0.0368198156, -0.0077599226, -0.6007363200, -0.0780613497, -0.1467527300, -0.1230172440, 0.0604507960, -0.0933458507, -0.9334561229, 0.1302061677, -1.3549059629, -0.3206006587, 0.0474012084, -0.1273537278, 0.1267875135, 0.0171022769, -1.2074739933, -0.5934535265, 0.0516394712, 0.0948734656, -0.1111561060, 0.0128314728, -0.1544333845, -0.3161842227, -0.0939127505, -0.2615040839, 0.0976408646, -0.0930209383, -0.1195174903, 0.0125772385, -0.0752150342, -0.3641434610, 0.1021555737, -0.2058769017, -0.0019192751, -0.3378454149, -0.0231911018, -0.0512282625, 0.0000423000, -0.1823885590, -0.9353687167, -0.0050528338, -0.0033881713, 0.0488694385, 0.2522849143, 0.0080918483, -0.5447226167, -0.5306113958, -0.1761734933, 0.0043444675, -0.5569560528, 0.0131653035, -0.0450030304, -0.0714627877, 0.2408668548, 0.7571787238, -0.0428079627, -0.0690217018, -0.1230519563, -0.1011290997, -0.2330710143, -0.1505650431, -0.0803625584, -0.1576848626, 0.0239274893, -0.2153393626, -1.0724616051, 0.2409494817, -0.1835133731, -0.1091466174, -1.0349012613, 0.0075622685, -0.0968990102, -0.4953422844, 0.2848712504, -0.1389326751, 0.2946089208, -0.0642417893, -1.3431473970, -0.2617005408, -0.1951454878, -0.1447175145, -0.1015480384, -0.0071836878, 0.0344059095, 0.0498934351, -0.6910850406, -0.1871895641, -0.1392149329, 0.2835049331, -0.0678508282, 0.7437719703, 0.0000301907, 0.1536392272, 0.0093822451, 0.0395105220, -0.0773746744, -0.3557166457, -0.6625204086, -0.0205211602, -0.1126842871, 0.0303619243, -0.5747813582, -0.3961667120, -0.0410952382, -0.0531837456, -0.8549078107, 0.0149322301, -0.2584316432, 0.5723561049, 0.0105454158, -0.1216841117, -0.0314095281, 0.0316709317, -0.7329066992, -0.0276730768, -0.0296075456, 0.5127768517, -0.0374559499, -0.0143852346, -0.1518882364, 0.0452121012, 0.0246609915, -0.4976579249, -0.0713722408, 0.0346446410, -0.0578570366, 0.0695560500, 0.4104986191, 0.1874295771, -0.0505642444, 0.3940786123, -0.5940597057, 0.0897686481, -0.0636495724, -0.1010017022, -0.0702942386, -1.5858908892, -0.2298343182, 0.0291836392, 0.1064828560, 0.0123381894, -0.0610164106, -0.0227420162, 0.3117270470, -0.0916774720, -0.2420573682, -0.3281259537, 0.2419883758, -0.1675345749, -0.1789320558, -0.1715168208, 0.1303132474, -0.1993235201, 0.0407157056, -0.0612923391, 0.0464581475, -0.2083458602, 0.0259561818, -0.2020534426, -0.2866652310, 0.0319543481, 0.4233029783, -0.4064624608, -0.0786013082, -0.0399198644, -0.0463884659, -0.2742494345, -0.1215057075, -0.0883304253, -0.1768932194, -1.0021781921, -0.1564066559, 0.1776129156, -0.4420809150, 0.0422930606, 0.2403529137, 0.2352130115, -0.1594056487, -0.1317852736, -0.0892581418, 0.3268511593, 0.0723371953, -0.4506210089, -0.5325388908, -0.0176813006, -0.1761955023, -0.0337589420, 0.1096998602, -0.4346438944, -3.1230869293, 0.2211355120, 0.0235866588, -0.1333825290, 0.0662800074, -0.1192027330, -0.0031287572, -0.0103925616, -0.5486974716, -0.1371270865, 0.0490908176, -0.0078762742, -0.0816946328, -0.4483650923, -0.1359818280, -0.0277461037, -0.5732874870, -1.4747245312, 0.0243615899, 0.0233249459, 0.0797346979, -0.0642945990, -0.5630193949, 0.3994585872, 0.0823533237, 0.0102461521, -0.1026761830, 0.1132976115, -0.1207879409, -0.1238536835, -0.2032201588, -1.1511540413, 0.5030256510, -0.0503041483, 0.2183350772, -0.0447133034, -0.1488114297, -0.0336854421, 0.1442630738, -0.1609189957, 0.0576046482, -0.0703484714, -0.1979549080, -0.1532295644, 0.0824422091, -0.1209960878, -0.5301309824, 0.3337418735, -0.2476983368, -0.1202460751, 0.0189058352, -0.0250840057, 0.4517925382, 0.5219287872, -0.0896576419, -1.1352320910, -0.2492402345, 0.3652244806, 0.4079445899, -0.1429147571, 0.4654708505, 0.8244798779, -0.1921669394, -0.0943735838, -0.2220602930, 0.0315676592, -0.0515337028, -0.0010054198, 0.4345456958, -0.0495201349, -0.1752357334, -0.0699071437, -0.2900169790, -0.1144794077, -0.7130391002, -0.1976299435, 0.3193846345, 0.2419753522, -0.1472476423, -0.0397325046, -0.0208083205, -0.1064516678, -0.1181249022, 0.2082796842, -0.2018381953, 0.3177320361, 0.0712831467, -0.0775443017, -0.0903364420, 0.3942190111, -0.0674940422, 0.4582633376, 0.0142667536, 0.0653663948, 0.0417362638, -0.0803556442, -0.0035735322, 0.5568819046, -0.4129074216, -0.0614989661, 0.0277149659, -0.1293013245, 0.0768042132, -0.0064046527, 0.0328202993, -0.0185360909, -0.6307703257, -0.0280612707, -0.1105976775, 0.0190906413, 0.2823580801, -0.1075415388, 0.0438113995, 0.1821523309, -0.0739759430, -0.3446947932, -0.1303607821, 0.4367672801, 0.0216827970, -0.0687209964, -0.7853538990, -1.1434395313, -0.1440483332, 0.4767198861, 0.0609199032, -0.0801027864, -0.3335719705, -0.1909566522, -0.0150115527, 0.1101888791, -0.3028970361, 0.6502400041, -0.7526177764, 0.3076322079, -0.0455890968, 0.3086314797, -0.0087867910, -0.0538029373, -0.0135745909, 0.7258354425, -0.7834637165, -0.1100603268, -0.7387633324, 0.0040748855, 0.0020667422, 0.1113973260, 0.0664181113, -0.0797534883, -0.0761653185, 0.0455568098, 0.0013261753, -0.0319439247, -0.0129198860, 0.2206461430, 0.4919385910, 0.6020065546, 0.0877513289, -0.4664014280, 0.0161839053, -0.4037213624, 0.0113096526, -0.1495937407, 0.0936586782, -0.1685283631, -1.4413231611, -0.0222220235, -0.1529080570, -0.0155640226, -0.4016700387, -0.7597115040, -0.0293255951, -0.0050826580, -0.2750439048, -0.0721371770, 0.0429115593, -0.3924493492, -0.3870156407, 0.0439376272, -0.0240543671, -0.0175664723, 0.4633063078, 0.4547247291, -0.1120343655, 0.3446536362, -0.0037068543, -0.1399248093, -0.1587764025, -0.0008673813, -0.0025891508, 0.7610272169, -0.7396383882, -0.0050410219, -0.0162252840, -0.0409270972, -0.1839102358, 0.7456256151, -0.3564201593, -0.6674669981, 0.1407882124, -1.2616173029, 0.0795374438, -0.0617668107, -0.4203657210, -1.4129338264, 0.1140633374, 0.4415871203, -0.3637249470, 0.6264082789, -0.0863588527, -0.1023337618, -0.8379805088, 0.2018942535, 0.0008058098, 0.0206953939, -0.2013527304, 0.0177174304, 0.3745693862, -0.0825372264, 0.2964007854, 0.3943153322, -0.1613860875, -0.1783801764, -0.3864001334, 0.5862780809, 0.0476404615, 0.1398819536, -0.3450258076, 0.1012029350, -0.0427093804, 0.4666238129, 0.0854695365, 0.0091555649, -0.2271609604, 0.0828326792, 0.3121137917, 0.5322511792, -0.0164007880, 0.1221672744, -0.0977303013, -0.1221077517, -0.0786214918, -0.0200530998, 0.3028140962, 0.7065262794, -0.0911346674, -0.0975896865, -0.0069185677, -2.1437838078, 0.0197258461, -0.0196509808, -0.8531670570, 0.0445425026, -0.0622554570, -0.0285263211, 0.3339629173, 0.2665066123, -0.4837017357, 0.0804356560, 0.0092406822, 0.1703484505, -0.1500380784, -0.0125788460, -0.6360452175, -0.0082046660, -1.0470792055, -0.1132319197, -0.1759811938, 0.2741126716, -0.0504444689, -0.5261970162, 0.0680444613, -0.1400191784, 0.0963892639, -0.1846768856, 0.0057569416, 0.0291336328, 0.0029056277, -0.0482102782, -0.4150067270, -1.3619461060, -0.4898236990, -0.0004256514, -0.0646601468, -0.0368921123, -0.0107487673, 0.0564357527, 0.0564447828, -0.3214005530, -0.1002580523, -0.2278117537, 0.0191706270, -0.0436295159, -0.0492160246, -0.1213009655, 0.0837892741, -0.0109866224, -0.0650090277, -0.0282377936, -0.0816267356, -0.0497945361, -0.0184892863, -0.5646458864, 0.1139997244, 0.4177591801, -0.0459185764, 0.1067754254, -0.0249392875, 0.0565237701, -0.1576073170, 0.1222930923, -0.1301492155, -0.2082701325, -0.1618142277, -0.0556115285, 0.5832149386, -0.4114204645, 0.0071775997, 0.2109909058, -0.1939532757, -0.0565259270, -2.2038671970, -0.0395723507, 0.0659288093, 0.0138505818, -0.3361827433, -0.1030989736, -0.0418469347, -0.0366021842, -0.5035837889, -0.0350927114, 0.2850726843, -0.2791452706, 0.1389667839, -2.7000672817, -0.1072083190, 0.0040236250, -0.0465941466, -0.0759782717, -0.1220166832, 0.8466018438, -0.0999789834, 0.0895256698, -0.1620430797, 0.0688751787, -0.0582752563, -0.5833534002, -0.0730693340, 0.0402441882, 0.0165952221, -0.1524036527, 0.0645759776, -0.1682034731, -0.1654680520, -0.4881961942, 0.0020302671, -0.0382011160, 0.0167465806, -0.6197685003, -0.1043012813, -0.0629133806, -0.2759239972, -0.0761680007, -0.3077249825, -0.0080701821, 0.0239805169, -0.0953423381, 0.0730205178, 0.0063912314, -0.1005524024, 0.3332758844, -0.0556989238, -0.1942389756, 0.0879864097, -0.0942509398, -0.2461710274, -0.0061510252, 0.0092503587, -0.0111446930, -0.0209367052, 0.4038953483, -0.0814787447, -0.0994380116, -0.3684622347, -0.0180917326, 0.0751382560, -0.1436571628, 0.0578537956, 0.2541985810, 0.2349412888, -1.3765326738, -0.0160929840, 0.4394816458, -1.0799355507, -0.1067310348, -0.0765094310, 0.3871535361, 0.1190818921, -0.1078685969, -0.1442993432, -0.0731976181, 0.2795757353, 0.2394724637, 0.0077564265, -0.2587374449, -0.1032599434, -0.0250841547, 0.0247183125, 0.0125163645, -0.0690754130, -0.2543016374, -0.8455232978, -0.3918790817, -0.1003692076, 0.2675279975, 0.0391798727, -0.1841334850, 0.0391202606, -0.0154811125, -0.0858967453, -0.1169142053, 0.2298244834, -0.0577899627, -0.0606829412, -0.0115795359, 0.2910186052, -0.2797301710, -0.1102437973, -0.1438489407, 0.2649277151, -0.0062547545, -0.1233839393, 0.2911733687, 0.0558259077, 0.0343195908, -0.1126253158, 0.0280523691, -0.3082277477, -0.8190162778, -0.0962815657, 0.4207673669, -0.0819707587, 0.0232644621, 0.1189293489, -0.2262488604, 0.0522485189, -0.0735546872, 0.0974620804, -0.0798371881, -0.0481922328, -0.1297519356, -0.2575727701, -0.0459263809, -0.6497910619, 0.4387699664, 0.0654454976, 0.2305272520, -0.1580225378, -0.1399749964, -0.2276541889, 0.4919324815, -0.2995472252, -0.2556292415, -1.6003310680, -2.2777509689, -0.1179662421, -0.0479341187, -0.2978885174, 0.0258660484, -0.0959410071, 0.0743227452, -0.5759664178, -0.1556443423, -0.2007242441, -0.0282825325, 0.0213719606, -0.4776454270, -0.0430613086, -0.0062680505, -0.2189405859, 0.0116286092, 0.0554019250, -0.0284309518, -0.2405660599, -0.1182278246, 0.0254639033, -0.8767660260, -0.0933617875, -0.0224296730, -0.1791860461, -0.0241608918, -0.0821035430, -0.8152392507, -0.0085361302, 0.2721367478, -0.0942359939, 0.0868475884, -0.1486882567, -0.3761275709, 0.2498191297, -0.4637050927, -0.1033636108, -0.1268137544, -0.2188858092, -1.4891934395, -0.0474763103, -0.0137015237, 0.0364678502, -0.0097658522, -0.4591714740, -0.0637084916, 0.3522240818, -0.2499008328, -0.5073559284, -0.0688634291, 0.1439598948, 0.0738606825, -0.1564946920, -0.0427971743, 0.2912943661, 0.0165561046, -0.2362382114, 0.0301241148, 0.1493756175, -0.1076418757, -0.0586103275, -0.0931501761, 0.0920387954, 0.0505786240, 0.1176002175, 0.0233937539, 0.1287221611, -0.0350529402, -0.0153767504, -0.1166330129, 0.0206614323, -0.0992282704, 0.0491532311, 0.0150869777, -0.0724342018, -0.0374821946, -0.0130812572, 0.0054150149, 0.0372808278, 0.0238600057, 0.1042229459, -0.0402480289, -0.0607060641, 0.0436659567, 0.0522113070, 0.0703813657, 0.0195386298, -0.0209202114, -0.0730711669, -0.0488805473, -0.0770213902, 0.0304095075, 0.0353437848, -0.0299118143, 0.1698018014, -0.0053583751, -0.1279959679, 0.0411021970, 0.0052744658, 0.1084045544, -0.0020856804, 0.0294482298, -0.0424242280, 0.0591200069, -0.0546534397, -0.0653493479, 0.0840022042, -0.0731418878, -0.2014242858, -0.0315282531, 0.0371898599, -0.0625677705, -0.1085436344, 0.1153339297, -0.0383758880, -0.0891718566, 0.1337735206, 0.1831199825, 0.0789972916, -0.0328233317, 0.0004799730, -0.1464585066, 0.2465274036, -0.1285967082, 0.0163658820, -0.2653182447, -0.1000424549, -0.0198872890, 0.0546916462, -0.1308594942, -0.3167168498, -0.1462295949, -0.0145668471, 0.2744381726, 0.2339614481, -0.1304822415, -0.1259645224, -0.4212670028, -0.0703068674, 0.0871795863, -0.0075199180, -0.0667108446, -0.0234046150, -0.0523044728, 0.0100360969, 0.0962149724, -0.3207717538, -0.0716830194, 0.0208104160, -0.0471982732, -0.0475876518, 0.0265281554, -0.1264813542, -0.0273128171, -0.0590301044, 0.0685411319, -0.0206290241, -0.1347050965, -0.0884981379, -0.1685416251, 0.0424933434, -0.0748466998, -0.0239842199, -0.0734782293, -0.0643401369, -0.0543209463, 0.0322147906, -0.1254721731, -0.0113494340, -0.2233774364, -0.0790250376, -0.0585212409, 0.0796300247, -0.0049010143, -0.2506982088, -0.0938386023, 0.0234590843, -0.0424502641, 0.0216162372, 0.1526215374, -0.0246360935, -0.0241797213, -0.2327478677, -0.1569726914, 0.0134082744, 0.0393295549, -0.1146372855, 0.1721359938, 0.1431608200, -0.0485370457, -0.0036565142, 0.1096666232, -0.0139370747, -0.0364028923, -0.0089438930, -0.0246274192, -0.0044319117, 0.0153413098, -0.1003907025, 0.0910020098, -0.0700471550, 0.2109551132, -0.2704674602, -0.1884218603, -0.1500039995, -0.2390494049, 0.0523627810, -0.2552131712, -0.0202140082, -0.0815070346, -0.0599964038, 0.0109340381, -0.0645776317, -0.0515026003, -0.1111401990, 0.0079155574, -0.2487229705, 0.0162812583, 0.0921403244, 0.0654631779, -0.1418446898, 0.0100479890, -0.2404788285, -0.1460866779, -0.0304487161, 0.0917247087, -0.2004600912, -0.0711260960, 0.2737042010, -0.0589023605, -0.0324572176, 0.0519470684, -0.0991440713, -0.1199199334, 0.0296249148, -0.3776662052, 0.1055707783, -0.0964745209, 0.1807244569, 0.0226229262, 0.0917511359, 0.0065926630, 0.0344685875, -0.0308716819, -0.0468713194, 0.0177980959, -0.0436843485, -0.0325844772, -0.0101178112, 0.0111868130, 0.0276968926, -0.1135974005, -0.1350928545, -0.0131882774, -0.1261201352, -0.0830568820, 0.0965255275, 0.0365629606, -0.0709607676, -0.0040632100, 0.0326374099, -0.0330903754, 0.0231923126, 0.0723109618, 0.0304113347, 0.0731213093, -0.0165746789, 0.1684703380, -0.0878884345, -0.0533016995, 0.0623645484, 0.0525196195, 0.1216570809, 0.0786168948, -0.0154000856, 0.0415628999, 0.0086741876, -0.1131201461, -0.0048756637, -0.0165750049, -0.0113117723, -0.1498840004, 0.3151746690, -0.0089653181, 0.1072003841, 0.0531825051, -0.0216677710, -0.0960838944, 0.0691502988, 0.1409877539, -0.0004993248, 0.0220778566, 0.1002770737, 0.0352315493, 0.0367231295, 0.0159729812, -0.0018115180, -0.2337753773, -0.0609826222, 0.0197694153, -0.0230125189, 0.0864458755, -0.1752294898, 0.4002065361, 0.0190836471, -1.0077320337, -0.0781192929, 0.3261810243, 0.1147136465, -0.0310413614, 0.4592576921, 0.0263740178, 0.0941515714, 0.0053820438, -0.0551039726, -0.1517421156, -0.0187898483, 0.2497718334, 0.0792450458, 0.0280083902, -0.3583024144, -1.2009584904, -0.0110128298, -0.0943636894, -0.2121956348, -0.2033715695, -0.0427142084, -0.5599461794, 0.0057874587, 0.0079642944, -0.0021989315, -0.0001004035, 0.0182788298, -0.0140847247, -0.1831217110, -0.0985468253, 0.0972587615, -0.0520954467, -0.1641412526, -0.1049207151, -0.1437854320, 0.2747450769, -1.4512544870, -0.0444258377, -0.0232490543, -0.0559107028, -0.1495278031, 0.3198367655, -0.0203973465, -0.0668358952, -0.8422776461, -0.6616116762, 0.0441299863, -0.0726133063, -0.0680090562, -0.1237415373, 0.2098590732, -0.1037904099, -0.0234770048, -0.2886030078, -0.1158090308, -0.5900139809, 0.8146965504, -0.0262957215, -0.9561221004, 0.5509480238, -0.1743027568, 0.0486593060, 0.2407556772, -0.0233687907, 0.0179533884, -0.0183846503, -0.3681663871, -0.2591114342, -0.0160799529, 0.0430412069, 0.0125391427, 0.1042295992, 0.0104797417, -0.1021385491, -0.2328591645, -0.9491909146, 0.0444640480, -0.0444925763, -0.0677886605, -0.1455036253, -0.7217745781, 0.2007747889, -0.1521180421, 0.0742126778, -0.0101278611, 0.0080022737, -0.0699170232, -0.1604027152, -0.0518476851, 0.2152699381, 0.0973507389, 0.0055902521, 0.0655355453, -0.1042132378, -0.1217723936, -0.5887833834, -0.6276941895, -0.0581007823, -0.0181693621, -0.3401187360, -0.0126217874, 0.0838006362, 0.1281718463, 0.0335330814, 0.7264737487, -0.0098942146, -0.0441208407, -0.1253429055, -0.1652094275, -0.1528995782, 0.1472796500, 0.4029480815, -0.1080914587, -0.1609152555, -0.8909927011, -0.8908225894, -0.1138494313, 0.0161183570, -0.2444520146, 0.4634268880, -0.0248144008, 0.4956240952, -0.0227711946, -0.0233880132, -0.5860903263, -0.0942202434, -0.1617634147, -0.2317961454, -0.0568619147, -0.0915894508, 0.3331270516, -0.2222776860, -0.1913983077, -1.9680261612, -0.1294532567, -0.1633915007, -0.0937766433, -0.0423042960, 0.4713465273, -0.1810471565, 0.1742585748, 0.0409966856, -0.2200457901, 0.4964197278, -0.2496421337, -0.3726503253, 0.0174327102, 0.0078579159, -0.0199077204, 0.0169913489, 0.2457733750, -1.0701586008, -1.0649994612, -0.5887230635, 0.1008045897, 0.0360439532, -0.2214611173, 0.0965885520, 0.0610178337, -0.1465807408, 0.0259671118, -0.0827271342, 0.4923532009, -0.0282010976, 0.0196918435, 0.0305267088, -0.5191721916, 0.4336768389, -0.1435596645, -0.0076365853, -1.0119776726, -0.0283345003, 0.1165286005, 0.0389811918, -0.0507259369, -0.1220310479, -0.4693525732, -0.0137591576, 0.3802378774, 0.5268854499, -0.0204539560, 0.3196975291, 0.0113690533, 0.0669224262, 0.0812782124, 0.0847220272, -0.0779641494, 0.3974100351, -0.0486641489, 0.0432944857, -0.0355805457, 0.1047536209, -1.2178561687, 0.3560518920, -0.3019306958, -0.1224928722, 0.0234833434, 0.0918402225, 0.0792978108, -0.1154901758, -0.8655493855, -0.3790049851, 0.0612162612, 0.3946539164, -0.6088604331, 0.5215092897, 0.0325921252, -0.0455779359, 0.1560177803, -0.6561174989, -0.0761042237, 0.0513155311, 0.1294268668, -0.1037711203, -0.1680532545, 0.0911720619, -0.8925085664, 0.0916569903, -0.0686856285, -0.1308654994, -0.0486233495, 0.4463508427, 0.0497189686, 0.0512324125, -0.4890629947, 0.1051633656, 0.2337995172, 0.3487119079, -0.1035229936, 0.1062188447, 0.0779149830, 0.2603105903, 0.1224398687, 0.2019653469, 0.0087977285, -0.1472908109, -0.1486397237, 0.1462836713, 0.0854745582, -1.4200263023, 0.1943039149, -0.0350310169, -0.1394041181, -0.0317066684, -0.2415494472, 0.0863952339, -0.0836252272, 0.6024782062, -0.7004060745, -0.1127208471, 0.0440856591, 0.0917811245, -1.1071513891, 0.3366492689, -0.1662881076, -0.0795469135, 0.1368939728, -0.1043913141, -0.0734169334, 0.0056530652, -0.0682312399, 0.0084642470, 0.5385338664, -0.0396439545, 0.0128163993, -0.3614345789, -0.0550428852, -0.0662214309, 0.0689183548, -0.0136118308, -0.0342150554, 0.2365224510, 0.0097463038, -0.1914680898, -0.0610841401, 0.0403295308, -0.0211330913, -1.6192868948, -0.4843588471, -0.0136015639, 0.0431738533, -0.2020603120, -0.1012106240, -0.1405489296, -0.2443408668, -0.0933387280, 0.0824167579, -0.0034131086, -0.0279549714, -0.0368167162, -0.3479643464, -0.2410806715, -0.0354951918, -0.0227967259, -0.0809702128, 0.0649054796, -0.0524624437, 0.1928180158, -0.0294707771, -0.7583035231, 0.5255225301, -0.6371185184, 0.0038997722, -0.0791339651, -0.0474219024, -0.0470625795, -0.4477889240, 0.0526757352, -0.1100078374, -0.2195028663, -0.0757165849, -0.1206339523, -0.1731034815, 0.2090633214, -0.4233717322, -0.0717270821, -0.0117182070, -0.0798002258, -0.1499199271, -0.1142306477, -0.1202892587, 0.0057789795, 0.4546464086, 0.0170959029, -0.0102470247, 0.0172061529, 0.3367578685, 0.0771643221, 0.7609810233, -0.2694817185, -0.1157329902, -0.4415901005, -0.0731276646, -0.0571275279, -0.0677957758, 0.0398211107, 0.1307858229, 0.4026479721, -0.1664937586, 0.0218444727, -0.0561184585, -0.0790217817, -0.2137962580, -0.1777729988, -0.0230097696, -0.1234813407, -0.0443663672, 0.0313352644, 0.0666788593, -0.0584422275, -0.0009383727, -0.3447592556, 0.1452407241, -0.2628397048, 0.0149430232, -0.1799575686, 0.0054655313, -0.0419976525, 0.0693050101, -0.0803066269, -0.6660500765, -0.0077610570, -0.0973544717, 0.1274120808, -0.1741850078, -0.1493802369, 0.1479750276, -0.5102066398, -0.1684003174, -0.0392203219, -0.2632469833, -0.0960872695, -0.2630347908, -0.1111266091, 0.0529889837, 0.3973849118, -0.2279436737, -0.5377079844, 0.0547855198, 0.0183874946, -0.9417785406, -0.1463422775, -0.0371242017, -0.1163193062, 0.0454351231, 0.2438108921, -0.6230735779, -0.3968823552, -0.3408095837, -0.4469096363, 0.1254533231, -0.0693546906, -0.1337335557, -0.4201317430, 0.1389454156, -0.1374968439, -0.0347718857, 0.0413492396, 0.1406002343, 0.5097536445, -0.2982149124, -0.1725819856, -0.1185517088, -0.0096996482, -0.1779491752, 0.0247861203, -0.0856267810, -0.1789352298, -0.4395024180, -0.3897836506, 0.0172394253, 0.0491402857, -0.1186037287, -0.2314491272, -0.0060667936, -0.1020166278, 0.0416707844, 0.5249257684, -0.3482060730, -0.0029033222, -0.0903299376, -0.0060937009, -0.9407101870, -0.2983756661, 0.0314526297, -0.0862497613, 0.4273563027, -0.0842490718, -0.7008616924, 0.1739462316, 0.2757416368, -0.1285246164, -0.3198998868, 0.0398343727, 0.5339797735, -0.3643262386, -0.0294001456, 0.1168402433, -0.0791626424, -0.1710465848, 0.0394488387, -0.0381181128, -0.0403987430, -0.2628284395, -0.0470692366, -0.1564496905, -0.1400348693, -0.1494253427, 0.0511554331, -0.4510540366, -0.2403361499, -0.3989341259, -0.0207810085, 0.2054482251, 0.0375970565, -0.1366699934, -0.0980055481, -0.1082428619, -0.3547839224, 0.2995190620, 0.0285845250, 0.2690225840, -0.1548040062, -0.0315443985, -0.9041398168, -0.2279190123, 0.1728880703, -0.1612820178, 0.1631183326, -0.1205647513, 0.2015025914, -0.0252248291, 0.1575326920, 0.1209495366, 0.0647385940, -0.0890955925, -0.3302847147, 0.0336660333, 0.0092243832, -0.0538287759, 0.1360017955, 0.0101055503, -0.3993065059, 0.3731736243, -0.0260557961, -0.0908688754, -0.1216545179, -0.2774231434, -0.2818605900, -0.0826428160, 0.0791071579, -0.3586628139, 0.0793276653, -0.0369707420, 0.3050589859, 0.1440975219, 0.1149288714, -0.9345992208, -0.1217352673, -0.1641414464, 0.0482942760, 0.1400479376, 0.0208673030, 0.6230232120, -0.5139378905, -0.0206165388, 0.0936591700, -0.0283707250, -0.3986904919, -0.3728914261, 0.1361064315, -0.0247786231, -0.0532603189, -0.0347927399, 0.1099624559, 0.0136506846, -0.0131145827, 0.0058659906, -0.0538519211, 0.0539420880, 0.0983042270, -0.0254935063, 0.0650902390, -0.0168362856, -0.0507402979, 0.0362277701, -0.0159491133, -0.0701343492, 0.1209078357, 0.0429490507, 0.0257782675, 0.0661831424, 0.0419418067, 0.0206482764, -0.0601377785, -0.1150880307, 0.0044199340, -0.1017310023, 0.0474701710, 0.1017617583, -0.1403409839, 0.0159580093, 0.0491290055, -0.0714576244, -0.1297152191, 0.0073882816, -0.0324135199, -0.1153344288, -0.0372441895, 0.0740213767, -0.0784618706, -0.0388544053, 0.0915711820, 0.1019431502, -0.0064756600, 0.0149512868, 0.0251576807, -0.0403227881, 0.0729280189, -0.1153234020, -0.0954454169, -0.1003151089, 0.0120569449, -0.0828233063, -0.0928388909, 0.0283403043, 0.0237227604, -0.1037515551, 0.0680182278, -0.0114931762, -0.1079917252, -0.0228434950, -0.1362236142, -0.0875930190, 0.1111107171, -0.1004337370, 0.0236255229, -0.0709312856, 0.0168830808, 0.0814415216, 0.0176109206, 0.0279034730, -0.0386986136, -0.1028329730, 0.0659614280, -0.0975674763, 0.0385841019, 0.0379835814, 0.0286819935, -0.0879005641, -0.1025407016, -0.0267262850, 0.0001194669, 0.0743010268, 0.0867287442, 0.0731249899, 0.0525226593, 0.0743814185, 0.0426769927, -0.1441972256, 0.0478546359, -0.0281118918, -0.0153037962, -0.1272103190, -0.1050799787, -0.0051229303, -0.1133643612, -0.0840382427, -0.0648033917, 0.0813355371, 0.0578936674, 0.0086346380, -0.0412760228, -0.0958099514, 0.1348780096, -0.0827824026, -0.0917732418, 0.0476553291, 0.0639593676, -0.0495870039, -0.0898725912, 0.0621115007, -0.0319691077, -0.2603728771, -0.1084331647, -0.1099100485, -0.1039674655, 0.0603442416, -0.0210928358, -0.1108715013, 0.0888041779, -0.0163567979, -0.1239445210, 0.0821107253, 0.2242288589, 0.0131831327, -0.0447936170, -0.0193309598, -0.0701154545, -0.0035010162, -0.0928825289, 0.0776812211, -0.0264043827, -0.0003885044, -0.1119604707, -0.0004153188, -0.0733640939, 0.0923943147, 0.0544310883, -0.0543703474, 0.0549369603, -0.0604192317, 0.0451070219, -0.1036608890, 0.0679982007, 0.0315861702, -0.1193175241, -0.0781073347, 0.0523154326, -0.0331374928, -0.0568858646, 0.0680216104, 0.0313704573, 0.0448540412, 0.0430199876, -0.0335314125, -0.0694143698, -0.0912736058, -0.1097473353, 0.0653773174, 0.0434813686, 0.1001361385, -0.0320054814, 0.0363297611, -0.1071752906, 0.0342178009, 0.0412602015, -0.0346875601, -0.0594850592, 0.0469210260, 0.1118620709, -0.0354087539, 0.0096908193, 0.0766145810, -0.0663667992, 0.0563249402, 0.0918946564, -0.0666359290, -0.0665654838, -0.0314764269, 0.1097556725, 0.0447639897, 0.0043253503, -0.0718842521, -0.1019126847, -0.0027583446, -0.0576581359, -0.0525623672, 0.0444404334, -0.0605467707, 0.1080968082, -0.0752458572, 0.0441755354, -0.0965301096, 0.0791613385, -0.1869025528, 0.0778268650, 0.0623699725, -0.0315639451, 0.0023288019, 0.0492900498, 0.0107683539, -0.1242763475, 0.0051099807, 0.0583644286, 0.0774595141, -0.0476471856, -0.0178307015, -0.0201407801, 0.0930896923, -0.0776610523, -0.0190524478, -0.0823430642, -0.1130123138, -0.0568409413, 0.0030831299, -0.1043386087, 0.0928296521, 0.0325287953, 0.0888914242, -0.0449884459, 0.0412487723, -0.0872868896, 0.0311810859, 0.0913512781, -0.1190294474, -0.0959361047, -0.1114903167, -0.0736815929, 0.0059670005, 0.0827519894, -0.0110306982, 0.0769018978, -0.0500954241, 0.0719225034, 0.0234173201, -0.0185809452, 0.1456920803, -0.1223601103, 0.0502484292, 0.0669171736, 0.0731910542, 0.0399111584, 0.0135289319, 0.1026405096, -0.0052143363, -0.0441851616, 0.1441102773, 0.0290477853, -0.1340033263, 0.0137274722, -0.0960186347, 0.0135607645, -0.0285102613, 0.0296932105, 0.0733950436, -0.0497144908, -0.2458095998, 0.0114651136, -0.0184915513, -0.2089350820, 0.0043646195, -0.5067188740, -0.0502883419, -0.1847888380, -0.0720167533, 0.1664199531, -0.0847441629, -0.2684302926, -0.4344722629, 0.0118252290, -0.0536003448, 0.2751441896, 0.1774674803, -0.0048955921, -0.0341116786, 0.1051091105, -0.0423969999, -0.3313537538, 0.1466325074, -0.1949492395, -0.0019519329, 0.3366110921, 0.0833972171, -0.0471872054, 0.1048506275, 0.1308412254, 0.1050340831, -0.3682014048, 0.0819921568, -0.0424492583, 0.0612716898, 0.0489223003, 0.0179930571, 0.9824644327, 0.0930855349, -0.0741615519, 0.2293940634, 0.0219694637, -0.4218498766, -0.0229342133, -0.1535167247, 0.0996168032, 0.3535259068, 0.1342750639, -0.0833622590, -0.0582792908, -0.1289156228, 0.0384016149, 0.0254025981, -0.0713253468, -0.6498741508, 0.0553398393, 0.1109085828, -0.0308940560, -0.2888013124, 0.2542522848, -0.0853865221, -0.0056826030, 0.0354896747, 0.0397442505, -0.0563882962, 0.0916789547, -0.0666727573, -0.3320216537, 0.0920850560, 0.0361738950, 0.0354653634, -0.0829228461, 0.0830824971, 0.0418827012, 0.0452009737, 0.0908780321, -0.0757472441, -0.1044816971, -0.0269183815, -0.1984727830, -0.1207427680, -0.3218673468, 0.0801223740, -1.3881907463, -0.1289976537, -0.1102799922, 0.0531816781, 0.5105612874, -0.2005466372, 0.0285398029, 0.0485213846, 0.1251268983, 0.0765543580, -0.1392039806, -0.0112139378, -0.0139280241, 0.2741669118, -1.2274807692, 0.0422146395, 0.0210994631, -0.0219404623, -0.2236981839, 0.1135257632, -0.5411648154, -0.0630632266, 0.0858924985, 0.0007782573, -0.0252889451, 0.0234009102, 0.6961073279, 0.0420380533, -1.4929591417, -0.0900548324, -0.0818286389, -0.0437434614, 0.9874432087, 0.3765181899, 0.0792794749, 0.0268004760, 0.0596489124, 1.4690301418, 0.0431116372, -1.3946938515, -0.1534694880, 0.0179707054, -0.0828042179, -0.0457849056, -0.0561564453, 0.0799305961, 0.1568166018, 0.1125747859, -0.7656183243, -0.3737123907, 0.0772633329, 0.4295265079, -0.0130612236, 0.0871783644, 0.0085632969, -0.0247823708, -0.0458484851, -0.0003558382, -0.4774584472, -0.3577994704, -0.0790524036, 0.0162668582, 0.0939485133, 0.0437266082, 0.0767613649, -0.0103824483, -0.0600138269, 0.0290002562, -0.2900890410, 0.1894807667, 0.0938495398, -0.1948357970, -0.1236150041, 0.2533833086, 0.0802646428, -0.0415158644, -0.0387655683, 0.0189628117, -0.0449058488, 0.7551063895, 0.4990065396, -0.0264862385, 0.0588381700, 0.0200267471, 0.3831909299, -0.0014164541, -0.1367674023, 0.1095465720, 0.0117404712, 0.1082758605, -0.4840170741, 0.0355618522, -0.0134147946, 0.3570880890, 0.1565131098, -0.1404721141, -0.0791551769, -0.4760119021, -0.1154839396, -0.4435840249, 0.0544573590, -0.0350452587, 0.0461816341, -0.2763747573, -0.1007300541, 0.0536718592, -0.1526541710, -0.1478540748, 0.0926114023, 0.0711038113, -0.4085274935, -0.2174554914, 0.6749826670, -0.1002735198, -0.0724910349, -0.0223227628, 0.1429469734, -0.0385531783, -0.1180921867, -0.1418631971, -0.9787821174, 0.1774800122, -0.1728887707, 0.0080182608, -0.0891392305, -0.0158654414, 0.1273769885, 0.7003992200, 0.0945893526, -0.0212906804, -0.2429780960, -0.0918497443, -0.2219891697, 0.1517308205, -0.1318424791, 0.4740701616, 0.0514416024, -0.0052119177, -0.6880953908, 0.1879800260, -0.0397223011, 0.0705505162, -0.0928577632, 0.0527534969, 0.8389111161, -0.2767949402, -0.0944767296, -0.0754653439, -0.2448352724, 0.0652608946, 0.2949369848, 0.7983925939, -0.0785583183, -0.6643347740, -0.2590668797, -0.7543967962, 0.0473503098, -0.1646970809, -0.0353841893, -0.5430394411, 0.0220296923, -0.0886825323, 0.1683991253, -0.0530060194, -0.0900031999, 0.1905980110, -0.1105659232, 0.0218390506, -0.4095014930, -0.0805862620, 0.2052049339, 0.0228897352, -0.0563549027, 0.0951304510, 0.1776597649, 0.0566431284, -0.0654198900, 0.1084391773, -0.0909134597, 0.1265349686, -0.0727625862, 0.1058511287, 0.0127001619, -0.0134481974, 0.2704155743, -0.0944297165, -0.0966530144, -0.1188749224, 0.0764271766, -0.0640657917, -0.1395812929, -0.1353317201, -0.0670669079, -0.0225116927, 0.0684616789, -0.0840790197, -0.0666666552, -0.0064722532, -0.0686819255, -0.0167237557, -0.0078875395, -0.0399360061, -0.0738602802, -0.0488771610, 0.0789363533, 0.0704581514, 0.0586783886, -0.1050112769, 0.1482413262, -0.1102785915, 0.1639827192, 0.0142526878, -0.0290120747, -0.0971811265, -0.0910600349, 0.0629620329, 0.0769931450, -0.1047026291, 0.1861413866, 0.1209371239, 0.1088163108, -0.0822206661, -0.0703729838, 0.0699720457, 0.0835746452, -0.0098383669, 0.0943460390, -0.0383095294, -0.0429144129, -0.0602691472, -0.0685648620, 0.1908808947, 0.0635188818, 0.0175638720, -0.0491458848, 0.0253243987, -0.0057938811, 0.0915772468, 0.0210915506, -0.0225166939, -0.1111056656, -0.0712038428, 0.0108770840, 0.0823357478, 0.0651891232, -0.0605526343, -0.0790315717, -0.0304312110, -0.0127598569, 0.0364528038, 0.0217220783, 0.0251919888, -0.1476770341, 0.0087710023, -0.1210747063, 0.0080958307, -0.0206750445, -0.0024948609, -0.1087186486, 0.1109763682, -0.1678760499, 0.0699466765, 0.0270938314, -0.0316451713, 0.0724379718, 0.0644603819, -0.1083160043, 0.0041458532, -0.0696505308, -0.1174550354, -0.0837438703, -0.1000616103, 0.0042055435, -0.0591524132, 0.1204408333, -0.0293328222, 0.0517173782, -0.0630742088, 0.1324938387, -0.1147132665, 0.0058310633, -0.0247704294, 0.0047381809, -0.0982203484, 0.1666248888, -0.0414326638, 0.1089996994, -0.0041014664, -0.0980333164, 0.0304917227, 0.0404741652, 0.1163659394, -0.0849501416, -0.0931274891, 0.0381977260, -0.0693317801, 0.0030599630, -0.1003766134, 0.1511154473, 0.0695224255, 0.0768731534, 0.0105006937, -0.0635023043, -0.0564619973, 0.1175989956, 0.0187680889, -0.0920025483, -0.0238835160, -0.0766757131, 0.0220642630, -0.0242226906, -0.1275352389, 0.0172604956, 0.0058569456, -0.0248475019, 0.0704249516, 0.0902340114, 0.0175327174, -0.0883470997, -0.1353216618, -0.0428591892, -0.0425353609, -0.1004182696, 0.0814994276, -0.0918353125, -0.1507146657, 0.0433176123, 0.0035619342, -0.0955881551, 0.0050892057, -0.0426064879, -0.0033870691, 0.0802449286, -0.1039678752, 0.0011251569, -0.1312822104, -0.0184395909, -0.0661159977, 0.0384017564, 0.1087319031, 0.1038684621, -0.0566764772, -0.0515190251, 0.0641343817, 0.1204924285, -0.0180983618, -0.0451343469, 0.0934433639, 0.0250304937, -0.0829092935, -0.0696619228, -0.0551806800, -0.0587489866, -0.0510045327, 0.0856662989, -0.1124083698, 0.0077561736, -0.0768246949, -0.0797849298, -0.0300487578, -0.0901032165, -0.1116785407, -0.0969879776, 0.0837304145, 0.0027772188, -0.0729694664, 0.0126295993, 0.0934787542, 0.0858157575, 0.0919232592, 0.0328816883, -0.0954473615, -0.1290839314, 0.0118581057, -0.0531404577, 0.0559707694, -0.0195354857, -0.0677789077, 0.0636747852, -0.0319269747, -0.1057381928, 0.0037210784, 0.0400741696, 0.1251234710, 0.0524621047, 0.0701322928, 0.1358775496, 0.1047068834, 0.0886327103, -0.0273667425, -0.1258741021, -0.0316691883, -0.0798773170, 0.0211052895, 0.1014241949, 0.1037546396, -0.0265127867, 0.0275362413, -0.0359744392, 0.0299236942, -0.0091530308, 0.0885476992, 0.0459356308, -0.1227324605, -0.0282122903, -0.0468351133, 0.0252936482, -0.0782135502, 0.0389424264, -0.0712195039, 0.0634754300, 0.3154165745, 0.0319229960, -0.0225667134, -0.0333419405, 0.0443546921, -0.0534881018, 0.0563944243, -0.0795096904, -0.0307427663, -0.0473967493, -0.0198177136, -0.1082275584, -0.0744626448, 0.0417283550, -0.0553631447, 0.0876727402, -0.1660598814, 0.0967708379, 0.0980713964, 0.0354966633, 0.0438825749, 0.1119112372, -0.1108736545, 0.0443443023, 0.1143808514, 0.0755936801, 0.0513190925, 0.1140693873, 0.0382935181, -0.0760333836, 0.1023035645, 0.0532498360, 0.0221051089, -0.0570658967, 0.0195197463, -0.0590709336, -0.0557205454, 0.0738989264, 0.0863571465, 0.0398893431, 0.0859280452, -0.0355415046, 0.0155213336, 0.0064365836, -0.0357533395, -0.0490407646, 0.0664042309, -0.1169179827, 0.0073815631, -0.1001427323, 0.0299581587, 0.0910933614, 0.0207263827, 0.1234438866, -0.0940989703, 0.0993749574, -0.0792058036, 0.0667089224, 0.1059251055, -0.1229715496, 0.0366152972, 0.1244128644, 0.0311055481, 0.0923378766, 0.0863000304, -0.1022579148, 0.0589116514, 0.0289518535, -0.0314569809, 0.0743350387, -0.0390350670, -0.0977173969, -0.0759010017, -0.0237608906, -0.0157788098, -0.0820164010, 0.0780850276, -0.0857047439, 0.0333634913, -0.0309283677, -0.0270686466, 0.0634340942, -0.0696989372, 0.0071314573, -0.0856442451, 0.1059688628, -0.0626050755, -0.0514089540, 0.1031252071, 0.0559974313, 0.0341055691, -0.1096619666, -0.0968879759, 0.1168350726, 0.1190660298, -0.1020451188, 0.0629430413, 0.0721203834, 0.0877873898, -0.0791042447, -0.0767615587, -0.1014035940, -0.0017914772, 0.1181574985, -0.0413703620, -0.1138972715, -0.1205697358, 0.1012826040, 0.0686120689, -0.0551269054, 0.0417311490, 0.0794427097, -0.0267451424, -0.0297789574, 0.0200938713, 0.1007203460, 0.1098094806, -0.1294346005, 0.1048012674, 0.0848215222, 0.1246917918, 0.0940759182, -0.1038713306, 0.0554405861, -0.0059179775, -0.1055436805, -0.0222630203, -0.0868722498, -0.1096154153, 0.0341151953, 0.1157394201, 0.0247545838, -0.0122747868, -0.0314683653, 0.0919810832, 0.1155258119, -0.0349670351, 0.0205561556, 0.0040111737, -0.0502133369, 0.0468562506, 0.0004702508, -0.0459469929, 0.0743885860, 0.0276365243, -0.0844597742, 0.1199532524, 0.0731930882, -0.0923748314, -0.0971618816, -0.0932727009, 0.0200106110, 0.0547314547, 0.1026346460, 0.0388962477, 0.0832720697, -0.1019327044, -0.1027106047, -0.0242935121, 0.0276465118, 0.0034857988, 0.0420068428, -0.1211626679, 0.0191140790, 0.0607727468, 0.0880008936, -0.0049243774, 0.0837448239, -0.0729415938, -0.0452791527, -0.0618282184, -0.0692906380, -0.0839747936, 0.0160012599, 0.1011825353, -0.0468294322, 0.0698331892, 0.0460993163, 0.0170923471, 0.0808627903, 0.0655983314, -0.1147519946, 0.1089354604, -0.0152797159, -0.1109272838, -0.0863240659, 0.0832754299, -0.0017673109, -0.0105682192, 0.1033038497, -0.1238756105, 0.0200093687, 0.0512561798, 0.0344965495, -0.0965225622, -0.0434650406, 0.1132712364, 0.0862426162, 0.0009944141, -0.0215201005, -0.0555540025, -0.0383260138, -0.0438588560, 0.1184936911, -0.0089497566, -0.0035991231, -0.0812372640, -0.1067175493, -0.0717421472, -0.0133629143, -0.0080324411, 0.1012474820, 0.1053812802, -0.0660967231, -0.1248967052, -0.0842812732, 0.0718689486, -0.0216012411, 0.1006685495, -0.0121651907, -0.0967444927, -0.0451168455, 0.1062084287, -0.0892165080, -0.1036480367, -0.0795961320, 0.0802507401, 0.1161757708, -0.0599240735, -0.0862824991, 0.0135179004, 0.0838429034, -0.0294052064, -0.0768674612, -0.0952307731, 0.0181177557, -0.0177085456, 0.0705230534, -0.0504800454, -0.0182656050, -0.1042349935, 0.0932224691, 0.0007266780, -0.0113741141, -0.1191935241, -0.1039271131, 0.0669927299, -0.0070659518, 0.1122638285, -0.0961965546, 0.0375262499, 0.1095337495, -0.0121501982, 0.0793993548, 0.0060865893, 0.0093979836, 0.0683001652, -0.1130061150, -0.0271105617, -0.0770383179, -0.0605245233, -0.0787535161, 0.0337274037, 0.1101872772, -0.1192673817, -0.0709454417, 0.0491813123, -0.0368832722, -0.1138430163, -0.0634995699, 0.0783437043, -0.0456998050, 0.1113892496, 0.0618528128, -0.1592306048, 0.0941478163, 0.0889839828, 0.0074674343, 0.1048593521, -0.8452171087, 0.0500468723, -0.2048486173, 0.1780886352, -0.0725701675, 0.1463191509, -0.0089143990, 0.6295475364, -0.0732161999, 0.0998667330, -2.0288841724, -0.1474023610, 0.0387383364, 0.0112950495, 0.0520456247, 0.1712050885, -0.1179860756, -0.0507470518, 0.1308797151, 0.0658600256, 0.7183969617, -0.1300529540, 0.0347710513, -0.0339580923, -0.1587632895, -0.1527520418, -0.0758535415, -0.2245227396, -0.8407721519, -0.0350526236, -0.0391356498, 0.3051392138, -0.1784511656, -0.0109225120, -0.0526250750, -0.2877848148, 0.0327224620, 0.1022725180, 0.0095218820, -0.2541137934, -0.4042892754, 1.2106835842, 0.0000947900, -0.0728222355, 0.0024152144, -0.0289531406, -0.1777895987, 0.3284006119, -0.0892050415, 0.2327717841, 0.0795473084, 0.0848511085, -0.1085319296, 0.5110186934, -0.0689431280, 0.0127586015, -0.0724194869, -0.9574930668, -0.0245287493, -0.0230315644, 0.0161753930, -0.0645044446, -0.0893285871, 0.1924977899, 0.1917362511, -0.3179115951, -0.3727049828, -0.0029813945, -0.1429919749, -0.0407127365, -1.4112379551, 0.4017604887, -0.0115748346, -0.0245103240, 0.0110340631, -0.1098068580, 0.2685297132, -0.3838477731, 0.0732385740, -0.1147671118, 0.1310383976, 0.0559911728, 0.2329611629, -1.0196300745, 0.0628562644, -1.2907292843, -0.1169693619, -0.0708024725, 0.0471470952, 0.0753583089, 0.0704565346, -0.3536235988, -1.8600854874, 0.0933126882, 0.0238684826, 0.1506095678, 0.4286507666, -0.0849005356, -0.6165769696, -0.2423447818, -0.9653404355, 0.0053899363, 0.0917054489, -0.1108160317, 0.0360249765, 0.1107475758, 0.8135025501, -0.6066837907, 0.0003064300, 0.1240601093, -0.4438739419, -1.2448055744, -0.1024105847, -0.0829184949, -0.5518787503, -0.2007192820, 0.0715336204, 0.0108304210, -0.2594927549, -0.1452825814, 0.2078080028, -0.0431317687, 0.0928503945, 0.0862623751, 0.0725941285, 0.5760375261, 0.0988022536, -0.6331630349, -0.0840646029, -0.8746659160, -0.0551871024, -0.0784384757, 0.0555568933, -0.0133327041, -0.0428177901, -0.1330332160, -1.3388960361, 0.5928006768, 0.0531926639, -0.3418758810, -0.0702748969, -0.0307818949, -0.0174684897, 0.0859289095, -0.1102044433, -0.2035066932, -0.1935556680, 0.0046967822, -0.3426706791, -0.1267561316, -0.0086860005, -0.0871862248, -0.0156250801, 0.0855832696, 0.0347789936, 0.0777032375, -0.0885943472, -0.4865178764, 0.8247173429, -0.0337731354, -0.0254917219, -0.0402984694, -0.5765393972, -0.0770519599, 0.1429278553, -0.1743857414, -0.4685639143, -0.1223836392, -1.8764848709, -0.0842638537, -0.1547270417, -0.0660772249, -0.3106659949, -0.0903988108, -0.0432331264, -0.2319126129, 0.0092843175, -0.1759624481, -0.0293749198, -0.0898712948, 0.0014211400, 0.1527001560, 0.0100371735, 0.9727911949, 0.0275273342, -0.0747957826, 0.0601994395, -0.0371558070, 0.5984241366, -0.8119221330, -0.8929778934, 0.2347755134, 0.1422490180, 0.2122274488, 0.1365973651, -0.0495556891, -0.4613514841, 0.0362794250, -1.1709358692, -0.0595661178, -0.0243943129, -2.7649323940, -0.0100776665, 0.0163978580, -0.1227806732, -1.3252857924, 0.0677099302, -0.1561535150, -0.0504721254, -0.0362865329, -0.1770264357, -0.0454474464, 0.1340834945, 0.1083253026, 0.0806022435, 0.0691510737, 0.4283772707, -0.0458033085, 0.0640495420, 0.2548435628, -0.2231159955, -0.0863009691, 0.1200284362, -0.7339040041, 0.0792949200, 0.1023462042, -0.0251837894, -0.1419418901, -0.5516954660, -0.0723983496, -0.1937873662, -0.1883840561, -0.0799137875, 0.0058364081, -0.0515172333, -0.2016024292, 0.3475174010, 1.1410462856, -0.2429403365, -0.0901397765, 0.1565687954, -0.9330546260, 0.0237371624, -0.2134976387, -0.0084517533, -0.0626994818, 0.1876582205, 0.0655523017, -1.0156501532, 0.0684845969, -0.0174344685, 0.0230125617, -0.1094392166, 0.4648739994, 0.0411528647, 0.0613393560, -0.2184172422, -0.0122517692, 0.0258921627, -0.0394770503, -0.0213313904, 0.2392244339, 0.1751510203, -2.2062335014, -0.1392176449, 0.0420783423, -0.8298118114, 0.0939917415, -0.0033733107, 0.1215359345, -0.0865749344, -0.0832266510, -0.4998179972, -0.0332138799, 0.1512309164, -0.0334995240, 0.3313905895, 0.0318728052, -0.1211002171, 0.0813525617, -0.0940382555, -0.0331118442, 0.1552681625, 0.0225471072, 0.0467270762, 0.0769917071, -0.0378225408, -2.8535842896, -0.1968728602, 0.0111886514, -0.0056601753, -0.1526587754, 0.0415402725, -0.2712269723, 0.0505583696, -0.4801210165, 0.0831942633, 0.0294234287, 0.1453981251, 0.0595927052, -0.0564879477, 0.0045233890, -0.5507726073, -1.2484499216, -0.1555557400, -1.0606667995, -0.4927646816, -1.5845329762, -0.2944604754, -0.2191556394, 0.0482339785, -0.2038205713, -0.1229793057, 0.5985621214, -0.4920930266, 0.0155909760, 0.0153828636, -0.0567157045, 0.2212814093, 0.0607222356, 0.0725071132, -0.1196231097, -1.3047674894, -0.0157777127, -0.3428338468, 0.0830404386, 0.4599846303, -0.5007978678, -0.1234765872, 0.0843903422, -0.0481237993, -0.1321802884, 1.7618758678, -1.1269654036, 0.0186172985, 0.0776342899, 0.0036582665, -0.0784983635, -0.1278283596, -0.6967842579, -0.0268086884, 0.5993659496, -0.0237204004, 0.0721956789, -0.0904240757, -0.0572779551, -0.1339526623, 0.3180658221, -0.1361962259, 0.0076045622, 0.0277921408, 0.0296361428, -0.0722121745, -0.0044089821, -0.7392376661, 0.0313371941, 0.1145247221, 0.0051595345, 0.0635712221, 0.0498153195, 0.1437945664, 0.0351760797, 0.2295305282, -0.1749937683, -0.0686119497, 0.0285513103, 0.1070866510, 0.0745688230, -0.1818355620, -0.0597472303, -1.7230242491, -0.8273144960, -0.0967178494, -1.0271738768, -1.1236565113, -0.0126677183, -0.0393803008, 0.0221181996, 0.1147285700, 0.0040112608, -0.0838348716, -0.5514649749, -1.0705901384, -1.6702722311, 0.0016310099, -0.1762295216, -0.9398573637, -0.0571880564, 0.0939026326, -0.0639402568, -0.7844417691, 0.0085016685, -0.6265805960, -0.1855314672, -0.0770823509, -0.1149447039, -0.1024416238, -0.0624418072, 0.0915303305, 0.0342345871, -0.0057937340, -0.1158605963, 0.9760539532, 0.1594620198, -0.4399359822, -0.0353851579, -0.0679435357, -0.0968159661, -0.0038969321, -0.5909785032, 0.0734293312, 0.0756868273, -0.1032572314, 0.0215620007, -0.3010488153, 0.0281150099, -0.0654859990, 0.0244444460, 0.5303466320, -0.0988145024, -0.0541461296, 0.0852696747, -0.3024030030, -0.0268414207, -0.2561174333, -0.3576138020, -0.9105932713, 0.0325345285, -0.0602171756, -0.1353720129, -0.0624214113, -0.7173678279, -0.0330650397, 1.0611683130, 0.1668467820, 0.0507018007, 0.0886174440, -0.2122594118, -0.0674120262, 0.1105326265, 0.1381620765, -0.1181484982, -0.1213599965, -0.1135432720, -0.2886912227, -0.3312728405, -0.2690929472, 0.9080580473, -0.5001021624, -0.2090406567, -0.0372780636, -0.1049183458, -0.0284493640, -0.1028446332, -0.2271298319, 0.8158626556, 0.1703756750, -0.0488038473, 0.1143057793, 0.0163600966, -0.5435582399, -0.6522789001, -0.0761526749, 0.0322226398, -0.8935586214, -0.0599652268, -0.2393428832, -0.0499031134, -1.5715698004, -0.1113454774, -0.1260773689, 0.0458370857, -0.1784566492, 0.5347139239, 0.0134348823, 0.0121111600, -0.0075565353, 0.0918547064, 0.1692686826, -1.1002132893, 0.0749623254, 0.0109048281, -0.0973091796, 0.1363070160, -0.0879906863, 0.4261986315, -0.0336690955, 0.5963307023, -0.3347322345, 0.2540926635, -0.1275223792, -0.8801195025, 0.2856599987, -0.0691416264, 0.0832688212, -0.0852361619, 0.0181704983, 0.0700267032, 0.0492142774, -0.5191850662, -0.0850086212, 0.1117349043, -0.3002743423, 0.1113644913, -0.1181532815, -0.3715755939, -0.3584093451, -0.1151415557, -0.0733491331, -0.0988733247, 0.0487400889, 0.0955389440, -0.0599500053, -0.0296393558, 0.0070140362, 0.0527834035, -0.0929949880, 0.1089851856, 0.1700694114, -0.0309063960, 0.0323362947, 0.0799812600, -0.1144674420, -0.0191429220, -0.0147322826, -0.0731788650, -0.0512475222, -0.1028579772, 0.0900758281, -0.1259675026, -0.1003583521, -0.0691901669, -0.0989829600, -0.0409373268, -0.0479294695, 0.0160524659, -0.0674872696, -0.0198492054, 0.0498857759, -0.2045200467, -0.1776885986, -0.0201668851, -0.0395792983, 0.1242008358, -0.0614703186, -0.0177819543, -0.0859150141, -0.0385663211, -0.0893111378, 0.2758336365, 0.0278773941, 0.0999739394, -0.2183052599, -0.1120002866, 0.0519167483, -0.0511627346, 0.0163103733, -0.0568238720, -0.0270340890, -0.0432505123, 0.0747517124, 0.2409011573, 0.0003140394, -0.0766647235, 0.0971909240, 0.0729820654, 0.0162733607, 0.0441484563, 0.0936050266, 0.0020329317, 0.0413888283, 0.0785928741, 0.0033737719, 0.1991148442, -0.1735747606, -0.0619914718, -0.0849812254, -0.0577254742, -0.1596826017, 0.0402726233, 0.0948667377, 0.0516578294, 0.0792670473, -0.0678146482, 0.0234781802, -0.1124781370, 0.0334165506, 0.0084804595, -0.0046637314, 0.0363020040, 0.0479236357, -0.0043679425, 0.0738586560, 0.1201768219, 0.1176906675, -0.0706230253, -0.0661995485, -0.0030994941, -0.1272217482, -0.0913969949, -0.0947747231, 0.0261790790, 0.0818853378, -0.0573411174, -0.0012329505, -0.0523525923, -0.0210802630, -0.0737751201, 0.1501614600, 0.0109091783, -0.0634932667, 0.0446148664, 0.0002566917, 0.1187229604, -0.0318531767, -0.0251765549, 0.1386806369, -0.0665854290, -0.0200567897, 0.0848392993, -0.0242848694, 0.1293533891, -0.0042943601, 0.0055034109, -0.0494690426, -0.0254803896, 0.0163941737, 0.0983677804, -0.0448180139, -0.0204617828, -0.0016992840, -0.0114625739, -0.1100538224, -0.0074745156, 0.0730203018, -0.0283911768, 0.1098916009, -0.0211335700, 0.5535153151, -0.1035531163, -0.1052457467, 0.0212325826, -0.0415885262, 0.0710814372, 0.0099143339, -0.0924257189, 0.0623161569, 0.1084802896, 0.2144461870, -0.0013178420, -0.0387010276, -0.0455974340, 0.1165919974, 0.0876190215, -0.0009575346, 0.0612758324, -0.0052751601, 0.0592772365, 0.0196153373, 0.0100255962, -0.0138914697, -0.0057844087, 0.0792720020, -0.1283135265, -0.1148184612, 0.0619167536, -0.0807019398, 0.0972718894, 0.1097196341, -0.0365588702, 0.0179830585, -0.0134123741, 0.0620534122, 0.1073343083, -0.1041137129, -0.1027633846, -0.0064171432, -0.1198564395, -0.0805315673, 0.0917358249, 0.0261468980, 0.0988364220, -0.0658535957, -0.0802386552, -0.1125257388, -0.0048943246, -0.0593105257, 0.0782681629, -0.0900814161, 0.0525298081, -0.0162861347, 0.0705179945, -0.0101222647, 0.0292322040, 0.1021195725, 0.0038140093, -0.0215787236, -0.1264061779, 0.0141660273, -0.0956139565, 0.0703201815, -0.0846762136, -0.1534667313, -0.0991677418, -0.0118928915, 0.0771381781, 0.0094654299, -0.0096440064, -0.0924800113, 0.0212233141, -0.1172073185, 0.0893273503, 0.0207720138, 0.0561115593, 0.0570913889, -0.0313596204, -0.0562699884, 0.0411835350, -0.0343936794, 0.0357639305, 0.0134628629, 0.1149603426, 0.0515867881, 0.0141781615, 0.0677645802, -0.0607223958, 0.0541284978, 0.0322296396, 0.1128184274, -0.1745288521, -0.0745497942, -0.0277898815, 0.1154492795, -0.0862706900, -0.0853850991, -0.0024617910, -0.0711685717, -0.0307182297, -0.1516105384, 0.0486627668, 0.0883203298, 0.0102911126, -0.0799621716, 0.1812351793, 0.0842998922, 0.1519785821, 0.0434195437, -0.0288815387, -0.0994736180, 0.1630597860, -0.1270598024, 0.0661994517, -0.0166628342, -0.0706500188, -0.1006232500, -0.0609341934, 0.0166457966, 0.0394129790, 0.1477297693, -0.1139079332, 0.0436350591, 0.1490100771, -0.0904799700, 0.3126430213, -0.1887942106, -0.7366199493, -0.0643789023, -0.1038958132, -0.6191536188, -0.0032766450, 0.1389573365, -0.0379876345, -0.0370997638, -0.1868670434, 0.0277077500, -0.4452300072, 0.0648416355, -0.0384480432, -1.6142462492, 0.0795677230, 0.0223976430, -0.0513884723, -0.0506688654, 0.2390666306, 0.4508003592, -1.4708898067, -0.8871096969, -0.0015561350, -0.1710793972, -0.0406946875, 0.0696024150, -0.1063047871, -0.8408035040, 0.0113334851, 0.2975415885, -0.2848127484, -0.2433365136, -0.1140341535, 0.0326417312, -0.0287371241, 0.0251582768, -0.2179213613, 0.0881786793, -0.0762621164, -0.0949474797, 0.4007362127, 0.0301780701, -0.2984925210, -0.0476866439, 0.9454749227, -0.0418336652, 0.0235445648, 0.0760931820, 0.0706133097, -0.8044061661, -0.0429694392, -0.0475453846, 0.1433995366, -0.1128690615, -1.2839027643, 0.0613369457, -0.3654849529, -0.2979749441, -0.3511188924, 0.0422369465, -0.0224337913, -0.0432970971, -0.0068328022, 0.0487135053, 0.0028392251, 0.2040404081, 0.1570779681, 0.1104907766, 0.1158203110, -0.4274537265, 0.0060320199, -1.5468045473, -0.1540684402, 0.1277684867, -1.5230338573, 0.0344418585, -0.0427560620, 0.2393092364, 0.0042567402, -1.6677724123, 0.0785199478, -0.4555137157, -0.5347187519, -0.0573216230, -0.0960168019, 0.0748942122, 0.6797769666, 0.1083158478, -0.0520009175, -0.0633018613, -0.1806632429, 0.0063390881, 0.2085235566, -0.1431811005, -0.7562406063, 0.1517808139, -0.1078496724, -0.0067768688, -0.0909368843, -0.0060996232, -0.0086876778, 0.5608821511, 0.1166023538, -1.5565328598, -0.0277854186, -0.0819239244, 0.3227978945, 0.0700361580, 0.0875659063, 0.3254418075, -0.1603321135, -0.0711702108, 0.2621612251, 0.8861590624, 0.7570164800, -0.0283080209, -0.0623638518, 0.3985549808, -0.5032499433, -0.0471271724, -0.8215819001, -0.9233904481, 0.0647360533, 0.0205331203, -0.0781767666, -0.0604617000, -0.1575544775, -0.0934521109, -0.3689418137, 0.4835445881, -1.2161265612, 0.0696113929, -0.6832559109, -0.8876524568, -0.0522951595, -0.0933346152, -0.3434333801, 0.1776498407, 0.0773264468, 0.0481286980, -0.2824338078, -0.0336361416, -1.1962097883, 0.6054960489, 0.0524765551, -0.1046964601, -0.0057167104, -0.2279300094, -0.3065191507, -0.9113918543, -0.0045970385, -1.0155969858, -0.1181024909, -0.0253836494, -0.5532271862, 0.0926937312, 0.8190678954, -0.0153645417, 0.0471888110, 0.0501645170, -0.1222463399, 0.1935171783, -0.0218729246, 0.0714181587, -0.0254444405, 0.2303922325, 0.2329506278, -0.0117918458, -0.0633214787, 0.2253431827, -0.0522317477, 0.5802233815, -1.1226625443, -0.1821699291, 0.0637458488, -0.0353108197, 0.0675758049, -1.0647897720, 0.6785161495, -0.0205884259, -0.0380035676, -0.0033902060, 0.0245011877, -0.0827045739, -0.1899534911, -0.1132075116, 0.5753063560, -0.1048523933, -0.0150944022, -0.0473095179, -0.0270595290, -0.0136898039, -1.3173370361, 0.1217544228, -0.1422645748, 0.4337522388, -0.1074664518, -0.0186457299, -0.0750129521, 0.0602311939, 0.3958398700, 0.9156350493, -0.5901497602, -0.1621700227, 0.7528949976, -0.1150572002, -0.0338073261, 0.6726288199, -0.1115668118, -0.0819798186, -0.0499876142, 0.0909613445, 0.0221040081, 0.2928858101, 0.0025531091, -0.2048803419, -0.2142186612, -0.0819465965, -0.0395744108, -0.5911331177, 0.3206473887, 0.0208512768, 0.1639450639, 0.3660479486, 0.0517380685, 0.0361628234, -2.2032568455, -0.0217605941, 0.0738071650, 0.0548713654, -0.2871435285, -0.0351851471, -0.2228599936, 0.1433348805, 0.2603608668, -0.1463766843, -0.5298057199, 0.4602219164, -0.1241133958, 0.1603037715, -1.1333438158, -0.0423266143, -0.0808747858, 0.0001165145, -0.0240422320, -0.0612061769, -0.7099143863, -0.0777097940, -0.1142504364, -0.4795374572, -0.1440141797, -0.5143426061, 0.2966675162, 1.0138552189, -0.8992677331, -0.0505575016, 0.5634073615, 0.0049293805, -0.1499842107, 0.1828942448, -0.0000328136, -1.1144205332, -0.0566981733, 0.0692220554, -0.3432461917, -0.0272955280, 0.0903577432, -0.1539519876, -0.0317018405, -0.0539641306, -0.4284070134, 0.0338194445, -0.0253738444, 0.0957004875, -0.2641587257, -0.1945484281, -0.4603822529, 0.2041584104, -0.0062018745, -0.0306619313, -0.2075019032, 0.0904834047, 0.0372371413, -1.3665231466, -0.5701963902, -0.5642355084, 0.0648405030, 0.3918571174, 0.0137349069, -0.2557891011, -0.3694760501, 0.1545037627, 0.0997285843, 0.0449106842, -0.1531736702, -0.2150758952, 0.1930111349, -0.0085583897, -0.3202416003, -0.1189102903, 0.2707069814, -0.1003266051, -0.0486942790, -0.0250649154, -0.1050157696, 0.6347885132, 0.0510946773, -0.0087339757, -0.2633017898, 0.2083964199, -0.6312429309, 0.0577763058, -0.0719503313, -0.6239964962, 0.3635577559, 0.0090042735, -0.3285856247, 0.1435848922, -0.0508334450, -0.0670566335, 0.0050379941, -0.5638756156, -0.0757439584, -0.1492400914, -0.1203928664, -0.8995877504, -0.1048665941, 0.5577257872, 0.2026789933, -1.0195289850, 0.5897981524, -0.1476899087, -0.0461746305, -0.0478083603, -0.1103381068, 0.0311278496, 0.0002592746, -0.1710583866, 0.1060408205, -0.1465470791, 0.0284233317, 0.0644372106, -0.2394040227, 0.0473991409, 0.4673788249, 0.0055882591, -0.0466151796, 0.0904012024, 0.0381271206, -0.0230944138, -0.7749190927, -0.0592457019, 0.1385158300, 0.0184719618, 0.1082545295, 0.0063036601, -0.0122923041, -2.2015700340, 0.1241443604, -1.1309142113, -0.0300145894, 0.0487912744, -0.2098428607, -0.5182791352, -0.1548140794, 0.0022883939, 0.4848490059, 0.0447508395, -0.1298858225, 0.4260020554, 0.1514093578, -0.1055902988, -0.1541402936, -0.0931759402, 0.2327199131, -0.0113472631, -0.5933874249, 0.1958730519, -0.0432290062, 0.0296274386, -0.2552178800, -0.0342392847, -0.1170602366, -0.1623600572, -0.2528120577, 0.4798862040, 0.3827962577, -0.0737174675, 0.0273450706, -0.2179648131, -0.0177842025, -0.0943250805, -0.2798111439, -0.1949074715, -0.1729318500, 0.1521739066, -0.0932313576, 0.0039266730, -0.1273297817, 0.1564162225, -0.1775834709, -0.0642648786, -0.0268061217, -0.0874083638, 0.0412094109, -0.4567900002, -0.1249624118, -0.0326613486, 0.2984625101, 0.0506511964, -0.9811815023, 0.0033941357, 1.1337673664, -0.0055868416, 0.0862980857, -0.0313210897, -0.0629660413, -0.0234202761, -0.0050653331, -0.1281167120, 0.0437135585, -0.1897754222, -0.1680333167, 0.0160482395, 0.2184009105, -0.4596556723, 0.0582175851, -0.3533530533, -0.8243499398, 0.9284235835, 0.0021009303, 0.0611140803, 0.0910674334, -0.0605058447, -0.3125109076, -0.1403006166, -1.9513665438, 0.0212607216, 0.1237168238, -0.0985249951, 0.0402070954, 0.0447607078, 0.0410572812, 0.0905177221, -0.2008228898, -0.1445057392, 0.0046937945, -1.0606126785, -0.2899031043, -0.2407612354, -0.4928769171, 0.0002876275, -0.8603445888, -0.0289147757, 0.0336675830, 0.0287751667, -0.5357841253, -1.4983066320, -0.0337645859, -0.8513090611, 0.2076413482, -0.0406815670, -0.0044507282, -0.9203498960, -0.1868610382, -0.0257535707, 0.1415259391, 0.1353373528, -0.1332019567, 0.3205785155, -0.0601763427, 0.0185425449, -0.0806701928, 0.0894673020, -0.1717958748, -1.4635245800, 0.1524303406, 0.0467382856, 0.2162571549, -0.3891475499, 0.0945898145, -0.3578948379, 0.6596572995, -0.0748693049, -0.1671139747, -0.0815754980, -0.0805423185, 0.1825202256, -0.2034325451, 0.1335888952, 0.4760309160, -0.0222899485, 0.2522424161, -0.4878144264, -0.9895289540, 0.2166293710, 0.0014673600, 0.0310320687, -0.1908878982, -0.0221961234, 0.3273113668, -0.0089373710, -0.2767613530, -0.4091252387, 0.0347585417, -0.3104759455, 0.0599522702, -0.6672288179, -0.6330866218, -0.2088678926, 0.1994354576, 0.0021149970, 0.0695016906, 0.0243959203, 0.0604721755, -0.8790486455, -0.0053472859, 0.1658786684, 0.0181759242, 0.0746213794, -0.0368886031, -0.0885766745, -0.2193008810, 0.0622450709, -0.0564641319, 0.1465097219, 0.0512043349, 0.0551368035, -0.1135289297, -0.1858338863, 0.0273090899, -0.3086691797, -1.6788696051, 0.0053198636, 0.0157358088, -0.4475795627, -0.2575635314, -0.0838202015, -0.0492888354, 0.4275435507, -1.4010566473, 0.1538157612, 0.0910130218, 0.4355012178, 0.0790797025, 0.0014506377, -0.2303399593, -0.1164302081, 0.0063925921, -0.0033793517, 0.0382404141, -0.0980489850, 0.3789728880, -0.1667886674, 0.0392135158, -0.5985905528, 0.1881591678, -0.0859968364, 0.0321283266, -0.2315591574, -0.0876361653, -0.5088343024, -0.5978032947, 0.0478691086, -0.5673000813, -0.2304087877, -0.2054796666, 0.2127147615, -0.2547684908, 0.0317339227, -1.9091105461, -0.0527481399, -0.3707092106, -0.2507782876, -0.0244166292, -0.1215171888, -0.0040973653, -0.2115545720, -0.1557128429, -0.0375237800, -0.0013188260, 0.2008568794, 0.0065122480, -0.4511370659, 0.5420893431, 0.3947033882, 0.3030596077, 0.0007281549, -0.0622394867, -0.0081875185, 0.0180268157, -0.0411651582, 0.4953974187, 0.1699457765, -0.3254044354, -0.1750197411, -0.0371644199, -0.2675834298, -0.4319328368, 0.0369893797, -0.5097765326, 0.0564823337, 0.0781596527, 0.0956284925, 0.0033998005, 0.0606055669, 0.1698957831, -0.2320319265, 0.0939592347, 0.0218707081, -0.0048620445, 0.0647411421, 0.0265445206, 0.1286676377, -0.1890178919, 0.4511860013, -0.0178313423, -0.0666206405, 0.1757918596, -0.6047075987, -0.0047417004, -0.0223694090, -1.4208421707, -0.0341479406, -0.0191853140, 0.1877835244, -0.0158526283, -0.1461735219, -0.0309434105, 0.1288500428, 0.2768790722, -0.0142314909, -0.0322877206, -0.9563943744, -0.0041756402, -1.0369333029, -0.0387211852, 0.0017120069, -0.0291142240, -0.1232733503, -0.6138325930, -0.6280004382, -0.1335370392, 0.0964625403, -0.2757959664, -0.4457629025, 0.0034330820, 0.0132138794, -1.3353676796, -0.2081573009, -0.0726106390, 0.2898717821, -0.0613101460, -0.3648924232, -1.3715207577, 0.1245383844, -0.0734095126, -0.0055580866, 0.0347826928, -0.0467848890, -0.0373984575, 0.0755839944, 0.3338244557, 0.2605945766, 0.0660373569, -0.1735360473, -0.9325695038, 0.0306847878, -0.5176790953, 0.0407497510, -0.1358364522, -0.0876183361, 0.1237403080, -0.2333333194, -0.0685000122, -0.1265558749, 0.0117911585, -0.0423921384, 0.1715642214, -0.0730498955, 0.0125180176, 0.1782608628, -0.1618209630, 0.5202838778, -0.8028842211, 0.4005630910, -0.1573714912, -0.1247401759, -0.0755805597, 0.0331801362, 0.4884195924, -0.1281644553, -0.6986388564, -0.0431454554, -0.0943927988, 0.0818616897, 0.0849650502, 0.0811912790, -2.6046504974, -0.6619197726, -0.0388841294, -0.0730695799, 0.0269657876, 0.3161863983, 0.3598040640, -1.1346689463, -0.4619351625, 0.0483409837, -1.7081120014, 0.0740648583, -0.0468858294, -0.4534544945, -0.4653631449, -0.2391580492, -0.1614398807, 0.2879967093, -1.1526066065, -0.1011377797, 0.0163654499, -0.7477684021, -0.2723450065, -0.0290274192, 0.0292565525, 0.0235393047, 0.0852400213, -0.0828815922, -0.1394707859, 0.0370372422, 0.1184592471, -0.0717187673, -0.1931499243, 0.4448207319, -0.1809246093, 0.0698393881, -0.0145192267, -0.1827815622, -0.0845154971, -0.5622649193, 0.1905402541, -0.1177743897, -0.0034372148, 0.0574247353, -0.1182579175, 0.9718878269, -0.1972013116, -0.2254263759, -0.7083116770, -0.1596315056, -0.5142139792, -0.5445108414, 0.3658179045, 0.3199812472, 0.3083109260, -0.1132971719, 0.1148440242, -0.0872904509, -2.3295650482, -0.1073744595, 0.1866916418, -0.3536491990, -0.0277866293, 0.2999965847, 0.0762496144, 0.1016950831, -0.4984614253, 0.2483614683, 0.3887222409, 0.0244766641, -0.0502528101, -0.0783036500, -0.0196256302, -0.8609906435, 0.0117755057, 0.2129392922, -0.0393074416, 0.0182147752, 0.1337595433, -0.0313618258, 0.8399222493, -0.1033090055, 0.0250954181, 0.1217771247, 0.8249763846, 0.0214639120, 0.0682982430, 0.1451129317, 0.0168029405, -0.7710623741, 0.0701308697, 0.1984211504, 0.0251908265, -0.1840770394, -0.0872996673, -0.0491223447, 0.0601058491, 0.7583357096, -0.3464071155, -0.2128940374, -0.2381042093, -2.4414210320, 0.0949734524, 0.1425675601, -0.0453107767, -0.5539757013, -0.0520770587, 0.0055954647, 0.1025813222, -0.1937356144, -1.3888206482, 0.0049518216, -0.8048160076, 0.2193757147, 0.4821689725, 0.0380899422, 0.0665835589, 0.0461191349, -0.0211740434, 0.0043628509, -0.0985830799, -0.0320356749, 0.1210578009, -0.0567437038, -0.6784295440, -0.1549931616, 0.4779367447, 0.1685230732, 0.0083641047, -0.1087259725, 0.0469156280, 0.4132370949, -0.0253335852, -0.0434920229, -0.0263171587, -0.5207731128, -0.0283956900, 0.0104977395, 0.0222130138, -0.3377631009, 0.0088891089, -0.2928695083, -0.1143256873, 0.5674120188, -0.6507553458, -0.1371993124, 0.0315504335, -0.0229892507, -0.0960633904, 0.1604845077, -0.2445213646, -0.0148056345, -0.0943253636, 0.0431704670, 0.0096722888, -0.1113468260, 0.3705360293, -0.1140709817, 0.5217571259, 0.0375960022, 0.0593415387, -0.0779019967, 0.1403492093, -0.0096083879, -0.4761852324, -2.9727761745, -0.0783608854, -0.0130278245, 0.0606798716, 0.0885652304, 0.1200129464, -0.8903376460, 0.0158127192, -2.2727153301, -0.0352702960, -0.0035416121, -0.6786897779, 0.0681303293, -0.0093236426, 0.1933015734, -1.3048040867, -0.1130521744, -0.4500527382, -0.2667890787, 0.3818973899, -0.3550972342, -0.0206351466, 0.4266400337, -0.6016093493, 0.0121041490, -0.0539552905, 0.8660767078, -0.1647456437, -1.2571988106, -0.0607588477, -0.0402414873, -0.0886587501, 0.0088575305, -0.8275641203, 0.4094432592, -0.2395063788, -0.3445809484, 0.6127694249, -2.1764233112, -0.1068359166, -0.1154323742, 0.5716937184, -0.3946354091, 0.0073649781, 0.1048825607, 0.0355141982, -0.2263908088, 0.4077070057, 0.2331095636, -0.1002573296, 0.0423403308, 0.0510328785, -0.0914956778, 0.0187817644, 0.1260517091, 0.5281724334, -0.4496766627, 0.5516574383, -0.1688531786, 0.9494139552, -0.0435407571, 0.3073115945, 0.0363891646, -0.1176003292, -0.0564748645, -0.2774905264, -0.0097360080, -0.0186138283, -0.1214354709, -0.0096956873, 0.4158619940, -0.2756300867, -0.0190766249, -0.0218326319, 0.4991808236, 0.0003967336, 0.0040102503, -1.8479701281, 0.1889517754, -0.1288183331, 0.0212545898, -0.0170480218, -0.8330495358, -0.0314962789, -0.0984370932, -1.3445856571, 0.0257272348, -0.1200190559, 0.0028707806, -0.0020987911, -0.0524219647, -0.6099500656, -0.5068600178, -0.0534981899, 0.0318191648, -0.0516791977, 0.5394930243, -0.8177614808, 0.0582219101, 0.3013236821, -0.0177983288, -0.2459358275, -0.1446893960, -0.0498669669, -0.3114135265, 0.0055182269, -0.3074731827, -0.3529233038, -0.4493397772, 0.4246930778, -0.0316951536, -0.0068582366, -0.4409559965, 0.1244350150, 0.3083739877, 0.1845625788, 0.0148545280, -0.0945419967, 0.1201240197, -0.0652495027, -0.2140268236, -0.7201458812, 0.0916085318, -0.0730142444, -0.1742941141, 0.1874215603, 0.0387700573, 0.1127443463, 0.1794911623, -0.0589053929, -0.0174429957, 0.8616204858, -0.0717923343, 0.0089364462, -0.2071428746, -0.4232237339, -0.9421016574, -1.0652463436, -0.0686718971, -0.0654194802, -0.2528437972, 0.6481958628, -0.3299948573, -0.2537589073, 0.2087524384, -1.0737317801, -0.1883262247, 0.0496927798, -0.0364844650, -0.3939395845, -0.0161091480, -2.1962749958, -0.0612940416, -0.0302727725, -0.3446867168, 0.0436812267, -0.4957674146, -0.2051441371, 0.5631160736, -0.1666806042, 0.0903729498, 0.1273238659, -0.0852847844, 0.0280705392, -0.1631867439, -0.0637003109, 0.0410878360, -0.0810992196, -0.0088708233, -0.1081512719, 0.0873727947, 0.0690668821, 0.0126843154, -0.0699863806, -0.1384382844, -0.0235735849, -0.0766552463, 0.0176061317, -0.0711089522, 0.0159485098, 0.1240183040, 0.0550194010, -0.2268404663, -0.0570491403, -0.1104911640, -0.0725851208, 0.0965579301, 0.0719597638, 0.0013862284, 0.0781039074, -0.0725035667, -0.1506528556, 0.0284088887, -0.1221460700, 0.0634655282, 0.0407424495, -0.1803274602, 0.0218379293, 0.0939859226, 0.0903105885, 0.0921085030, -0.1811914444, 0.0482303016, -0.1575618833, 0.0578737110, 0.0142030278, -0.0569181927, 0.0699272528, -0.1727880538, -0.0569130704, -0.1244112253, 0.0239031464, -0.0601634160, -0.7089766860, 0.0017139551, -0.0707553402, -0.0256832168, -0.0881921723, -0.0949683338, 0.0983675718, -0.0561956391, -0.0315124616, -0.0821056291, -0.0062634312, -0.0587159805, 0.0999996439, -0.0568727925, 0.0233164653, 0.0716215894, 0.0497903340, -0.0763160661, -0.1138960719, -0.1392696798, -0.4361463189, 0.0263811629, 0.0577484854, 0.0189594366, -0.0561608113, 0.0388522707, 0.0208406243, 0.0028645517, -0.0203498937, -0.1069805622, 0.0415355861, -0.2357925624, -0.0655124113, -0.0012590080, -0.0023717603, 0.0806554109, -0.0955267251, 0.0472610742, -0.0012996554, -0.0766601786, -0.0674050376, 0.0828093886, -0.0032377345, -0.1228097156, 0.0053159338, -0.0359561779, -0.3900244832, -0.1615588367, 0.1494688690, 0.0329677947, -0.0248354953, -0.0152171114, -0.0114277368, 0.0973227173, -0.1345938295, -0.0312829167, 0.0794577375, 0.0178012885, 0.3149315119, 0.0567635931, 0.0580224171, 0.0449327156, -0.1925821155, 0.0023035463, 0.0244029649, -0.0523429550, 0.1543640643, -0.1553514600, -0.0548417754, 0.2107583433, -0.0413137339, 0.0785025880, 0.0132952640, 0.0193020701, 0.1385191977, -0.0474531837, -0.2129865140, 0.1653893441, 0.0272997078, 0.0153036527, 0.0083923461, -0.0332893990, 0.0511191227, 0.0133258747, -0.0407968350, -0.1441012621, -0.0513530225, -0.0078399181, -0.0168752652, -0.0673662797, 0.1797029227, 0.0178689901, 0.0942818448, -0.1008966714, 0.0306563210, -0.1837459952, 0.0668761581, -0.1702771038, -0.0053429548, -0.1614986658, 0.0107883373, 0.0116723469, -0.0338131376, -0.1115812287, -0.1829835325, 0.0075312867, 0.0176719278, -0.1000887454, 0.0108440304, -0.0400658883, -0.1079430282, 0.0355394930, 0.0097617004, 0.0648266226, 0.0426685512, -0.0220823158, 0.0703559443, -0.2924842536, -0.0235513207, -0.2124550939, -0.0167096872, 0.0183453131, 0.0602051802, -0.0243726391, 0.0797289461, 0.0492356569, 0.0422273502, 0.0205140002, -0.0097140754, 0.1013111025, -0.0454734303, 0.0036071194, 0.1168867946, -0.0741623566, -0.0392940678, -0.0113120237, 0.0361880772, -0.0149239898, 0.0530164428, 0.0098244883, 0.0770516917, 0.1839978248, -0.0805499926, -0.0733772516, -0.3208248317, 0.0903992429, 0.0635677129, -0.0435041487, 0.1527050883, -0.0716740489, 0.0053801751, -0.1044536233, -0.1754355133, -0.1072764322, 0.0056068501, -0.2205542922, -0.0761392936, 0.0680277571, -0.1133044213, 0.1171997711, -0.0070344186, -0.0590556338, -0.0705151185, 0.1977331787, -0.1482141316, -0.1372826248, 0.0608385578, -0.0475634784, -0.0268184915, 0.0409676023, 0.0174958371, -0.0721874759, 0.0388697907, -0.0801355094, -0.1393240243, -0.1104778945, -0.1021849290, -0.0745982379, 0.0898013189, 0.3617191613, -0.1879099458, 0.0563536584, 0.0187030192, -0.0591829307, 0.0990864709, -0.0724480972, 0.0773527995, 0.0660992190, -0.0923153684, 0.1294292510, 0.1007813439, -0.0894923210, 0.1188274026, -0.1254938990, 0.2876358330, -0.0223020520, -0.0136244977, -0.0431541018, -0.1384976953, 0.0674811900, -0.0215845220, 0.1765405536, -0.1159066930, -0.0267450027, 0.1516608745, -0.0517387055, 0.1093921661, -0.1018366218, 0.0874888673, -0.0874853879, -0.0213649012, -0.0423959196, -0.1046793684, -0.2080532461, -0.0363838710, 0.0045283819, -0.0825568512, 0.0176528431, 0.0608032271, 0.1063989177, 0.0353653692, -0.2364906222, 0.0063421498, 0.0009860661, -0.0685205013, 0.0601943880, 0.0963823199, -0.1144702137, -0.0313659348, 0.0130215166, -0.0452675670, -0.0805966035, -0.0523169562, -0.0336256213, 0.0282569956, -0.0933036730, 0.0060038608, 0.0902784318, 0.1055651531, 0.0941399857, 0.0894361958, 0.1076577678, -0.0742602795, -0.1405823231, -0.1982696652, 0.0719310790, -0.0206594560, -0.0440822877, 0.0168896466, 0.0543265864, -0.0464283116, 0.1933713257, 0.0559176840, -0.0276429541, 0.2244997621, -0.0071802423, 0.0231407098, -0.1431424171, -0.0126423873, 0.0300583486, -0.0270327721, -0.0602182858, -0.0723096877, -0.0278131254, -0.1061386839, 0.1152738631, -0.0170741007, -0.0012694001, -0.0726269335, 0.0334881991, 0.0814965814, -0.0633985847, 0.0168737713, 0.0520044900, -0.0126293302, -0.0965621546, -0.0021214606, -0.1727689505, -0.1392791122, 0.0468229353, 0.0407309830, 0.0714312494, 0.1010449082, -0.0044776909, 0.0780613497, -0.1664716601, 0.1569561660, -0.0977359042, -0.0963893831, 0.0459171310, 0.0229626559, 0.1376528591, 0.0239525177, -0.0217598323, -0.1257108748, 0.0498194695, -0.0068632290, -0.0979150236, 0.0978807956, -0.0303089190, 0.2138545960, -0.0918555856, -0.0305997767, 0.0842265189, 0.0373921841, -0.0264186636, 0.0018985460, 0.1611345112, -0.0256550442, 0.0632045940, -0.0191595331, 0.0330668651, 0.0122563839, -0.1591795534, 0.1769290417, -0.0334591269, -0.0022106308, -0.0375787467, 0.0473794304, -0.0691290647, -0.0848347694, -0.0801180676, 0.1415979564, -0.1117532402, -0.0077774050, -0.1266973466, 0.0090849446, 0.2076446712, -0.1850699335, -0.0474828780, 0.0560982861, 0.1127873063, 0.0944233760, 0.0484511927, 0.0796313137, 0.0457803793, 0.0563967340, -0.0131848771, 0.0357484557, -0.1104848385, -0.0596346892, -0.0458989069, -0.0940671861, 0.0882910118, 0.0072407788, -0.0026845988, 0.0735244602, -0.1014063954, 0.0959844813, -0.0600120611, -0.0970797762, 0.0196903963, -0.0149054313, 0.0395351499, -0.4377280176, 0.0103403414, -0.0416440368, 0.0054135211, -0.0291470047, -0.1475897431, 0.1433305293, -0.0680713803, -0.0849528611, 0.1106891781, 0.0270867441, 0.0281427968, -0.0109265978, -0.0759248510, -0.0352607779, 0.2580860853, -0.0305699240, 0.1244092435, 0.0411152020, -0.0560711324, -0.0202276427, 0.0996673703, -0.0612999760, -0.0334197767, -0.0930763185, 0.0171838012, -0.0322273374, -0.0966610089, 0.0751107037, 0.0534874126, 0.2084844112, 0.1117774770, 0.0053963661, 0.1036629602, -0.0771766603, -0.1082182676, 0.0114991609, 0.1519583464, 0.0653665438, -0.1014899015, 0.0089896619, 0.0459972881, -0.2240630835, -0.1416104138, -0.0184797384, 0.0822947025, -0.1811678261, 0.0132154217, -0.1247878075, 0.0165124740, -0.0999360979, -0.0381108038, 0.0698524341, -0.0921115577, 0.0066248919, -0.0010614173, 0.0263070092, 0.0768700019, 0.0892265886, 0.0007926950, -0.1171957552, -0.0963075757, -0.1513707191, -0.1461395621, 0.0269181058, 0.1529651284, 0.0501735434, -0.0166727901, -0.0801331699, 0.1197704896, 0.1384023428, 0.0923356712, 0.1381428391, 0.0915675610, -0.0493186153, -0.0377466194, 0.0740097612, 0.0363059640, 0.0439924896, 0.0595255196, 0.0308294427, -0.0073029874, 0.0270644259, -0.0891519114, 0.1292134821, 0.0453264341, 0.1059119999, -0.0057405205, 0.0913506970, -0.0232119486, -0.0870715827, 0.1578728557, -0.0684128776, -0.1310110390, -0.0144096557, -0.1125967726, -0.0428091325, -0.0375427604, 0.0522155464, 0.1217596009, -0.0672190115, -0.1505579054, -0.1508972198, -0.0802212432, -0.0989410877, -0.0744289085, -0.0015061796, 0.1082752645, -0.1011966765, -0.1210110188, -0.0795140564, -0.0226870179, 0.1085065156, -0.0300332103, 0.0989867970, 0.1124262139, 0.0344018452, 0.0464842618, -0.0250839908, -0.0981745124, 0.0697002858, -0.0114087164, 0.0658817738, -0.0460208952, 0.0626353845, 0.0899994671, 0.0292099807, 0.1052376479, 0.0756435171, -0.0501799062, -0.0150068104, 0.0210855901, -0.1129449606, -0.0198506042, -0.0628485531, -0.1200999096, 0.0258550644, -0.0043934882, -0.0906302333, -0.0575217307, 0.0013990623, 0.0338936448, -0.0704191029, -0.0662073269, 0.0411271937, 0.0313111916, -0.0398692787, -0.1201080903, 0.0348019004, -0.0823159888, 0.1085333824, -0.0881067887, -0.0701201707, -0.0457754955, -0.0460454524, 0.0728547946, -0.0187165216, 0.0135313030, -0.0319015086, 0.0350074768, 0.0429958478, -0.1025616825, -0.0777857602, 0.0092033288, -0.1159511805, 0.1233129799, 0.1130142137, -0.0637352020, 0.0653750375, 0.0355890989, -0.1071378812, -0.0114244577, 0.0658162385, -0.0545396395, -0.0164794028, -0.0994597450, -0.0047730505, -0.0426293910, -0.0126666129, -0.0011900961, -0.1039861739, -0.0546067059, 0.0040688515, -0.0744234473, 0.0302226841, 0.0811286122, -0.0151346689, 0.0167278051, -0.0235051662, 0.0977839455, -0.0589691401, -0.0361670032, -0.0888598263, -0.1138748229, -0.0260138493, -0.0169190355, 0.0180990994, -0.0530804396, 0.1066824645, 0.0197875500, -0.0662343502, -0.0482520163, -0.0462332554, 0.0820965618, -0.0446323268, -0.1145506799, 0.0363702439, -0.0409142785, -0.0924494639, 0.0138377845, 0.0506145693, 0.0213089287, -0.0774805844, 0.0465526395, 0.0024408996, 0.0701161027, 0.0056565702, 0.0849840045, 0.1150414720, -0.0921316072, 0.1364859939, -0.0895800367, -0.0896266699, 0.1186130717, -0.0135570168, 0.0144332349, 0.0356933586, 0.0888992846, -0.0882876441, 0.0850198045, -0.0992095992, -0.0857854858, -0.0491263941, 0.1085208207, -0.1085639298, 0.0336424969, -0.0558960140, -0.0466401912, -0.0199209210, -0.0413165167, 0.0901312381, 0.0434877872, 0.0813437998, -0.0618609078, 0.1089771912, -0.0976162255, -0.0986967832, -0.1137105972, -0.0645097122, 0.1097381935, -0.0396792293, 0.0837679505, -0.0331861414, 0.0685452223, -0.0072368393, -0.0299028046, -0.0706468523, -0.0772093758, 0.0959584191, 0.0956681371, 0.0426611304, 0.0288249552, 0.0814919770, 0.0222577564, -0.1202073395, 0.0592716336, 0.0900196508, -0.1169716120, 0.1230040193, 0.0512403846, -0.0808941498, -0.0702457353, 0.0668503940, -0.0473646335, 0.0036875480, -0.1045293510, 0.1245166659, 0.1059449017, -0.1171206534, -0.0730869174, 0.0711046085, -0.0309334099, 0.1169625819, -0.0570140742, 0.0929233581, 0.1046490371, -0.1108600274, -0.0917326882, -0.0670425594, 0.0759420693, 0.0300822258, -0.0370340943, -0.0229620636, -0.0346711986, -0.0769945383, -0.0909703076, 0.0226964653, 0.1030936241, -0.1142002940, 0.0464524589, 0.0246202052, 0.0006955568, -0.0547794998, -0.0374593437, 0.1128261387, 0.0760224685, 0.0371193662, 0.0235800743, -0.0728905797, -0.0966969430, 0.0917049423, 0.0851304531, 0.1197624952, 0.1178597510, -0.0038159834, 0.1089985296, -0.0474649705, -0.0015284419, -0.0103996098, -0.0228453223, -0.0693486482, 0.1067973673, 0.0777550340, -0.0541895926, 0.0958304182, -0.0929971933, -0.0183739625, -0.1186127812, 0.0052585066, -0.0770348012, -0.0984342694, 0.0655108690, 0.0120390654, 0.0595247746, 0.1067967713, -0.0149639370, 0.0546495616, 0.0232147276, -0.1012468636, 0.0104255686, 0.1424997449, -0.0244496483, 0.0232909787, -0.0417962335, -0.0044684755, -0.0329646207, -0.1248422563, -0.1018025875, 0.0033950806, 0.0412231982, -0.0981736258, -0.0345618427, 0.1284591109, -0.0793106556, -0.0109877950, 0.0008829445, 0.0189695582, -0.0033825338, -0.0745128393, 0.0372235179, 0.0427922010, -0.0011344306, -0.1085850000, -0.0427317806, -0.1604052335, 0.0170014389, 0.0569230877, 0.0705143437, -0.0932852551, 0.1992642730, -0.0099678198, -0.0110996803, -0.0640260652, 0.0036968668, 0.0239873547, -0.0078730909, -0.0248109736, 0.0355163962, 0.1082652286, 0.0245461371, 0.0580525734, 0.0128149679, -0.0514162444, -0.0142980954, -0.0154300174, 0.0556553826, -0.0318851098, 0.0662980601, 0.0892117396, -0.1231451407, -0.0647181347, 0.0063532125, -0.1736170352, -0.1575813591, -0.0574782677, 0.0301459040, -0.0171307232, 0.3559324145, -0.0293194652, -0.0564125553, -0.0208543148, -0.1403355598, 0.0044872747, 0.0662884414, -0.0634695739, 0.0734881610, 0.0273722336, -0.0242565777, 0.0492358021, -0.0376893207, 0.0452587642, 0.0091384370, 0.0247477032, -0.0273404624, -0.2668165565, -0.2746458352, -0.0659126043, 0.0583384670, -0.1456359178, -0.1582632512, -0.1336496621, -0.1420181245, -0.0045808670, 0.0791350901, -0.0271262322, -0.1313210726, -0.0069674766, 0.0336813033, 0.0163549241, -0.0471757352, 0.0162872970, -0.0915081948, 0.0810199678, 0.3724802136, -0.0703080073, -0.0336236879, -0.2731791139, 0.0818066448, 0.0042534689, -0.0003923205, -0.1239998937, -0.1672240496, -0.0522836260, -0.1097346246, 0.1565632075, 0.0899254829, 0.0090916334, 0.0155805787, -0.1916949004, 0.0652161241, -0.1365258694, 0.0556285903, 0.0089751855, 0.0072118128, -0.1585697681, -0.0033384450, 0.0032499009, -0.5095068216, 0.0468932688, 0.0300446227, -0.3085701764, -0.0466128476, -0.0610747822, 0.1224270687, 0.1461075097, -0.1110334694, -0.0719106346, -0.1522752941, -0.1363400370, 0.0142243244, 0.0354263633, -0.0202818532, -0.2450295538, -0.0624746308, -0.1534760445, 0.0134343887, 0.0543338917, 0.0481539853, -0.0315405652, 0.0328586921, 0.0097056702, -0.0653495863, 0.0972563475, -0.1815210283, -0.0345611349, -0.1409227252, -0.0943246037, -0.1530279964, -0.0719328746, 0.0786637291, 0.0267752111, -0.1852121949, -0.0529026575, 0.1186034754, -0.0665845945, -0.0291092228, -0.0279770177, -0.0592678487, 0.3935380280, -0.0471854322, 0.0975779146, 0.0946448520, 0.0022955760, -0.0160308052, 0.0147080291, 0.0965629146, -0.0089696189, -0.0690845922, -0.0112308590, -0.1360643506, 0.0229271967, -0.0049723131, 0.1095305383, -0.1918279380, -0.0254428107, 0.0567445941, -0.0626486912, -0.1048574448, -0.0085968859, -0.0169383995, -0.1015661731, -0.0200981554, 0.1583626121, 0.3786287308, -0.0114190308, -0.0862688795, -0.0188352857, -0.0561786667, -0.0305504855, 0.0676686987, -0.0453826189, -0.2537996173, -0.0681287199, 0.0095198471, 0.0871849358, -0.0149006797, 0.0686197877, -0.0179603230, -0.1489618272, 0.0938679427, -0.0764517337, 0.0801655427, 0.0244648214, 0.0607221499, -0.0504783876, -0.1094447523, -0.1503110081, 0.0308994446, 0.1795959324, -0.0565134473, 0.0043210220, -0.0497073233, -0.0599914491, 0.0371088125, 0.0778851435, -0.1651571840, 0.0164911672, -0.0159919187, -0.1523393244, -0.1092081740, -0.0757411122, -0.0269789565, 0.0163079146, -0.0302165840, -0.0142235365, 0.0506787896, -0.0608777665, -0.0726945177, 0.0955465809, 0.0918069333, -0.1328153163, 0.1188295186, -0.0211752653, 0.1410495341, -0.0906427428, -0.0265579540, 0.0542502217, -0.0074483999, -0.1498219222, -0.1604384035, 0.0824867636, -0.0551731661, -0.1204118803, 0.0264271963, 0.0472432375, 0.2274423987, -0.1105346382, -0.1615713835, -0.3971963525, 0.0052787745, -0.1363535970, -0.0819074064, -0.0064193136, -0.2118136734, 0.1863368303, 0.0252876803, 0.1136975512, -0.0375187658, -0.3472826183, -0.0930455849, -0.0040925317, 0.1076656505, -0.3964547813, 0.0091408622, 0.0241859630, 0.1987071484, 0.2380889356, 0.0253314245, 0.0737952590, -0.0037226670, -0.0006875040, -0.0998307988, -0.2110596746, 0.0627922267, 0.0670460314, -0.1295669079, 0.3933102787, -0.0412692726, -0.0218732040, -0.2776508629, -0.1595471650, -0.2530841827, -0.0122907097, -0.4017346501, -0.1822619140, 0.0282307137, -0.2335763425, -0.1364306957, 0.1821198314, 0.0308850780, -0.0134440511, -0.4580939412, 0.2797601521, 0.0336316079, -0.0534328073, -0.0515502058, 0.0138036786, -0.1208886653, 0.0409921966, 0.1034929007, -0.0020958793, 0.1861125380, -0.1726313680, -0.0658458471, -0.0597335175, 0.0810713321, -0.0888294727, -0.0701526105, -0.0619572625, 0.1161523312, -0.0179072432, -0.6977534294, 0.0296523068, -0.3287332654, -0.1282330900, 0.0680020154, 0.0557748005, -0.1693681329, 0.2230826020, -0.0175837539, -0.4663214386, -0.3098973334, 0.4544276595, -0.0487866737, -0.0940891579, -0.1263285726, -0.0256438646, -0.2544071674, -0.2943878472, -0.0096343486, 0.2115053236, -0.3032764792, 0.4088735282, 0.1266938895, -0.1952809989, -0.4449801445, -0.0870806500, -0.0498310030, 0.2807894349, -0.1703701764, -0.0149449706, -0.0458592474, -0.0057883239, 0.3863335252, -0.2265188396, -0.0621752441, 0.0526157357, 0.4561648965, -0.0426582843, 0.1275534779, -0.0887296870, 0.2323295176, -0.8996599913, -0.1967001259, -0.0976421535, -0.0875466019, -0.0304824598, 0.4780385792, 0.1705727577, -0.4489494860, -0.1056866720, -0.2007271498, -0.1869869381, -0.1139061153, -0.3167299330, -0.0547529645, -0.2222959399, 0.0502046905, -0.1235670671, -0.1381363422, -0.1173485443, -0.0636237562, 0.0427879617, -0.0319554918, -0.2011111826, -0.0449787416, -0.1815192103, -0.0230467506, 0.0886351690, -0.2408588529, -0.0544032194, -0.1787191480, 0.0331129991, -0.1243084446, 0.0605252087, -0.3531060815, -0.1273837537, -0.4971112907, 0.2611902356, -0.1380201429, -0.2120530307, -0.0700170919, -0.5958391428, -0.1846230775, -0.0039093010, 0.0151119232, 0.2321313471, -0.1909858733, 0.1470521390, -0.9735594988, -0.1888714582, 0.1656015813, 0.0235837922, -0.1708151847, -0.1668323576, -0.0741508454, -0.1964643598, -0.4783955514, 0.0461718589, -0.1582176685, 0.0919238180, -0.0039098626, -0.0803282261, 0.0576564632, -0.1723765284, -0.3380026817, -0.1372967362, 0.1708539575, -0.7071639895, -0.6731873751, -0.5593644977, -0.2006618828, -0.1974666417, -0.1506615728, 0.0012179501, -0.1524291486, -0.1729588956, -0.5257396102, -0.3762528896, -0.3692174256, -0.1164600849, -0.1921598613, -0.1777970046, -0.1095229834, -0.1559911817, 0.0239588507, -0.1855695993, 0.0917643234, 0.0620133206, 0.1583001316, -0.0572710708, 0.0377285033, 0.0189343467, -0.1450669914, -0.2790513635, -0.0131919226, -0.1629620492, -0.4708838761, -0.2008870542, 0.1627285928, -0.8068379760, -0.1480823010, -0.1190036684, -0.0236512311, -0.0832693502, -0.3991916180, 0.3471115232, -0.1583578140, -0.3608406782, 0.0204740763, -0.1525232047, -0.0562486686, -0.1261754185, -0.0871146619, -0.8927423358, -0.1304820776, -0.1220875084, -0.1268544793, -0.1930784583, -0.1046426296, 0.2436105758, -0.0784048438, -0.4870955050, 0.0692214221, 0.0238324124, -0.1692032367, -0.1732094437, 0.2742409706, -0.8997184038, 0.1502116472, 0.1748710126, -0.8467493057, -1.2838534117, -0.1029528305, -0.0044400487, -0.3047676980, -0.5095592737, 0.0373626277, -0.0787174180, 0.1451044977, -0.0778672099, 0.0754965320, -0.0393129438, -0.1716853976, -0.5226578116, -0.0247437414, -0.1575235128, 0.0782775283, -0.6383245587, 0.0461425669, 0.0282660183, -0.0816870481, -0.1479100734, -0.2251154780, -0.9344902039, -0.1801455915, -0.1502043158, -0.0792901590, -0.3421108425, 0.2914336026, -0.1496470422, -0.2000897229, -0.1638710350, -0.1126512587, 0.1965013295, -1.3732370138, 0.2464599311, 0.1629063487, -0.0800981522, -0.0306367949, 0.0537430197, -0.3765960932, 0.0607288517, -0.1683224738, -0.0220183451, -0.0191577896, -0.1711178571, 0.0382361598, -0.0177750811, -0.2506131232, -0.2706139088, -0.1299940199, 0.2300183028, -0.0777309164, -0.1572201401, -0.1572181582, 0.0721665025, 0.0006786964, -0.0007746083, 0.2949506044, 0.0236133002, -0.1146325395, -0.0186867137, 0.0728175342, -0.1020480096, -0.0241697654, 0.0558480397, 0.0499208756, 0.0168820638, 0.0052528256, -0.1624504924, -0.0358140692, -0.0567795373, -0.9015069604, 0.0189545825, 0.0577263646, -0.0018791679, -0.2062339783, -0.1291559935, 0.0661524162, -0.1009686142, 0.2291570902, -1.7863541842, -0.0898084864, -0.0014815715, 0.2726148069, 0.0066355364, -0.2371300757, -0.3649587035, -0.3492776155, 0.0133315567, 0.0460945033, 0.0368849896, -0.0172587484, -0.2173509747, -0.1329577267, -2.8631739616, -0.1234422699, -0.7344650626, -0.1018021256, 0.0759857297, -0.1543010473, -0.0022655905, 0.1689890921, 0.2591913939, 0.0799853355, 0.2860397696, -0.2147106975, 0.2182929814, -1.6622362137, -0.1736556590, 0.2323969752, -1.0140902996, -0.0858511850, -0.3245969713, -0.1834123582, -0.0238112025, -0.0565315485, 0.0105019929, -0.4593517184, -0.1980815828, -0.0865057781, -0.0578628182, 0.3974108696, -0.1314890832, -0.2423105538, -0.0798676908, -0.0465945750, -0.7785680890, -0.0116223721, -0.0662599355, 0.0085255690, -0.0880313739, -0.2875057161, -0.0641125962, 0.0539668202, -0.1412497312, -0.2007914931, -0.1512120068, -0.1193141937, -0.2542552948, 0.0085710911, -0.5335586071, -0.0890859514, -0.1203376427, -0.0983024240, -0.0279778317, 0.0608954430, 0.2806140780, -0.1424316019, -0.1422027498, -0.0231380910, -0.1840945333, 0.0538086481, 0.0644952282, 0.1302465796, -0.0404444113, -1.1784367561, 0.0111051258, -0.0415264480, 0.0174507629, 0.1043192372, -0.0609905161, -0.1364046484, -0.1432308108, 0.0200027991, -0.0848932639, 0.3483889103, -0.0970995352, -0.0315115973, -0.0176035315, -0.0083083753, -0.6742318869, -0.1328727603, -0.2687096000, -0.1419298500, -0.0635883138, -0.7190902233, 0.0650944784, -0.0811217725, -0.0562841557, -0.2694348693, -3.2680442333, 0.3243826926, -0.6235247850, -0.1280868053, -0.4887036681, -0.5022180676, -0.1235581487, 0.0054038023, -0.3185105026, -0.6649491787, 0.0034813855, -0.1459874064, 0.0740493536, -1.1910098791, -0.0021088987, -0.1616375595, 0.0351654105, -0.1193258390, 0.0000433314, 0.0097768493, -0.0823977366, -0.1866815686, -0.0615729354, 0.0700816736, -0.5919289589, 0.0345210172, -0.1865133643, -0.0130434604, 0.2439940274, -0.0156358760, 0.0605671778, -0.0514452010, -0.1085676774, -0.0212003645, 0.0053321058, -0.0277562197, -0.0324140415, -0.4157136679, 0.0905640796, 0.0454669110, -0.0270801391, -0.3030793965, -0.1015131101, 0.3210632503, 0.4999814332, -0.0354284942, -0.0025664673, -0.1574734747, -0.1087663472, -0.0613660701, -0.7613198757, 0.0722822845, -0.6718102098, -0.0507512316, -0.1327609569, -0.0665582120, -0.0482726954, -0.1477429271, -0.4849357605, -0.1470565200, 0.0060682264, -0.0352322459, 0.0449915230, 0.2341015190, -0.2368194014, -0.1211651042, -0.0980355367, -0.2305627167, -0.0158209633, 0.0636847839, -0.0481932759, -0.2617476583, -1.6234520674, -0.2946381867, 0.1343499869, -0.7227469087, 0.0801190808, -0.0820409954, -0.0490284227, -0.0647717863, 0.1689784676, -0.1086377874, -0.4999338090, 0.2127523273, -0.1272985488, -0.5419420004, 0.0283474363, -0.2102824003, -0.1795836985, -0.1693759561, -0.0638420582, 0.1318091154, -0.1162519753, -0.0005048153, -0.0684199482, 0.0361260548, -0.0295295529, -0.4869325757, -0.4799885452, -0.1303363144, 0.0883984715, -0.0184410904, 0.1389424205, -0.5224246979, -0.7029178143, -0.0047348663, -0.2437343150, 0.1267120838, 0.2662098110, -0.5251258612, 0.8844140768, 0.3061568439, 0.0017481174, -0.1524091959, 0.0091045182, 0.0212681033, -0.2499791980, -0.0787589699, -0.0930997655, -0.6582616568, 0.0794242471, 0.3018223047, -0.0406493135, -0.3810029626, -0.0385304168, -0.2062272578, 0.1711675078, -0.0717508644, 0.0843850225, 0.0823305100, -0.0358157605, -0.1540774554, -0.0158253293, -0.0878989995, -0.0189762805, 0.0339890718, -0.0534768291, -0.1305190325, 0.0400590524, -0.0391764343, -0.1477136612, -0.1696433276, 0.0507310405, 0.0449529663, 0.0761750862, -0.0731658563, 0.1504978538, 0.0363250524, -0.0666414946, -0.0112256696, -0.0263986234, -0.0357511155, 0.0154587477, -0.1243131161, 0.0317529328, 0.1693059057, 0.0034251218, 0.1142146736, -0.0600720383, 0.0843361914, -0.0999796987, 0.1546872109, 0.0465687886, -0.0592806637, -0.0097297179, -0.1014535725, 0.1239431277, 0.0691275001, -0.2170649320, -0.0057161110, 0.2132967114, -0.0016090545, -0.0997087806, 0.0815832540, -0.0355069824, -0.0508588627, 0.0832576454, 0.0774150789, -0.0497170761, 0.0395182110, -0.3467463255, -0.2082047611, -0.0015771566, -0.0201703552, 0.1929532290, -0.0622825660, 0.1197456643, 0.0394033603, -0.0185972862, -0.0507243313, -0.0020775329, 0.0026563890, -0.0257703904, -0.0795761794, -0.1607722938, -0.0767373145, 0.0124065997, 0.1036490873, -0.0587983429, 0.0284127854, 0.1034666151, 0.2340662032, -0.0917902216, -0.0863118917, 0.0987784863, -0.0504338630, -0.0460958965, -0.0093412641, 0.0936696380, 0.0628215149, -0.0182433948, 0.1124262363, 0.0569253862, -0.0418885238, -0.1165225804, -0.0562595837, -0.1190168560, -0.1512939632, 0.0841778889, 0.0709371790, -0.1268211603, 0.0791038051, -0.0888082311, 0.0590260588, 0.0016291240, -0.0186089464, -0.0625301749, 0.0277885832, 0.0702756867, 0.0833389312, -0.0152521040, 0.0602144413, -0.0386594273, -0.0222899187, -0.0412173867, -0.1929109097, 0.0778636336, 0.0393953919, -0.1294103861, 0.0676985756, 0.0554745272, -0.1296785474, 0.0295083933, 0.0088590831, -0.0481733717, -0.0041743899, -0.0101668816, 0.0779279768, 0.0415319838, -0.3243581355, 0.0094733620, -0.2343762964, -0.0290460084, 0.0425055362, -0.0179156214, -0.0374620371, -0.1235015988, -0.0937375724, 0.3096856475, 0.1435347050, 0.1009387746, 0.0105979880, -0.0632494837, -0.1289588958, 0.0272246748, 0.1283930689, -0.0874434412, -0.0159104448, 0.1091512144, -0.0341368355, -0.1464622915, 0.1619713157, 0.0726772249, -0.0723019838, -0.0836049467, -0.1908088624, 0.1519000381, 0.0005532387, 0.1058070138, 0.0772780851, -0.0325913727, 0.0297040101, -0.3185193837, 0.0326033831, 0.0081542302, 0.0054236157, -0.1168531775, 0.0822603554, -0.0233970322, -0.1229380965, 0.0302322488, -0.0039673913, -0.0006617484, -0.0843057558, -0.0271774661, 0.1092365310, -0.0696734190, -0.0769569650, -0.0261517894, -0.0821260884, -0.0680598691, -0.0840714276, -0.1409743577, 0.0745222420, 0.0188868362, -0.0069143712, -0.0896969363, 0.0840328485, -0.1853118688, -0.0141491210, 0.0344077908, -0.0036923289, 0.0076644910, 0.0317408442, -0.0524233729, 0.2523470521, 0.1044441685, 0.0913325548, -0.1014641225, 0.1093861461, 0.0540488921, 0.0453387648, -0.0263160169, -0.0248701368, -0.1277465522, -0.0631988570, -0.0249027237, -0.1021884382, -0.0341585763, -0.1616495401, 0.1513666064, 0.0318838954, 0.0320135280, 0.0395789668, 0.1131137908, -0.2462363094, -0.1404976398, 0.0693717971, -0.1466011703, -0.1612240821, -0.0425721742, -0.0108086271, -0.0735955387, -0.1035347804, 0.1399346888, -0.1072043329, -0.0915937424, -0.1665658653, 0.0108354725, 0.0718171820, 0.1019559801, -0.0653763339, -0.0327329673, 0.3414388895, -0.0977552235, -0.0253318846, -0.0120224552, 0.0876009837, 0.0715791807, -0.0521168299, -0.1516468376, 0.0010072087, -0.1802261174, 0.0755440891, 0.1361940056, -0.0483912267, -0.0576336309, -0.0979784057, 0.4143436551, -0.2114194036, -0.1172615290, 0.0089843487, -0.0492607504, -0.0878423005, -0.0468771011, 0.0766237155, 0.0685125962, 0.0009097438, -0.0809940845, 0.1377213448, -0.0119112162, -0.0051921043, -0.0653463304, -0.0002925992, 0.0355533101, 0.0179531872, -0.0441834927, -0.1246887222, -0.0285061486, 0.0864317119, -0.1161442101, -0.0928108916, -0.1958917975, -0.0870080590, 0.1070258692, -0.0480110943, 0.1139334291, -0.0894182622, 0.0713066831, 0.1197534502, 0.0486620329, 0.0329608507, -0.1278240234, -0.0596563183, -0.0947731733, -0.0454794466, 0.1139726639, -0.1148312390, -0.0671393573, 0.0690280721, 0.1071852371, 0.0937689766, -0.0398182310, 0.0961310938, -0.0238670968, -0.0658630803, -0.1278931499, -0.0529619828, 0.0371561348, -0.0401960015, 0.1164173558, -0.0868352130, -0.1143407524, 0.1004829109, -0.0727913380, 0.0690661147, 0.0729724318, -0.0061308290, -0.0879175216, -0.0880783424, -0.0226832498, -0.0105326651, 0.1136972979, 0.0219258387, -0.0601616837, -0.0673904568, 0.0765142739, -0.1103086472, 0.0053724842, -0.0528693609, 0.0620326959, 0.0244405624, -0.1020351350, -0.0821267590, -0.0313715525, -0.0349957272, -0.0868097469, -0.1023543775, 0.0748546720, -0.0869034603, 0.0683971494, -0.0847088546, -0.1028243601, -0.0083449781, -0.0361688435, -0.0475096963, 0.0356541276, 0.1036543027, 0.0601237230, 0.0801523030, 0.1143848896, -0.0613877922, 0.1207585633, -0.0292111728, -0.1200183034, -0.1101678759, 0.1005005762, 0.0210195705, -0.0304379165, -0.0097389491, 0.0402153023, -0.0256781857, 0.0336803682, -0.0269691311, 0.0302822888, 0.0884612203, 0.0395642146, 0.0418082774, -0.0333431251, -0.0717386305, 0.0198133979, 0.1169624552, 0.1069960892, 0.0750025511, -0.0331212245, -0.1312399507, 0.0666213408, -0.0841361061, -0.0959508047, -0.1108226404, 0.0422157049, -0.0170561969, -0.1154078543, 0.0442679748, -0.1149950922, -0.1191302836, -0.1316521764, -0.0473260023, 0.0412257873, 0.0231072512, -0.0151931643, 0.0243133027, -0.0559873022, 0.0886401236, 0.0233223941, 0.0020230711, 0.0970206112, -0.0396093912, -0.1145261899, -0.0909644142, 0.0274703279, 0.0959316343, 0.0081211356, -0.0780244470, 0.0784044489, 0.0431097820, -0.1092649251, 0.0106783463, 0.0188815165, -0.0406198315, -0.1290636659, 0.1160387620, -0.0330469497, 0.1160872132, 0.0637265742, 0.0479328372, -0.0913516507, -0.0757411122, -0.0882210061, 0.0682469904, 0.0660222098, -0.1112219393, -0.0165042132, -0.0135026658, 0.1009104773, 0.0934734195, 0.0784488469, 0.0136566758, 0.0933885798, -0.0158348605, 0.0121122086, -0.0942320749, 0.0771750808, -0.0228278041, 0.0260353554, -0.0598699152, 0.0158349741, -0.0772115663, -0.0980920568, 0.0446647704, 0.0711921453, -0.0368197747, -0.0872194916, -0.0260886103, 0.0042259004, 0.0350570679, 0.1118602827, 0.1267350316, -0.0550776459, -0.0103251245, -0.0938020349, 0.0863317251, 0.0254515409, -0.0326182470, -0.0862259343, -0.1139728948, 0.0175562203, 0.0466290675, -0.0517781675, 0.1006400436, -0.0020051550, 0.0154733416, 0.0824321806, 0.0767260492, 0.0572286546, -0.0834017247, 0.0933141112, 0.0611995608, -0.1073603854, 0.0274441224, 0.0845501572, -0.0147644291, -0.0746555328, -0.0199315529, 0.0826216862, 0.0630595908, 0.0838814899, 0.0903450474, 0.0192098860, -0.0341162160, 0.0605426691, -0.0107439160, -0.0632308498, -0.0303105209, 0.0645320565, 0.0724439025, -0.0252498984, -0.0402450114, -0.0875984132, -0.0460764728, 0.0390402041, -0.0899276137, 0.0448163860, -0.0119388225, 0.0921109915, 0.1145282760, -0.0289356690, 0.0612139367, -0.0545661747, -0.0659961626, 0.0057563782, 0.0569569468, 0.0164677203, 0.0614414215, -0.1190318167, -0.1237086430, -0.0748964846, -0.0882977396, 0.0427811444, -0.0807676464, -0.0370700322, 0.0077210995, 0.0549521782, -0.0102689434, -0.1676692516, -0.0041643330, -0.0161737278, -0.0251854137, -0.1098520234, -0.0831985474, -0.1192671657, 0.0051305331, 0.0385131948, 0.0379021019, 0.0706419721, 0.0843907371, 0.0804300010, 0.0646179020, 0.0817983001, -0.2067655623, 0.1732840687, 0.0217494369, -0.0117283873, -1.0944994688, -4.4559183121, 0.1424903423, 0.0156783666, -0.0636713058, -0.0445720591, -0.0962798670, -0.2771501243, -0.0166353248, 0.0428292081, -0.0618619882, -0.1707106084, 0.0474142358, -0.1689841300, -0.0017131617, -0.2040008456, -1.5555157661, -0.0032077618, -1.6555540562, -0.0051775058, -0.0100122718, -0.1661363095, 0.0708049461, -0.1390980333, 0.1278569102, -0.7012045383, -0.0731465369, -0.1089318022, 0.0132522983, -0.0904591233, -0.0972863659, -0.2836540937, 0.2531006932, -0.1285298020, 0.0150856413, -0.0684841052, -0.0539113469, -0.2044426352, -0.0873372406, -0.1000387892, 0.1367001384, 0.0230019651, -0.0400119126, -0.1645126790, -0.0617879443, -0.0256755091, -0.7080211043, 0.0146383429, -0.0174645279, 0.4593888819, 0.0194557067, -0.5784477592, -1.1427124739, -0.0574044846, 0.3227405250, -0.2158953547, -0.0975078791, -0.0881877244, 0.0224575438, -0.0501959845, 0.0653928444, 0.0000254673, 0.0132532073, -0.1042102128, -0.1254057139, -0.1785851717, -1.3381292820, -0.0907367021, 0.3239508271, -0.0206468478, 0.1600981951, 0.2763980329, 0.0476218574, -0.0741703361, -0.0051439158, -0.0157669000, -0.7675127387, -1.2656514645, 0.1869617999, -0.2312164605, 0.0271062590, 0.0015679749, -0.2246771902, -0.1236036718, -0.0285416078, -0.1999326050, -0.2215205431, -0.1162981912, -0.0242442582, -0.0545483492, -0.0334358811, -0.1256545484, -0.0130506130, -0.1445471197, -0.0495040528, -0.3402237296, -0.1510404050, 0.0384664834, -0.0651613325, -0.1094360277, 0.4484417439, 0.0244442075, -0.1000498459, -0.0960030258, -0.3770861030, -0.0339742154, 0.1582279205, -0.4353305101, 0.0215932615, -0.1082917526, 0.1003893092, -0.3415814638, -0.1513527334, 0.0152734369, -0.2057621032, 0.0221655257, 0.0135281766, -0.2627718449, -0.1397007555, -0.1239575073, 0.0690082833, -0.1242231801, -0.1174114048, -0.0317625180, -0.0414878242, -0.4814069867, -0.4165368080, 0.1028956622, 0.0126287863, 0.0110232532, -1.0934941769, -0.0453276597, 0.0308324341, 0.1361688823, 0.2026203871, 0.0813311264, 0.0430554710, -0.2853562832, -0.9903475046, -0.3020213544, -0.2256279290, -0.1045882851, -0.0929746926, -5.6628818512, -0.0975259915, -0.1929261982, -0.7315393090, 0.0747628435, -0.4820294082, -0.1552237421, 0.0676289052, -0.6302447915, 0.0629683882, -0.9804643393, 0.0117468582, -0.1055850983, -0.0585751534, -0.1323746741, -0.0409928784, -0.0879862681, -0.0239068121, -0.0939475596, 0.1669550389, -1.2346498966, -0.1013267934, -0.0842858404, 0.1597997099, 0.0349693038, -0.5396206975, 0.2089650482, -0.6101441383, -0.1417621821, -0.0349907428, -0.0679516569, -0.0926742405, 0.0305656288, -0.0280320290, -0.8802452683, -0.0666486993, -0.0041851383, -0.0022885625, -0.1474816948, -0.1617133915, 0.1213475391, 0.0820638090, -0.0795347914, -0.0043126312, 0.0685947239, 0.1316768825, -0.2187023312, -0.0775179192, -0.2879979014, -0.2564041317, -0.4547914565, -0.0186028089, 0.0226815566, -0.2353284210, -0.3646635711, -0.2541470528, 0.1676952392, -0.0977754146, 0.2188028693, 0.0083435420, 0.0042711846, -0.1370075047, -0.3090253174, -0.1041919440, -0.2867233455, 0.1616801471, -0.1356605440, 0.0175223183, -0.0278895628, -0.1346412748, -0.2560245395, 0.0538610928, 0.0671801642, 0.3379792571, -0.2986917496, 0.0120267896, 0.0149833169, 0.2594742179, 0.1177923232, 0.1496253163, -0.3028237224, -0.0434482694, -0.1008943394, -0.0346307419, -0.0831421986, 0.1207513735, -0.3330845833, -0.0541032404, -0.1591314971, -2.2061059475, 0.0462157317, -0.1768007576, -0.3384545743, 0.3119126558, -0.0793646723, 0.0099584498, -0.0742673129, -0.0696527436, -0.9150921702, -0.0905557945, 0.2440299541, -0.4023945928, -0.0594342202, -0.3797151148, -0.0759220272, -0.0076068672, 0.1561119705, -0.3979324698, -0.2457755655, -0.0330535397, 0.0113469316, 0.0060104788, -0.1157860309, 0.0832138583, 0.1370508522, 0.0711740777, 0.0250266343, -0.1294102669, 0.1172917485, -0.0612946637, -0.0018213118, 0.0462792516, 0.1250577569, 0.1159142926, -0.1061139628, -0.0367676802, -0.0746661797, -0.0530252568, -0.0168102756, 0.0297750700, 0.0720331073, 0.1102282405, 0.0254298635, -0.0765791908, 0.1099373326, 0.0188239254, 0.0445672572, 0.0379051901, -0.0704958290, -0.0768002644, -0.1621304005, -0.2205508798, -0.0818509683, -0.0792589337, 0.0329139046, -0.0011878962, 0.1125003770, 0.0808571205, -0.0805949867, 0.0008754170, 0.0910752341, 0.1325575262, 0.0727637857, -0.0541963987, -0.0865688846, 0.0086218016, 0.0177084245, -0.0517020635, 0.0755103156, -0.1310376972, 0.0132028367, 0.1004786268, -0.0601235405, 0.0577349998, 0.0971674770, -0.1022729054, -0.0958925560, 0.0215061884, -0.0008085006, -0.1082999483, 0.0464704596, -0.0219268687, -0.1132175475, -0.0688226894, 0.0613490604, 0.0915922821, 0.0868324712, 0.1163819581, -0.1399727315, 0.2529022396, -0.0020724237, 0.0713671371, -0.1166417897, -0.1243549958, -0.0027995491, -0.0963690430, -0.1231052577, -0.0411048718, 0.0110711753, 0.0905102193, 0.0893695503, 0.0363953039, 0.0712936521, 0.0215573888, 0.0051665306, 0.0810085461, 0.0802489221, -0.0248221867, 0.0459123440, -0.0220974982, 0.0300778691, 0.0802059844, 0.0280200299, 0.0788868666, 0.1142371446, -0.1142720357, 0.0932295620, 0.1231328249, 0.0134365140, 0.0443251394, -0.0215666518, 0.0441451259, 0.0213882420, -0.0762608200, 0.1473580748, 0.0381779484, -0.1184446365, 0.0787830204, -0.0497006513, 0.0416781045, 0.0683185533, -0.0106974542, 0.0523976572, 0.1373538822, 0.0361561179, 0.0903751701, -0.0400639139, 0.0035652537, 0.0442873761, 0.0186344236, -0.1199187785, -0.0274459831, 0.0782445073, -0.0512894094, -0.0685282052, -0.0694630146, -0.0316728167, 0.0305815786, -0.0293025095, 0.0801317915, 0.0162897855, 0.0670914352, -0.0727915317, -0.0261620674, 0.0295680221, -0.0088059949, 0.0472948514, 0.0091448631, 0.1116094142, 0.0896256492, 0.0469833501, 0.0085260030, 0.1102007553, 0.0196370147, -0.0923678949, 0.0313277654, -0.1320272088, -0.0028434084, -0.0011806962, -0.1163301542, 0.0272200778, -0.0887760669, -0.0864177272, -0.1240653545, -0.1307744980, -0.1283890158, -0.0028912793, 0.0295983013, 0.0917929411, 0.0201205909, -0.0002878151, -0.1009986103, -0.1109380051, 0.0773440003, -0.0486907437, 0.1522296518, -0.0414169729, 0.0649879649, 0.0737503618, 0.0681601465, 0.0150611866, 0.0944445953, -0.1169538721, -0.0682611018, 0.0299268570, 0.0534354113, 0.0647110343, 0.0979021117, 0.1413375586, 0.0482583605, 0.0033839815, 0.1218272746, -0.0778778493, 0.1077829301, 0.0768177435, 0.0384565815, 0.0028505276, -0.0579472668, 0.0096564591, 0.0190817416, 0.0911255181, -0.0075037708, 0.2396416664, -0.0918331817, -0.0418604165, 0.1389456242, 0.0558069870, 0.1588249058, -0.0469056070, -0.0310204290, 0.0645746365, 0.1001452729, -0.0319024511, 0.0100072268, 0.0203052964, 0.0308339801, -0.1314218491, 0.0837501585, 0.0103798918, -0.0419992469, 0.0609583445, 0.0300794989, 0.0104532838, 0.1070966870, -0.0804594532, -0.1187501401, 0.0790933371, 0.0708622336, -0.0726266876, -0.0748680755, -0.1162882298, 0.0605602115, -0.1171100438, -0.0678672642, -0.0978422761, -0.0843076110, -0.1065881178, 0.0099460781, -0.0712579340, 0.0416974835, 0.1088406593, -0.1087719053, -0.1075369567, -0.0149393138, 0.0105601391, -0.1056490168, -0.0890232697, 0.0352939293, 0.1199014932, -0.0892800689, -0.1629837453, -0.0305893440, -0.0438436270, -0.0506142713, -0.0820315927, 0.0409025252, 0.0130264061, 0.1253664047, -0.0556539297, 0.1167173162, -0.1814302802, 0.0699586123, -0.0257125888, -0.0507213771, 0.1308742017, -0.3722274303, 0.1361241788, -0.0170508921, -0.0084449919, -0.2202106118, -0.1982428282, -0.2616659701, -0.1489732563, -0.0849062800, -0.2301132381, -0.0892396048, -1.0365037918, -0.0686463416, -0.0311404709, 1.0256747007, -0.9003384113, 0.0088606533, 0.1216123775, 0.0135429353, 0.0225539170, -1.3345260620, 0.0190689228, -1.0557215214, 0.0038671559, -0.4085687101, -0.1105163023, -0.0176416468, -0.0801170766, -0.2493564039, -0.2138715684, 0.1423699111, -0.0530004725, 0.2743059099, 0.0313215852, -0.1249142587, -0.0677884072, -0.1338342130, -0.0071278466, 0.0131368022, -0.1277047694, 0.0017653041, -1.6809231043, 0.0180976726, -0.0924908742, 0.1762243509, 0.2087096274, 0.0672566369, -0.0670167878, -0.2051119655, -0.0071166055, 0.1918392330, -1.0904690027, -0.0171103142, -0.7617076635, 0.0983618349, -0.6256982088, -0.2018167973, -0.1567264348, 0.3592860699, -0.4941759408, 0.0158282332, 0.0654098466, -0.0390670076, 0.0157694481, 0.0770873725, -0.0020256587, -0.3245495856, -0.0141879981, -0.0873050839, -0.1578309983, -0.9422603846, -0.0543172956, -0.8856518865, -0.0094826296, -1.0949695110, -1.2722411156, -0.0551027320, -0.1545601487, -0.1899728030, -0.0884055793, -0.4764573872, -1.8070551157, -0.8270872831, -0.1927278638, -0.1401130408, -0.0752194226, 0.0823619068, -0.9221094847, 0.0130337244, 0.2701530159, -0.0148784611, -0.1130157262, 0.0731739402, -0.1542847455, -0.0102619529, -1.3224930763, 0.3859545588, -0.2011129707, -0.0160197187, -0.2190876007, -0.6795414090, -0.1448495835, -0.5998116136, 0.0417303778, 0.0513095893, -0.0014365042, -0.0833375081, 0.0281685740, 0.0686325505, -0.1409379691, -0.1418959200, 0.0434419811, -0.0355398506, -0.1893488914, 0.1241113096, 0.1385458410, 0.1099747419, -0.1232550219, -0.5900286436, -0.8288028836, -0.1382940412, -0.1436613053, 0.6872425079, 0.1192043871, -1.1329104900, -0.0213925019, -0.0056684124, -0.0969840884, -0.2743562460, -1.7030746937, 1.0644221306, 0.4067592323, -0.3320737779, -0.3632234037, -0.2028662860, -0.1328985095, 0.0052130036, -0.9032600522, -1.0761270523, -0.0504875779, 0.1627647877, -0.4487764239, 0.1870570928, -0.3514577448, -0.0342316888, -0.0201600902, 0.0509757698, 0.0046750521, 0.0710921884, 0.0893898383, 0.1316477358, 2.0819883347, -1.8588166237, -0.3544653058, 0.0583165921, -1.0120648146, -0.1955676675, -2.1629102230, 0.0067533841, -0.1044127345, -0.0905745700, -0.3817294538, 0.4426215887, -0.0095281107, 0.0897425860, -0.0100421822, -0.0870506093, 0.3957693577, 0.0453632921, -0.1708279997, -0.2903092504, -0.2466900349, -1.5271672010, 0.0957431346, -1.8656144142, 0.1170130894, -0.2532575727, -0.0982039347, -0.2405460328, 1.1434533596, -0.1606781036, -1.1332370043, 0.0581116378, 0.0337552242, -0.0052687819, -0.2372894287, -0.1470331401, -0.2253000438, -0.3558333218, -0.1004227921, 0.1027170122, 0.0032005031, -0.0134607460, -0.7107817531, 1.2886602879, -0.1161084622, -0.0709709078, -0.3907815814, -0.0716750622, 0.0413955636, 0.2811050713, -0.0221572351, 0.3387956619, 0.5053579807, -0.2397154123, -0.0857252479, 0.0105295628, -0.0460444316, -0.1863199621, 0.7699800730, -0.0138508417, 0.0143925250, 0.5799200535, 0.0367528275, 0.3057798743, -0.0769592151, -0.4993355870, -0.4153342247, -0.0649891049, -0.0135647245, -1.2449144125, -0.6026057601, 0.0137700019, 0.2849886119, -0.3952489793, 0.0332862027, -0.0786754489, -0.4423862994, -0.0411225967, 0.0245672837, -0.2354222983, -0.0694264844, 0.8777091503, 0.1567266136, -0.2336947918, 0.0741402358, -0.1745864600, 0.0441799574, 0.1039343774, -0.1904164553, 0.1651582122, 0.8598314524, 0.0088716121, -0.0125565771, -0.0065610511, -0.2156240791, 0.0480436906, -0.1580186337, -0.1055291817, -0.0237019286, 1.0442707539, -0.0306868926, -0.2461580783, 0.0885006338, -0.0422839932, -0.1390680522, -0.1189106554, 0.3187675476, 0.0022618058, 0.0586538091, -0.7760466337, 0.0062091374, -0.0675216615, -0.0066584633, -0.0886808410, -0.1519879550, -0.0975683555, -0.3104232550, -0.0859228969, -0.0117449453, -0.0961231589, 0.0019909539, 0.0035324513, -0.1104400381, 0.0878751948, -0.0099891014, 0.0197093375, 0.0389887132, -0.4053931236, 0.0019475080, -0.2308604717, -0.1268235147, -0.1692247987, -0.1379862428, -0.0149030061, -3.1793789864, 0.2463515401, -0.0715698451, -0.3168700337, -0.1050793529, -0.0906528682, 0.0840061158, -0.3168367147, -0.1299589574, -0.1535655409, -0.0397645719, 0.1217880622, -0.1707272381, -0.0127637209, -0.3842235804, -0.3146156967, -0.2619047463, -0.0855800211, -0.0148973130, -0.2330988646, 0.0003080046, -0.6868761778, -0.0806500018, -0.0755974501, -0.0293380413, -0.2937091887, -0.5793404579, -0.8492763042, -0.0903413221, 0.0660326630, -0.1190869510, -0.0040011634, -3.5255172253, -0.2420862168, 0.0731176808, -0.0079854829, 0.0037316962, 0.0189803354, 0.0375653990, 0.1452220827, -0.0514780805, 0.6953494549, -0.0502578020, 0.3552442789, 0.0275003724, -0.6484390497, 0.0703120753, 0.0480462722, -0.0382803343, 0.0320316628, -0.1172467843, -0.0354111046, 0.1440122575, -0.2037354857, 0.1065796092, 0.1890156567, -0.0089139678, -0.0144036915, 0.7121113539, 0.0256364830, -0.6927020550, 0.1064935178, -0.0884070545, -0.0677900687, -0.1403870881, 0.0346188806, -0.5117901564, 0.1581906229, 0.0802124292, 0.0447001494, -0.7589146495, 0.0353832617, -0.2400805950, -0.0529464260, -0.0139375413, 0.9976411462, -0.0333420821, -0.1024781838, 0.1321333498, -0.5508782268, -0.0005771518, -0.0562983602, -1.1396546364, -0.0330947079, 0.0415374488, 0.0119477669, -0.5689743757, -0.1231026053, -0.2057320774, -0.3167022765, -0.0689546093, 0.0430104882, -1.0305356979, -0.1485660821, -0.1457210332, 0.4174914062, -0.1965903044, -0.1543502063, 0.0726044774, -0.1843212545, 0.3474958241, 0.0308526326, 0.4063444436, -0.2365907282, 0.1366394013, 0.0429060124, -0.0203559306, -0.1662855446, 0.1523040831, 0.2438434511, -0.0125828506, -0.2353069782, 0.2182748616, -0.0603872910, -0.3045942485, -0.0352450982, -0.1575674117, 0.0344571210, 0.0030742034, -0.0173474941, -0.0051211803, 0.2343621850, 0.3028201163, 0.4753786922, -0.8164388537, -0.0815004632, 0.1944968700, -0.0198741015, -0.1831223220, 0.0181691162, 0.0397446863, 0.0374812298, 0.6084937453, 0.2295943946, 0.0078358883, -0.0748231933, 0.0311750621, 0.0030790824, -0.1224194020, -0.0260773022, -0.0806441382, 0.0333938822, 0.0449848324, -0.2241188437, -0.7909393311, -0.3126157522, 0.1371028274, 0.0320374221, -0.1450838894, -0.8912636638, 0.3516894579, -0.0120680574, -0.2809560597, -0.0082648452, -0.1663066894, -0.1326660961, -0.2515016794, 0.0563990586, -0.8701559305, -0.0852978155, 0.0130316298, 0.0849418640, 0.0149881514, -0.4344702065, -1.3716937304, 1.0353252888, -0.7443137169, 0.0872072503, 0.0175786130, 0.0499335900, -0.0534118712, 0.0277855489, 0.2746571302, 0.0938939601, 0.1583432704, -0.4818561673, -0.9679890275, 0.0371255390, -0.0050188042, -0.1374471188, -0.1132847443, -0.1398877501, -0.0378170162, -0.1444323212, -0.1209376901, -0.4314814806, 0.0752680600, -0.2343584746, -0.2153447866, 0.0243535154, -0.0178656951, -0.1982430369, 0.1866768301, 0.0542832054, -0.0307619181, -0.2818164825, 0.1059436351, -0.1489761770, -0.1532607824, -0.0259630810, -0.0710286647, 0.0797060728, -0.0406415388, -1.3705658913, -0.2057766318, -0.2069218308, -0.5888673067, -0.0588602200, -0.4046714902, -0.0008633164, -0.3098259270, 0.3298439085, -2.4784264565, -0.2665624022, -0.0123186577, -0.1078058854, -0.6468964219, 0.0254026167, -0.6485961676, -0.0762253851, 0.0424750820, -0.1732243598, -0.0260402001, -0.3240850270, 0.4073551595, -0.5634983778, -1.3012391329, -0.0432122312, -0.9029598832, -0.0097022671, -0.0945515782, 0.1491883844, -0.0044096098, -0.3050640523, -0.1281345189, -0.1540634632, -0.2330316454, -0.0068479287, 0.3712681830, -0.1268151850, 0.0789616629, -0.1185326502, -0.6413589120, 0.0137448600, -0.0155643178, -0.2511076331, -0.0541541241, 0.2536072135, -0.0889861509, 0.3919800818, 0.0090102535, -0.0033348659, -0.0039448082, -0.0035179583, -0.0834850371, 0.6637750864, 0.1690861583, -0.1603192389, -0.0166153647, -0.2792394161, -0.0581247397, 0.4009379745, 0.0702816173, -0.1627434641, 0.0160694178, 0.0053203851, -0.0758471861, -0.0255856849, -0.0731535479, 0.0008479683, -0.1596711725, 0.1901806444, -0.2078786790, 0.0078011318, -0.1354142278, -0.0572314113, 0.0790877715, 0.0659009367, 0.1588088423, -0.0042286445, 0.1805566102, 0.0156686138, -0.4780485034, 0.0674815550, 0.0677926093, -1.8678199053, 0.0411144085, -0.0812084079, -0.6069888473, 0.2229133248, -0.0639307722, -0.0796840861, 0.0066153985, 0.6563273668, -0.1948251575, -0.0414684303, -0.2560490072, 0.0161424428, -0.0865356252, 0.4518614709, -0.0201302040, -0.0140399542, -0.5151864290, -0.0538628548, 0.0341108702, -0.0458275490, -0.1412286460, 0.0164922178, -0.0063955607, 0.0938620120, 0.1626306772, 0.1076016128, -0.1586886048, -0.0615673214, 0.4297212064, -0.1846034527, 0.2490528971, -0.0076933382, -0.1271543205, -0.0830285847, -0.2982806861, -0.0192784239, -0.0209027473, 0.4451671839, 0.0216057934, -0.0317429006, -0.0986746550, 0.0108911311, 0.1718229055, -0.1756833941, -0.1410100907, -0.1907666624, 0.0330554806, 0.0577908792, -0.0559372641, -0.0766898096, -0.0027340271, 0.1353672147, 0.4081884027, -0.1394336522, -0.3983195126, 0.4850960374, -0.3224815428, -0.0536527932, 0.0541510433, 0.0820360631, 0.2843002081, 0.0597051270, 0.5651356578, 0.0568855926, -0.0992733836, -0.1975021213, -0.0704533607, -0.0452275574, -0.0511581600, -0.2213114947, -1.0787304640, 0.1975102425, -0.1472671479, -0.0495850444, -0.1135884151, -0.8919225335, -0.0756498724, -0.1466135532, 0.3841278553, -0.2327399254, 0.0242963340, 0.0934473127, -0.0788558051, 0.0629229769, -0.6637321115, -0.0939237326, -0.1490880996, 0.0021966193, -0.0045686467, -0.0284708366, -0.0382646360, 0.2465890050, -0.5499699116, 0.2512938082, -0.3646225035, 0.0126649439, 0.6706730127, -0.0638195872, -0.2807515264, 0.0192773342, -0.0476569235, -0.0093441932, -0.5341276526, -2.0538237095, -0.0940704271, 0.1108244136, -0.0257881023, 0.3753064871, 0.1932747811, -0.0777094588, -0.1374995857, 0.2694483399, -0.0737068504, -0.4956132770, -0.6277657747, 0.4649480581, -0.0832614824, -0.0054361844, -0.0577504225, 0.2929878235, 0.3849513829, 0.0436613970, 0.2927130163, -0.0768538043, -0.0714579299, -0.1221082583, -0.3506910205, -0.1158540770, -0.3619681001, 0.0164520722, 0.0250922926, -0.1175181270, -0.0432929099, -0.0373597890, -0.0675317571, 0.4031344056, 0.0065816198, -0.0236660838, -0.5661922693, -0.1460151374, 0.0660412386, -0.4049074948, -0.5318345428, 0.5303913355, 0.4495642781, 0.3533869684, 0.3206678033, -0.0662806854, 0.0224976167, 0.2185179591, -0.1024572998, -0.2050110251, 0.0275788475, -0.7181247473, -0.1623869687, 0.2381966561, 0.0347861275, -0.0076415464, 0.0158652514, -0.0474271588, -0.0350307897, -0.1033416614, 0.3461409807, 0.0210264511, 0.1177407578, 0.1075786725, 0.0526102185, -1.7530993223, 0.4392415285, -0.0826982632, -0.1249564067, -0.0353950225, 0.0342178605, -0.1915153265, -0.4248355329, -0.0829064623, 0.0304866079, 0.0338794440, 0.0936553255, 0.0092588570, 0.0933192521, 0.1539638340, 0.3170135021, -0.1636503339, 0.0172864422, -0.2108612210, -0.5598065853, -0.1560263783, -0.9344218373, -0.0650903583, -0.0022033555, 0.1291761696, -0.0726702884, -0.5039823055, -0.1273241490, -0.1507607400, 0.0977008790, 0.0642919764, -0.0758496895, -0.1851276904, 0.0790697634, -0.1190698966, 0.0024287892, 0.0167190805, 0.1028844193, 0.0446434394, 0.0307218842, 0.0564696454, -0.0907931328, 0.0616141036, 0.0037115454, -0.0262795519, 0.0510470234, -0.0304905809, 0.1108892038, 0.0622959286, 0.0574403144, -0.1495989710, 0.0050768689, -0.0188435186, 0.1225378960, -0.1472534090, -0.1221196130, 0.0376771502, -0.0500575304, 0.0715069994, -0.0332321860, 0.0192594919, 0.0456331708, -0.0531815551, -0.1824649125, -0.0291219167, -0.0384071991, 0.1654407978, -0.0451062247, -0.1081769168, -0.1578588337, -0.1039542854, -0.0318606384, 0.0545154773, -0.1512228847, 0.0204885677, 0.2939328849, 0.0944377407, 0.0161305387, -0.0570707843, -0.0097360127, -0.1100383252, 0.1284062266, 0.0778455511, -0.0241955630, 0.2098274976, -0.0379620120, 0.0702308267, -0.0794325471, -0.2247984409, 0.1040334329, -0.0056730793, -0.0760568976, -0.0978502035, 0.0720213205, 0.0443267524, 0.0188913345, -0.1094240174, 0.0942417681, 0.0266195852, -0.0197923202, -0.0928658098, 0.0574276447, -0.2520058453, -0.0072753727, -0.0135390367, -0.1020010933, -0.0112720998, 0.0822986588, 0.0722207949, -0.1105220169, 0.0071858307, -0.0482260771, -0.0523052625, 0.0457775667, 0.0167979002, 0.1211954653, -0.0000183246, -0.1176836938, -0.0463973247, -0.2416362166, 0.1369976997, -0.0293783844, -0.0705228746, -0.0054959613, -0.0904000029, 0.0151503133, 0.0795242116, 0.2034407854, -0.0338698477, 0.1499018967, -0.0545945652, -0.0847657993, -0.0565893091, -0.0373562276, -0.0184378028, -0.0044965534, -0.1178327426, -0.0578192659, -0.0812804103, -0.1005965471, -0.0007396009, 0.0297494158, -0.0811057091, -0.0980895013, 0.0041392781, 0.0037850032, -0.0720924661, 0.0594348647, 0.0534030534, -0.1510073394, 0.0594370365, -0.0733689591, 0.1628179550, -0.1350163072, 0.0174465235, -0.0682454407, 0.0062499018, 0.0448505767, -0.0470723771, -0.0700869411, 0.0351845659, -0.0744750947, -0.0572297759, 0.0005760422, -0.0296269171, 0.1152012870, -0.0072822967, 0.0226289704, -0.1316997260, -0.1447685361, -0.0247236900, -0.0768960118, -0.0798726529, 0.0871872306, -0.0680033937, -0.0474279374, 0.0866448954, -0.0332209244, -0.1292595267, 0.1064845398, 0.1133565158, -0.0293414779, -0.0190632604, -0.0465084054, 0.0190305840, 0.0430409461, -0.0506028719, -0.0046881428, -0.0001761177, -0.0536221564, -0.0416136123, 0.0028104384, -0.0298702009, -0.0585934743, -0.0012200486, -0.0773349032, -0.0285572074, 0.0603422634, 0.1297171563, 0.0025221717, -0.0504222549, 0.0437010974, 0.3122957051, -0.1655722260, 0.0271954052, -0.0053846603, 0.0614509620, -0.0906411111, -0.0763165653, -0.0023083715, 0.0222076084, -0.1134556830, 0.1510627568, 0.0150126517, 0.0748533159, 0.1315884441, 0.1556484550, -0.0101924855, -0.2176851481, 0.0484352522, 0.0522909164, -0.0714094788, -0.1082044691, 0.1319395304, 0.0065279524, -0.1088469997, 0.0288825389, -0.1379602104, -0.1028006822, 0.1028928459, -0.0443059914, -0.0237221662, -0.1050092727, 0.0349002555, 0.0071554426, -0.1501582563, -0.0790611207, 0.0663318709, 0.1022161543, -0.0467221215, 0.1543793678, 0.0041373116, 0.1638191491, -0.0479169935, 0.0680354908, 0.0623494983, 0.1803848594, 0.1299704164, 0.0397801250, 0.0063533545, -0.0321577415, 0.0866180956, 0.0226847380, 0.0306997169, -0.0417064205, 0.0449073464, 0.0314060450, 0.1293309927, -0.0734311342, -0.0955840424, 0.0177659336, -0.0397594497, 0.0396048762, 0.0771434009, 0.0175047964, 0.0110615222, -0.0344625115, -0.0546637587, 0.0647055060, 0.0011109621, 0.0742280409, -0.0760705993, -0.0885409936, -0.0533982739, 0.0516745374, -0.0284387078, 0.0369677879, 0.0261604190, 0.0457908101, 0.0383610316, 0.0107776523, -0.0290015806, 0.0572868884, -0.0392852351, -0.0575596355, 0.0154397702, -0.0352476947, 0.0258581992, -0.0098864958, 0.0944231078, 0.0984105170, -0.0526753962, -0.0167570449, 0.0188900046, 0.0701857209, -0.0012921895, 0.0456428304, 0.0409259200, -0.0328830779, -0.0635521710, 0.0538356379, -0.1008931696, -0.0140066231, -0.0950329229, -0.0544807799, 0.0115642389, -0.0496783741, -0.0885013714, -0.0250287130, -0.0431210548, -0.0103351660, 0.0571593978, -0.0253626052, -0.1226761043, -0.1493470669, -0.1308654696, -0.0053412435, 0.0699604452, -0.0474009551, -0.0047783777, 0.0219436996, -0.0845564678, -0.0072420109, 0.0490259230, 0.0486258157, -0.1720509827, -0.0263950620, -0.0812878162, -0.0123433955, 0.0500752144, 0.0498029590, -0.1518246830, -0.0059876456, -0.0277968273, -0.0276369657, 0.0019512032, 0.1237865612, -0.0596767142, 0.0280244630, -0.0391431041, 0.0542791709, -0.0458483174, 0.1040099710, 0.0256713666, 0.0275656953, -0.0264329687, -0.0352258943, 0.0637627095, -0.1383857280, -0.1491446346, -0.0712018535, -0.0135880029, 0.0313603953, 0.0147986030, -0.0065606278, 0.0572295263, 0.0428900905, -0.1087066531, -0.0893906876, -0.0076460415, -0.0134271653, -0.1055749506, -0.0479030274, 0.0954436287, -0.0580711514, 0.0212712083, 0.0049061435, 0.0291375238, 0.0485762283, -0.0132420333, 0.1218815446, 0.0002542032, 0.0919266418, -0.1521024108, -0.0691458508, -0.1042942405, 0.0364981666, 0.1008027047, 0.0235464405, -0.0596527904, -0.1105165109, 0.0371998288, -0.0328067243, 0.0858382881, -0.0493443720, -0.0209486187, -0.1050706878, 0.0155006899, 0.0153300734, 0.1250882298, -0.0519615971, 0.1552955061, 0.1141390726, 0.0585009418, 0.1310875565, -0.1145110354, -0.0128110554, -0.0184394699, 0.0339886583, -0.1304237992, 0.0380413011, -0.0288966950, 0.0989599153, -0.0898068696, -0.1381873339, -0.1008263677, -0.0997612774, 0.0553379022, 0.0692489073, -0.1087496579, -0.1537192762, 0.0879981145, 0.0406133197, -0.0314191580, 0.0561958142, 0.0231832135, 0.0718169212, -0.0461764671, 0.0837788880, 0.0595136806, -0.0702601075, 0.0493455678, -0.0852272958, -0.0610819012, 0.1162029430, -0.0041118199, -0.0747131705, 0.1515411735, -0.0912926868, -0.0408205613, 0.0331694372, 0.0920523927, -0.0211385153, -0.0083141644, 0.0348920710, 0.0682618022, -0.0249641128, 0.0041654864, -0.0513256639, -0.0463072658, 0.0281766634, 0.1471733451, -0.0500614829, 0.2166407108, -0.0759624764, 0.0333303735, 0.1129048541, -0.0570094697, -0.1234770194, 0.0651710629, 0.0343283117, 0.0706594437, -0.1273634881, -0.0033779300, 0.0641025156, 0.0107859792, 0.0984375030, 0.0137108620, 0.1054853126, -0.0687887743, 0.0898122266, 0.0521502905, -0.0094781434, -0.0721651912, 0.0109350095, 0.0042504459, -0.0092639439, -0.0300997552, 0.0645141751, 0.0651119351, -0.0700411573, -0.0206446089, 0.1101436764, -0.0490085967, 0.0346862674, -0.0289068911, -0.1130016446, -0.0345240235, 0.0281126294, -0.2028138041, 0.0070598521, 0.0205433406, 0.1619429737, -0.2101009935, -0.0337133780, -0.0445577390, -0.0444505252, 0.0274521653, -0.0859719589, 0.0673825815, -0.0923744887, 0.1502998471, -0.1233053207, 0.0118751200, -0.0310290661, 0.0293109901, -0.0733043402, -0.0456514806, 0.0651604459, -0.1127074733, -0.0618453138, 0.0360658057, 0.1986331940, -0.0647811145, -0.0971832052, 0.0260855239, 0.0357423015, -0.0527015366, -0.0783376396, 0.0838774741, 0.0619461872, 0.0450430773, 0.0839716569, -0.0489518531, -0.0521916263, -0.0030771045, -0.0061642458, 0.0527863838, 0.0999531075, -0.0057466114, 0.0458102226, -0.0659744889, -0.0568415262, -0.0422691852, -0.0597260371, -0.0873714387, 0.0540942773, -0.1446223557, -0.0689432397, -0.0910167992, -0.0460131951, 0.0568704009, -0.0408424772, -0.0978800952, 0.1186691374, -0.0474207737, -0.1138651818, -0.0444956794, 0.3180797100, -0.4287840128, 0.0970061123, 0.0963951871, 0.0446509793, -0.2672818899, -0.1504123211, 0.0117116580, 0.0443847664, -0.1340632141, 0.0065596150, 0.0188886896, -0.0078166695, 0.1046099663, 0.2252987027, 0.0388330594, 0.0803446993, 0.1033319011, 0.0247630291, -0.0896574557, -0.0462866426, 0.0197626185, -0.1437422931, -0.1020800844, -0.0155923450, -0.0029087772, -0.0368619561, -0.0521465726, 0.1045312658, 0.0496047735, 0.0012682633, -0.0632487014, 0.0504106544, -0.0377748795, 0.0163666476, -0.1072098240, 0.1109766811, -0.0809985623, 0.1078228354, 0.1009193510, 0.0290694758, 0.0336227342, 0.0220643971, 0.0151677392, -0.0642197281, 0.0400879122, 0.1106075943, -0.0217037480, -0.1761214137, 0.0164725352, 0.0374376625, 0.0224490780, 0.1063998863, -0.0077205901, -0.0084951995, -0.0636946037, -0.0578909144, 0.0087952595, 0.0819723979, 0.0026875248, 0.0164048821, 0.0824155957, 0.0250490103, 0.0338391885, -0.0032754592, -0.0445049442, 0.0369269550, 0.0655742511, 0.0183430612, 0.1746974736, 0.0245714244, -0.1039576232, 0.0813475847, -0.1170720905, 0.0117185721, -0.0772238970, -0.0367951728, 0.0531427264, -0.1219725758, -0.0021386789, -0.0194658395, -0.0610274449, -0.0824251026, -0.0146003664, 0.0701802522, 0.0436669402, -0.4007623196, 0.0389681794, 0.0925347358, -0.1310083568, 0.1154666469, -0.0439667515, -0.0060125343, -0.0038327586, 0.1193177924, 0.0293219164, -0.0596852601, -0.0215913001, -0.0742867887, 0.0941569582, -0.1091757119, -0.0570708625, 0.0918441638, -0.0558106974, 0.0766216144, -0.0323946029, -0.0960263759, -0.0214849748, 0.1114722639, 0.0828855857, 0.0285521988, -0.0460481420, -0.0816002563, -0.0140153067, -0.0504610538, 0.0076592346, -0.0892716944, 0.0604307950, 0.0057472591, -0.0364762247, -0.1232236177, 0.0875046626, 0.0818038881, 0.0604514033, -0.0761809945, -0.1331516206, 0.1281724125, 0.0134257935, 0.0909965485, 0.0386213921, -0.1167815328, -0.0779869184, 0.0456682742, 0.1219494939, -0.1296668053, 0.0299935527, -0.0114490576, 0.0647136271, -0.0144338692, 0.0061478037, -0.0500498824, 0.0652452707, -0.0731529146, 0.0863541886, -0.0707009658, 0.1249974743, -0.0229807217, 0.0443786457, -0.1094519049, -0.0473774783, 0.0474900603, -0.0965864733, -0.0920868441, -0.1105229035, -0.0638636649, 0.0607626699, 0.0508846343, -0.1016842797, 0.0780803487, 0.0928253904, 0.0440200903, 0.3039190769, 0.0342484824, -0.0182689428, 0.1030694246, -0.0845664069, 0.1112743318, 0.0479992516, 0.1013911590, 0.0497386456, 0.2617394030, -0.0483584814, 0.0579259545, 0.0408835560, 0.0845123604, -0.0172852520, 0.2461932749, 0.0141167380, -0.0984194949, 0.0166477151, 0.0668912604, 0.0274516810, 0.0166498031, -0.0413275957, 0.0314645581, 0.1268341541, -0.0724309385, 0.0758300722, 0.0255849939, -0.0776386708, 0.0688677579, -0.0620124154, -0.0529534966, 0.1067046672, -0.0569352210, -0.0897176266, 0.0616333745, -0.1316215545, 0.0602099635, 0.0540673360, -0.1318097711, 0.0915846229, 0.0352700874, 0.0413945019, -0.1099980250, -0.1167201176, 0.0231569428, -0.1000266522, -0.0258807745, 0.0428767055, 0.0065260986, -0.0544376262, 0.1419707686, 0.0878817290, -0.1515026689, -0.1138829589, -0.0463128164, -0.0850390494, -0.0883118957, -0.1079402342, 0.3085671961, -0.1021541059, 0.0299418271, 0.0865863338, -0.0052218828, -0.0547117218, 0.0324844904, -0.0652543753, -0.0078648105, 0.0622871444, -0.0196752846, 0.1208677217, -0.0299271941, -0.0790250674, -0.0060719652, -0.1335478872, 0.0528533123, -0.1394719183, -0.0363298394, -0.1435745060, -0.0030522577, -0.1137007177, 0.0172868632, 0.0976019874, 0.0521247126, -0.2904155254, -0.0543013774, -0.0818506628, -0.1163954958, 0.0056779399, 0.0009933178, 0.0196161438, -0.0723316148, 0.0315892361, -0.0076462324, -0.0228269324, -0.0542479157, -0.1747429073, -0.0460445732, 0.0617468320, -0.2261511534, -0.0043810280, -0.1281724870, -0.0037018813, 0.0784730092, -0.0072649447, -0.7950006723, -0.0183451194, 0.0617611110, 0.0946924537, -0.1231490150, -0.7172817588, -0.0790947005, -0.1602470726, -0.3605863452, 0.1337423325, -0.0019591355, -0.0643136874, -0.1421802938, -0.1849129200, -0.9078887105, 0.0373538956, 0.2106545120, -0.0015481615, 0.1097694710, -0.0231007412, 0.0773523152, 0.0119927824, -0.1477067769, -0.0147175258, -0.1948979944, -0.1223464683, -0.1959082931, 0.0587103330, -0.0790575966, -0.4293221831, 0.3073028028, -0.0377754755, 0.0653865486, -0.1062427685, 0.1358946711, -0.5350775123, -0.0018251070, 0.0509233475, -0.3238866925, 0.4507298470, -0.0015435093, -0.0622350723, 0.0447022133, -0.0785744786, -0.1385507286, -0.5246044993, -0.0639215931, -0.4857621193, -0.4224221408, -0.3427504301, 0.4179646075, -0.0566813685, 0.1498203278, -0.6048305035, -0.1215628386, 0.0430132896, -0.5497984886, -0.0584288016, -0.0321418457, -0.0012013490, -0.0830798447, 0.0250600055, -0.0433453284, -0.2277874947, 0.1019542515, -0.1629970223, -0.8347001672, -0.1775037497, -1.4473206997, -0.6572074890, -0.0162007753, -0.0215616822, -0.0084230294, -0.0302943457, 0.9632781148, 0.2779202759, -0.0110916868, 0.0226253830, 0.0744826943, 0.1296622902, -0.1267158538, 0.0301301479, -0.0854081586, -0.1033328623, 0.0481203161, -0.0435101204, -0.1202676743, -0.1292157173, -0.0460699685, 0.4744860232, 0.3000796735, 0.0318623111, 0.0061081080, 0.0374669880, 0.0393915735, 0.0754594579, -0.0510597676, 0.0267502051, -0.2695004344, -0.0110758543, -0.0552466474, -0.0549328066, -0.3125531077, -0.1286467314, -0.1337172836, -0.4808372855, -0.1276975870, -0.3874060810, -0.2436133027, 0.1536524296, -0.2515137196, -0.2369695008, -0.0278905388, 0.1985870153, 0.0446986444, -0.7258787751, 0.3363696933, 0.0477687307, -0.1817204505, -0.1759207547, 0.0310300905, -0.0344982259, -0.0291988626, -0.3398618400, 0.2525166571, -0.5077177882, 0.0049504000, 0.6438310742, -0.2919342518, -0.0677855238, -0.0877058357, -0.4311807156, 0.1927660257, 0.0695812404, -0.2321925312, -0.2698843479, -0.2253367752, 1.0263857841, -0.5234530568, 0.0404757597, -0.0673289225, 0.0102520641, -0.1742933393, -0.1619218588, -1.9932816029, -1.4721977711, 0.5646252036, 0.3262872398, -0.0428913385, -0.9629424810, 0.0213852841, 0.5089032054, -0.0081063006, -0.1174540147, -0.0472006984, -0.0112325689, 0.0531290658, 0.0063197343, 0.0895517617, 0.0139596676, 0.1512898505, 0.2224719822, -0.0513029881, -0.1049117148, 0.4716623724, -0.0250659473, 0.4692717493, -0.3459872603, 0.1175061166, -0.0862702057, -0.2225525528, -0.0640855208, 0.1678633094, -0.6360456347, -0.1308243275, 0.5151056647, -0.0008103261, 0.0375655368, -0.0758989677, 0.3823346198, -0.0012202571, 0.1288928241, 0.0469856560, 0.0026594866, -0.1127820089, -0.1383538991, -1.8892942667, -0.8366643786, -0.0486036763, 0.1521362960, 0.0255797431, -0.0869710669, -0.0821646973, -0.1311617792, 0.1490231156, -0.4218736291, 0.5688807964, 0.0939323232, -0.8294638395, -1.3447780609, 0.0950681418, -0.0700450540, -0.5916300416, 0.0505129620, -0.0724355727, 0.1223175153, 0.1326853931, -0.1246160194, 0.1931629032, -0.0186184142, -0.0848886073, 0.0791669562, -0.1778318435, -0.0467007421, -0.2647458315, -0.7030816674, 0.0044935653, -0.1287464052, 0.4024723172, -0.0178010780, 0.0614022389, 0.5351132154, -0.0565917417, -0.0060317968, -0.1053662524, 0.2155498266, -0.2136433721, -0.0370346047, -0.0648049265, 0.0410864614, -0.0490142480, 0.3716844320, -0.0266684368, -1.4071534872, 0.0629893839, 0.0542912111, 0.0322067291, -0.1205652282, -0.1543253958, 0.0341752954, -0.1915628463, 0.0607913807, -0.4741994739, -0.0938563421, -0.1782304645, -0.1482567787, -0.0675149187, -0.0913639367, 0.0336646996, 0.2608734667, -0.1257207245, -2.7655329704, -0.1201836988, 0.0072139818, -0.2478657663, 0.0028314260, 0.5839900374, 0.1010093167, -0.0837378204, 0.0316187292, 0.0034103373, -0.1276813000, -0.0675697252, -0.1697066724, 0.0188144464, -1.1652990580, 0.0106097637, -0.1322476268, -0.1052020490, -0.0013450943, 0.3197657168, -0.0404786505, 0.2497741580, -0.0009085361, -0.0072631878, -0.0470920950, -0.0032480217, 0.0454437658, 0.2480907738, -0.5706085563, -0.2117511183, 0.1012314558, -0.0362198614, -0.1249979660, -0.0733370036, -0.1245729625, 0.6448308825, -0.2881448865, 0.0331439525, -0.0212988891, 0.0694690198, 0.0244427975, 0.0671599805, -0.4473373890, -0.7169398665, 0.1986943632, -0.0755249932, -0.0388091467, 0.0243138298, 0.1003766730, -0.0684275404, -0.4373882115, -0.1156784296, -0.1484529078, 0.0502318293, 0.3999795914, 0.2729431689, 0.2986385226, 0.1498365700, -0.4293200970, 0.0526463129, 0.0677656159, -0.0362548605, 0.0224219281, -0.1514772922, -0.0007409849, 0.0206529852, -0.2075611949, -0.0234303996, -0.2222146690, 0.1539975852, -0.0381260216, 0.3286811411, 0.0242126212, -0.7706663609, -0.2316648513, -0.0072113839, -0.1409347802, -0.0343792960, 0.0355039388, 0.0561255105, -0.5404942036, 0.4400165379, 0.0216920730, -0.1010968834, 0.0150384717, -0.1456934214, 0.8782441020, -0.0272048879, 0.1522495300, -0.0089969803, 0.0596623830, 0.0266704969, 0.0417714193, -0.0254896227, 0.6438602209, -3.1819589138, -0.2526051104, -0.0010016836, -0.0517544821, -0.0234562773, 0.0048900959, 0.1165133715, -0.0779847726, -0.4669285715, -0.0255987048, 0.0065807756, -0.8969979286, -0.3333755732, -0.0308124516, -0.0780126676, 0.6353381276, 0.0069102198, 0.1145752817, -0.5428904295, 0.1629828960, -0.1774113625, -0.0894883797, 0.3970531821, 0.3419602215, -0.1157860532, 0.0436394401, 0.4398910701, -0.0896241292, -0.7045507431, 0.0234438125, -0.0131053235, -0.1359053403, -0.0536065809, 0.0757948086, -1.0494005680, 0.2682481110, -0.1711188406, -0.2976407111, 0.4602112770, -0.0032488117, -0.0131599130, -0.0420952961, 0.2383502424, 0.0685846508, -0.2535229921, -0.0846993774, -0.1151033267, -0.7441620231, -0.0734593719, -0.0300863925, -0.1311448514, 0.0021767574, 0.0171672963, -0.3054149151, -1.7378952503, -3.4462926388, -2.1998305321, -0.8960891366, 0.0959731862, -0.6847873926, -0.1028415039, 0.8387545347, 0.0269396510, -0.0553233400, -0.1479871273, -0.4265648723, 1.0029053688, -0.0306319185, -0.1178648248, -0.0090256175, 0.2249820828, 0.0939101800, -0.1067815274, 0.0699344277, -0.2376623750, -0.0499072820, -0.2606107593, -1.4105912447, 0.1970052272, -0.0953907967, -0.1030264124, -0.1163907945, -0.5054172277, 0.5524592400, -0.0842929929, 0.1395573765, -0.0845514163, 0.0608525611, 0.0360665098, -0.0259834956, -0.0450648591, -1.0938405991, -0.0068312529, -0.0648645535, 0.0688751638, -0.0534909330, -0.4455674291, -0.6206182241, -0.4744139612, 0.3512699306, -0.4589920640, 0.7763820291, -0.0097192703, 0.0010927218, -0.2596160173, -1.5773249865, -0.4189442396, 0.3051467538, -1.3774557114, -0.2081961781, -0.0985210910, -0.0427294560, -0.6739031672, 0.0057558804, 0.0927174538, -0.2852510512, -0.0422139205, -0.1439079642, -0.0148220221, -0.0690053254, 0.4920379519, -0.6931586862, 0.0214787032, -0.0952049717, -0.6706641316, 0.0117785949, 0.0432017148, -0.1255863607, 0.4313713610, 0.0172041971, 0.0743604749, -0.0361496322, 0.0179667603, -0.0588140674, -0.1050762609, 0.0514819324, -0.7940486670, 0.2946581244, -0.1451323777, -0.0826089680, 0.0173931532, -0.2010671049, -0.2491934597, -0.5315891504, 0.2365732938, -0.2006970793, -0.0439154878, -0.0233972576, -0.1567498744, -0.4851734638, 0.0365170352, 0.4529457688, 0.0451909453, 0.0065500545, -0.5577932000, 0.0144206677, -0.5573037863, -1.1233763695, -0.7967981100, 0.1577277482, -0.2088108361, -1.1889827251, 0.0878815353, 0.0285267960, -0.8035303354, -0.0068634059, 0.2835419774, -0.0448884927, -0.0854116455, -0.0806133002, 0.0484912284, -0.6480738521, -0.0021360407, -0.0376774222, -0.2945584059, -0.2132547796, -0.0137240123, -0.0705264062, -0.0294825584, 0.0166647639, -0.6938294172, 0.0743091926, 0.3342221677, 0.0053568608, -0.4883228838, 0.0774604008, -0.0381694213, -0.0414753780, -0.2076393962, -0.0926190615, 0.0691913292, 0.1216172725, -0.3293825388, 0.0371055901, 0.0011859649, 0.5167559981, 0.8783047795, -0.0686753020, 0.0294284020, 0.0553614944, -0.1658268422, -1.2811740637, 0.2181362808, -0.3239697516, -0.6475955248, -0.6220733523, -0.1296387464, -0.0581502840, 0.0278136563, -0.0690728202, -0.2417707741, 0.2798410654, 0.0739902556, -0.5667342544, 0.0981151834, 1.4927680492, 1.1615195274, 0.3437571824, 0.4933330715, -0.5673034787, -0.1356853396, -0.1155402660, -0.8031674623, -0.0354310386, 0.0234574676, -0.0081519103, -0.8166435957, 0.0212557763, 0.1144113317, 0.0287469495, -0.3879912496, -0.0538772233, -1.2020552158, -0.1864364296, 0.1348450035, -0.4160141051, -0.1664114743, -0.0016277406, -0.4021251500, -0.0673006997, -0.8644766212, -1.3027080297, -0.5611433387, -0.0536465012, 0.0898761973, -0.0819141269, 0.2557881474, 0.2683495581, 0.0969671533, 1.0410907269, 0.0220457632, -0.0305008572, 0.0887767300, 0.1934228837, -0.0597030409, -0.3512837291, -0.0486024134, -0.0945195705, 0.0149529055, 0.1687304974, 0.0030767431, -0.0551783368, -0.0303415470, 0.2303504348, 0.0263838843, -0.0178636853, -0.0358071811, -0.0888554305, 0.1403398812, -0.0924001709, -1.1265467405, -0.3754218221, 0.0589584596, -0.0020098186, 0.5009626746, -0.5300024748, 0.0442618914, 0.0628263131, 0.6959531903, 0.3024585247, -0.0684154257, -1.2238744497, -0.4318050742, -0.0762081966, -0.1195079312, -0.0422687456, 0.1219037026, -0.0420660190, -0.1290653199, -0.0355393402, -0.9454442859, -0.4809184670, 0.0469687879, 0.0266559757, -0.3750289679, 0.0157810599, -0.0340342112, 0.0185398646, -0.7486643791, 0.0858301893, -0.2831670046, -0.0790645406, 0.3925043941, -0.0115918275, 0.4742018878, -0.0067860954, -0.0619918928, -0.0105695780, -0.0907023028, 0.1042743176, -0.2527500689, -1.5353386402, -0.5868315101, -0.6115302444, -0.1577183753, -0.4331107438, 0.0203170776, -0.0139515717, 0.0071821646, -0.0715269595, -0.0274581164, -0.1961273253, -1.9194438457, 0.1112461984, -0.0633631572, 0.0601225421, -0.7607685924, -1.9404749870, 0.0362836048, -0.0032596451, 0.5003661513, -0.1213548928, -0.7117591500, -0.0317706093, -0.9554175735, 0.1837235689, -0.0593621731, 0.0353516862, -1.3352978230, 0.5612694025, 0.0481418706, 0.6602364779, -0.0748047382, 0.0671837032, -0.0956026986, -0.0181838516, -0.1239043251, 0.1053375229, 0.0179279577, 0.0195021145, -0.1229403317, -0.0878956020, -1.2895035744, -0.7233683467, 0.2139587998, 0.7525572777, 0.4864965677, 0.5904661417, -0.0103629716, -0.0515639782, -0.1359127760, 0.0106886420, -0.9337567091, -0.5902349949, -0.1115271375, 0.3100712597, -0.1231262982, 0.0978895351, -0.5736917853, 0.3484848440, -0.0180192683, 0.1266440451, -0.0508339331, 0.0598975532, -0.1157844663, -0.0767236054, -0.0734949932, -0.2931101620, -0.0607072748, 0.1202624291, -0.3695468009, -0.0603435896, -0.0223186575, -0.0897510499, -0.1170862019, -0.0267239567, -0.2902182639, -0.6117659211, -0.0957966447, 0.0257098656, 0.1476943046, 0.0465624183, -0.6810609698, -0.2712884545, 0.0070065721, -1.1849973202, -0.0754401609, -0.0309449006, -0.1601497978, 0.3332595825, 0.3011634946, -0.0387967601, -0.1324327886, -0.1124902219, -0.1387861967, 0.0162576381, -0.1004444212, -0.6117487550, -0.1494911462, 0.1000322104, -0.3269556463, 0.1516267657, 0.0146911740, -0.3642102182, -0.0499180220, 0.1257325262, -0.0468197763, -0.0525515378, -0.0497231185, 0.0735544637, 0.0656665117, 0.0799567625, -0.1215841472, 0.1071574539, 0.0857959539, -0.1198397279, -0.1011168659, -0.0939700603, -0.0426609814, 0.0615054704, 0.0643408000, 0.0716130137, -0.1163999438, 0.0709055141, -0.1007914171, -0.0761422813, -0.0078455107, 0.1065741777, -0.0466281176, -0.1295691431, 0.0211248044, -0.1303339303, 0.0562674552, -0.0540419035, 0.0974512324, -0.1073539853, -0.0634054840, 0.0954437852, 0.0911619663, 0.0023479760, 0.0618897602, -0.0210038219, -0.1126136482, 0.0806140602, -0.0189151168, -0.1116439104, -0.0075274222, -0.0149498843, -0.0105258822, 0.0432589054, 0.1234273314, -0.0413175672, 0.0246038530, -0.0242675319, 0.1104739308, 0.0777888671, -0.1185622811, 0.1022425219, 0.0233251508, 0.0431942642, -0.0754730031, -0.0175418295, -0.1078447551, -0.0155665949, -0.1046440601, -0.0585784018, 0.0691378266, -0.0676396787, 0.0156862997, -0.0864170119, -0.0960577726, 0.1173877418, -0.0331667662, -0.0039992989, 0.0838200077, -0.0513003618, -0.0347069204, -0.1236495078, -0.1120168269, -0.1170283556, 0.0915300027, -0.1195070148, -0.0408639014, -0.0417923629, -0.0523917191, 0.0280989110, -0.0445481539, -0.0132108685, -0.0337548554, -0.0938858166, 0.1150088906, -0.0050918758, -0.1257172972, 0.0689647794, 0.1200350076, -0.0795263126, 0.0064863265, 0.0912835300, 0.0724258423, -0.1127718389, -0.0778087974, -0.0900222808, 0.1096922755, 0.0451192744, -0.0813172087, -0.0577803850, 0.0330234468, -0.1150328517, -0.0190565493, 0.1140854135, 0.0612781942, 0.0905468985, -0.0794869736, -0.0587688684, 0.0103961825, 0.0841227174, -0.0224922299, -0.0168338101, 0.0039721131, -0.1084440351, -0.0866831616, 0.0824888125, -0.1234465837, 0.0058974028, -0.0271554068, -0.0377196781, 0.0401895344, 0.1018196568, 0.1055505574, 0.1065922603, -0.0173812024, -0.1172058806, -0.0539821051, -0.0530439094, 0.0821192786, -0.0027394632, -0.0670184493, 0.0923611000, 0.0329034775, 0.0285666101, -0.0064651067, -0.0508502759, -0.0527376495, 0.0360610262, -0.0617524534, -0.1034183055, 0.0434015393, -0.1219844222, 0.0005439245, -0.0300472714, -0.1103780270, -0.1193576753, 0.1138892472, 0.1115520447, -0.0198110044, -0.0074023665, -0.0540635847, 0.1109437868, -0.0277209934, -0.0956402197, 0.0258275587, 0.0905039757, -0.1054849997, 0.0559915006, -0.0592757836, 0.0899611413, 0.0186735094, 0.0060960338, -0.0780491233, 0.1292797625, -0.1243409365, -0.0494221151, -0.0466767550, 0.1014898568, -0.0510441735, -0.1071796119, -0.0865794718, 0.1097261310, 0.0787416399, -0.0535629019, 0.1164625883, 0.1075330377, -0.0603197254, -0.1147561967, 0.1061359197, 0.0286748409, 0.0329725519, -0.1214290038, -0.0663584545, -0.0746329725, -0.0064396332, 0.0759782791, 0.0852259174, -0.0202522110, -0.0904285386, 0.1225087643, 0.0838993192, 0.0045884848, -0.0112145049, 0.1065067649, 0.0866872072, -0.0148054985, -0.0343215540, 0.0868375525, -0.0601187013, -0.0009850860, -0.0104538491, 0.0827553719, 0.0686288029, 0.0626882091, 0.0220283940, 0.0322768688, -0.1149697080, 0.0910571739, 0.1035782099, -0.0493650436, -0.0046686693, -0.0833280310, 0.1184422672, -0.1001819968, 0.0206946209, -0.0904466361, 0.0779936239, 0.0904232338, 0.1225941479, 0.0273135006, 0.0225914717, 0.0666038096, 0.1010876670, 0.0792279392, -0.1051226556, -0.0534606576, 0.0553574897, -0.0074961782, -0.0333364308, -0.0774232447, -0.1056699380, 0.0141990781, 0.0048267734, 0.0360433459, 0.0684551895, -0.0594722815, -0.1083306670, -0.0964584649, -0.1210675612, 0.0592908002, 0.1125851721, 0.0174104273, 0.0422550142, 0.1151714996, -0.0986994207, 0.0131584890, -0.0657230616, 0.0857616067, -0.1145029888, 0.0538447201, -0.0728024840, 0.0755372494, 0.0800755620, 0.1165908575, 0.0158724785, 0.0312220603, 0.0502900667, 0.0608279258, -0.1444929242, 0.0580137707, 0.1224120259, 0.0863870904, -0.1652955711, 0.0463619083, -0.0385217480, -0.0430251732, -0.0793948621, -0.0346845128, -0.0999355689, 0.0387612656, 0.0534354150, -0.1270717382, -0.0384849049, -0.1133378074, 0.0365399010, -0.1274338961, -0.0203020982, 0.0417358540, 0.0460943095, 0.0605614036, 0.0152131030, -0.0827470720, -0.1272473037, -0.0112434532, 0.1170427948, -0.0550723188, 0.0865396485, 0.0451965481, 0.0737022907, 0.0836936310, -0.1307743043, -0.0213288348, 0.0887273476, 0.0319713652, -0.0024744272, -0.1088120341, 0.0109337745, 0.0273808725, 0.1003444865, 0.0206124727, 0.0162904989, -0.1661216021, 0.0126141449, -0.1350643337, -0.0348531604, -0.0914508402, 0.0631657764, -0.0675162971, 0.0424763486, -0.0006895678, -0.0564106964, -0.0592588596, 0.0190285966, -0.1071222946, -0.0990065485, -0.1635975540, -0.0340950713, -0.0824121907, -0.1026197299, 0.0428628549, -0.0561910421, -0.0294218641, -0.1547475457, -0.1016855910, 0.0444735624, -0.0069911545, 0.0727378950, -0.0737168193, 0.0886219889, -0.0218004230, 0.0480973423, -0.3414386213, -0.0329962336, -0.0885236934, -0.0705257654, -0.0099798506, -0.1323591471, -0.0068575800, -0.1468855143, 0.0526808463, 0.0006965991, -0.1463512033, -0.0759081393, -0.1048738956, -0.0327601209, 0.1304329783, 0.0779069886, 0.0857930705, -0.0129200714, 0.0555912666, -0.1516322196, -0.0347456895, -0.0270358976, -0.2153714001, -0.0087887356, 0.0415650718, -0.0754188001, 0.0800275058, 0.0679444969, 0.0109257102, 0.0619237497, 0.0681985989, -0.0084044272, -0.1561951637, -0.3539534211, -0.0477418602, -0.1019809768, -0.1243393347, -0.0310748108, 0.0141014084, -0.0200909767, 0.0680863634, 0.1227196530, -0.0728019401, -0.0666333884, 0.1643737108, -0.0046774694, 0.1065441892, 0.0289682373, 0.0082794782, -0.0585827194, 0.1555816829, 0.0284421667, 0.0807235911, 0.0863474533, -0.1163619235, 0.0211389083, 0.2482223362, 0.0492499806, -0.0866741091, 0.1369967610, -0.1335261911, -0.0499687530, 0.1206980869, -0.3548400104, 0.0171924103, -0.0014403003, -0.0757018402, -0.0855136514, -0.0557349995, 0.0335213393, -0.0453433432, -0.0417394079, -0.0116277654, -0.0654163212, -0.0324537903, 0.0297854040, 0.1112828106, -0.0529629737, -0.0115260556, -0.0795210898, -0.1872300208, -0.1514315307, -0.1774618477, 0.0412921943, 0.0084345443, 0.0256097782, 0.1342339814, -0.1385244131, 0.0188815929, -0.0552617013, -0.0265120510, 0.0358206481, -0.0633661896, 0.0967667475, -0.0703569502, 0.1902284175, 0.0444309860, 0.1069621667, -0.1828366667, -0.0060823443, -0.0384960100, -0.1118217558, -0.0621169284, 0.0163363777, 0.1424013674, 0.0154427774, 0.0357071199, -0.0229300745, 0.0135999667, -0.1139563322, -0.0139725544, 0.0890640542, -0.1100609824, -0.0362581164, 0.0838909075, -0.0774097294, -0.0550415479, 0.0374802686, -0.0193251353, -0.0892342404, 0.1010099351, -0.0300277174, -0.0225524120, 0.1074267998, 0.0386290029, -0.0068440400, 0.0318674743, 0.1519335806, 0.1256115884, -0.0885683745, -0.1064267382, -0.0352739096, -0.0134769510, -0.2320854515, -0.0061348951, -0.0327629000, -0.0710218847, -0.0896654204, -0.1270806193, 0.0365780592, -0.1106664315, -0.1288506985, 0.1867535859, -0.0399186872, -0.0967250764, -0.0067140418, -0.0177270640, -0.0049319621, 0.1445839256, 0.0569494180, -0.1362343132, -0.0737623274, -0.2723472714, 0.0794910640, -0.0278289039, -0.0559664145, 0.0337942690, 0.0490557067, -0.2547174692, 0.0584872440, 0.1006284133, 0.0464531854, -0.0320046619, 0.0995495394, -0.0004875216, 0.0197318047, 0.1201109216, -0.0670005828, 0.0099321883, -0.0472950228, 0.0496485531, -0.0153689422, 0.3545377553, 0.0023434677, 0.0190207791, -0.0269412622, 0.0570117123, 0.1427648813, 0.0256819185, -0.0346684158, 0.1272182763, -0.0014891922, -0.1001670063, -0.1083180010, 0.1114897728, -0.0645799339, -0.0653085411, 0.1095568836, -0.0442607701, 0.0915067419, -0.0671451390, -0.0538268387, 0.0751516521, 0.0543665588, 0.0710722879, -0.1118375286, -0.1075317264, -0.1092148945, 0.0687248185, 0.0351637341, -0.0120786130, -0.0811304227, 0.0714264289, -0.0013876557, -0.1017958894, -0.0006036762, 0.0634547099, 0.0438424051, 0.0175637603, -0.0210834444, -0.0184156355, -0.0899194553, -0.0657394230, 0.1014435887, -0.0436026454, -0.0039100051, 0.0597838238, 0.1107559204, -0.1229348481, 0.1228092015, -0.0937469602, 0.0776872858, -0.0445965528, 0.0962954164, -0.0060909092, -0.1004885435, -0.1267674416, -0.0079632690, 0.0733532980, 0.0128453374, 0.0160631612, -0.0929480791, 0.1159599498, 0.0809434652, 0.0042433441, -0.0098772058, -0.0193301067, -0.1279385090, -0.0160794258, -0.1026724279, 0.1194316968, 0.0503531210, 0.0984368995, 0.0918496028, 0.1297988445, -0.0590869486, 0.1189982295, 0.0845656991, -0.1286796629, -0.0859522894, 0.0362462476, -0.1240349412, 0.1093826294, -0.0756529272, -0.0114201903, -0.1026047841, 0.1143200696, 0.0477413833, 0.0214573145, 0.0165926088, 0.0886242688, 0.0455690622, 0.0890796110, -0.0873930454, 0.0502288043, 0.0905420408, 0.0662600994, 0.0193858966, 0.0649206340, 0.0338578485, -0.0362285674, -0.0702291727, -0.0389474034, -0.0139411092, 0.0860503986, 0.0665031075, 0.0491702072, 0.1047620177, 0.0698293820, -0.0911298171, -0.0855946541, 0.1049605608, 0.0508678034, -0.0073221605, 0.0586987250, -0.0286131501, 0.0641960427, -0.0591221750, 0.0270033479, 0.1058571935, -0.1139468253, 0.0215045810, -0.0941867903, 0.0953018367, -0.0412738025, -0.1037308499, -0.1007876620, 0.0106445849, 0.0893603563, -0.0845606104, -0.0570338629, 0.1003496945, -0.0985096022, 0.0450271070, 0.1127988026, -0.1115165576, 0.0270524286, -0.0755009875, -0.0755637065, -0.0864120498, -0.0413588211, 0.0009596944, -0.0413649380, 0.0369492993, -0.0063688927, 0.0894422457, -0.1177800372, -0.0427690148, -0.0593052171, -0.0501976721, 0.0103869336, -0.0829529762, -0.0912923515, 0.0001798570, 0.1128029749, -0.0744436756, 0.0011072159, 0.0749792159, 0.0864484832, 0.0010172129, -0.0558197238, 0.0607590415, -0.0630471781, -0.0146087315, -0.0353594124, -0.0884489417, 0.0812129304, 0.0124784689, -0.0390255973, -0.0541750565, -0.0959679484, 0.0411214828, 0.0443989746, 0.0070655048, -0.0816328451, -0.0908195153, -0.0108672380, 0.0727588534, -0.0662948266, -0.1177701876, -0.0555555522, -0.0956611037, 0.1112333462, 0.0829443336, -0.0316387042, 0.0727250353, 0.0161136687, 0.1175011620, 0.0257080793, -0.0140291732, -0.0323237181, -0.0576012768, -0.0444076024, -0.1034626588, 0.0280797184, -0.0052858591, 0.0079392791, 0.0240314156, 0.0569313876, 0.0063199410, -0.1108992398, 0.0872599483, 0.0530374646, -0.0048671383, -0.0475976467, 0.0717592537, 0.0872194767, -0.0061534741, 0.1218788624, 0.0841197968, -0.0476490855, 0.0638012737, -0.0897345021, 0.0091473665, 0.1248767078, 0.0960315540, 0.0699509084, -0.0181049947, -0.0067027817, 0.1078931689, 0.0953606963, -0.0640219450, -0.0739704967, -0.1008599699, 0.0598849952, 0.1025564894, -0.1059403345, 0.0818075836, 0.0213070177, -0.0331984460, 0.0799244568, -0.1064720154, 0.0229494274, -0.0491645932, 0.0397376120, 0.0519415699, -0.0589649975, -0.0707478523, -0.0451246798, -0.1138371527, 0.1120589674, -0.0298548937, -0.0843861103, 0.0890134200, -0.0948064625, -0.0914793238, 0.1280759275, 0.0513754487, 0.0962256193, -0.0473589487, -0.1103538796, -0.1163781211, -0.1082536578, 0.0221923348, 0.0119354157, -0.0918043926, 0.0868583024, 0.0302153826, -0.1103306711, 0.0367405191, 0.1150497794, -0.1214538515, -0.0592108779, -0.0407119095, -0.0968567431, 0.0154309571, 0.0946075618, -0.1541098803, 0.0275177527, 0.1155774593, 0.0373891816, 0.0115491552, 0.0373740867, 0.1070594415, -0.0470086671, -0.0189391151, 0.0600401275, 0.0476036482, 0.1357034892, -0.0007726962, 0.0835860372, -0.0589095466, 0.0735952482, -0.1447494924, -0.0373746902, 0.0118785109, -0.1898830384, -0.0922639370, 0.1215176731, 0.1937662512, -0.1113137379, -0.0028849498, -0.0172812305, 0.0271542110, -0.1342980415, -0.0474285930, -0.1018104777, -0.0390190631, 0.0238239653, -0.0933669433, 0.0242797602, -0.0186486617, -0.0013025735, -0.0419229008, 0.1404806972, -0.0896526128, 0.0296661649, -0.1706271321, -0.0332854539, 0.1504401714, 0.1511964649, 0.0586428344, 0.1164822280, -0.0065369084, -0.0185041111, -0.0748110637, 0.0958142206, 0.1548168957, -0.1140624136, -0.1272044629, -0.0711518377, 0.1355485171, 0.0036264302, -0.0623798184, 0.0030656299, 0.1062649339, -0.0580018647, 0.1179462299, -0.1288783252, 0.1219677255, -0.0640587136, -0.0570732951, -0.1308709383, -0.1584600359, 0.1076285094, -0.0829322785, 0.0536741018, 0.0911854729, 0.0836649835, -0.0638574362, -0.2675695717, 0.0933466181, -0.1298876256, 0.0756706595, -0.0735247880, 0.0142145827, -0.0787791312, 0.0355455838, -0.1896055043, 0.1086564958, -0.0727459863, 0.1855623126, -0.0243089199, -0.0172303673, -0.2402295321, 0.0999256968, 0.2209295779, -0.0458958074, 0.0030565173, -0.0045515196, 0.0259680524, -0.0405488312, 0.0569685027, -0.1569038928, 0.0619563311, -0.0114064766, -0.0800703764, -0.2339922190, 0.0050746496, -0.0947910249, 0.0902386680, -0.1587792039, -0.0088529540, -0.0629321709, -0.0675726607, 0.0961978212, -0.0850617066, -0.0099718785, 0.0425026044, 0.0745083690, 0.0039165281, 0.0132332770, -0.0907012373, 0.0286637899, 0.1156398728, -0.1393690407, -0.1023590639, 0.0948452652, -0.2571826875, 0.2103455216, 0.1018055305, 0.3088893294, -0.1130054891, 0.0719845816, 0.1464847326, -0.0454343148, -0.0499380827, -0.1057352573, 0.1013662219, 0.0119100688, -0.1399973035, -0.0514674075, -0.0136967637, -0.0778938904, -0.0961015373, 0.0603515692, 0.0064192601, 0.0271596611, -0.0341997482, -0.0091733364, 0.0536777563, 0.0339561515, -0.0922833085, -0.0646377280, -0.0214250851, 0.0853826851, -0.1297665685, -0.1106080860, -0.0508036464, 0.0565982945, -0.0502537675, 0.1694910675, 0.1360081285, -0.0353120081, -0.0150298849, 0.0652344897, -0.1042160094, -0.1147097796, -0.0321153328, -0.0577679835, -0.0761666447, 0.0015651813, -0.0910034850, -0.2146496922, 0.1311514229, 0.0129970303, 0.0401903875, 0.0246140659, -0.0148378517, -0.1671836823, 0.0374198556, -0.0426715985, -0.0245792940, -0.0449866168, -0.0996110514, 0.0801173002, 0.3861846626, -0.1193185449, -0.0973744318, 0.0579633750, -0.1055465490, 0.0135153001, 0.0576342680, -0.0113564776, -0.0154268891, 0.0474435464, -0.0867614895, 0.0255649686, -0.0454315655, 0.0490166992, -0.0343319215, -0.0660800934, 0.0402021632, -0.1104646996, 0.0506180376, -0.1151662841, -0.0469216034, 0.0643751174, 0.0949161276, 0.1867099404, -0.0580963045, 0.1777919233, -0.1083678380, 0.0478640422, -0.0790358856, -0.1730414629, -0.1288550645, -0.0748097673, -0.0738617331, -0.2408724129, -0.0012072569, -0.0258997418, -0.1337761283, -0.1296761185, 0.0931375921, 0.0777461529, -0.0990570039, -0.0068308655, 0.1482399404, -0.0973381624, 0.0819471329, -0.0791961923, -0.0455538705, -0.0770497546, -0.1102123782, -0.0332705453, -0.0284019671, 0.1238083020, -0.1205419078, -0.0517846346, 0.0406025983, -0.0188636333, 0.0280135758, -0.0137423389, 0.2751964033, -0.0902146995, -0.0994991139, 0.0644991919, 0.3556020856, 0.0932828784, 0.0555677749, -0.0326851644, 0.1508985758, 0.0471912920, -0.2516345978, 0.0885545611, -0.1016441584, -0.1344753206, -0.0389032252, 0.0731696561, -0.1380657405, 0.0455603339, -0.0668462515, 0.0508793406, 0.0248528719, -0.1118743122, 0.0472569466, -0.0987290442, -0.0475725532, -0.1166081131, 0.0377840474, 0.0467145331, -0.0502239652, -0.0461782515, -0.0619329624, 0.0115456581, 0.0403708033, -0.0637911037, -0.1016075090, -0.0867663100, 0.0533512235, 0.1219567657, -0.0893280804, 0.1060546339, 0.1162791476, -0.0168515742, -0.0125358552, -0.0452333689, -0.0233826339, -0.0576244295, -0.1125362217, -0.0031257549, -0.0382574461, -0.1111041307, 0.1088392064, -0.0847061947, 0.1238708794, 0.0478814021, 0.0582318604, 0.0188669860, 0.1103834212, -0.0994545743, -0.0603598729, -0.0340973139, -0.0925927833, -0.0430272520, -0.0603766441, 0.0709086955, -0.0313711464, 0.1285698116, 0.0536702685, 0.1004828513, -0.0157094896, 0.0558728091, -0.0166539550, -0.0637719110, 0.0562071018, -0.0483848453, -0.0848193839, 0.0831524134, -0.1177721620, -0.0335903168, 0.0381577313, 0.0990459621, 0.0466188155, -0.1128046587, -0.0205457229, 0.0382696986, 0.0595254004, -0.0589501224, 0.0022582412, 0.0042279977, -0.1256012768, -0.0538825877, -0.0232649446, -0.0842248499, 0.0157685876, -0.0123033822, 0.0805039406, -0.0625497997, 0.0192608535, 0.1003822610, -0.0698088706, -0.0921291038, -0.1059389114, 0.0902739167, 0.0945836678, -0.0046418007, 0.0588756800, 0.0334071368, 0.1190090179, -0.0879580155, -0.1244336367, 0.0409970060, 0.1152702570, -0.0377972722, -0.0597958900, 0.1186397374, -0.1232482493, 0.0118025541, -0.0909405947, -0.0370269082, -0.0220776796, -0.0734689608, -0.0731462017, -0.0032816827, 0.0263542477, -0.0525410771, -0.1296570450, 0.0975573659, 0.0612414181, -0.0851582363, -0.1055797040, -0.1298929900, -0.0137330294, -0.0557966232, 0.0017611078, 0.0438179485, 0.0508852899, 0.0733117461, 0.0484746695, 0.1005479097, 0.0002577901, -0.0977695584, 0.0899121165, -0.0677075088, 0.1006919146, -0.0200810134, 0.0858857855, 0.0336721838, 0.0985238850, -0.1232884452, -0.0956709012, -0.1183628440, -0.0955004394, -0.0359164067, -0.0301813073, -0.0206019972, -0.0401742905, -0.1105721891, -0.1183096170, -0.1015561894, 0.0738573447, -0.0436846204, 0.0172750354, -0.0456224084, 0.0712180436, 0.0571867153, 0.0946949720, 0.0386252403, -0.0700136051, 0.0750884414, 0.0799816772, 0.1036635116, -0.1134064496, -0.0421192795, -0.0060040355, 0.0980180800, -0.1080233455, -0.0392976403, 0.0619004667, 0.0042045745, -0.0758785009, -0.0309282839, 0.1062426642, -0.0573045760, 0.1256849319, 0.1045981050, -0.0229865368, 0.0659471750, 0.0649291351, -0.0852655843, -0.1072407141, -0.0313352048, 0.1181898415, -0.0393739641, -0.0167261716, 0.1301116496, -0.0870469287, -0.0392348170, 0.0310890377, 0.0670002475, -0.1008877307, -0.0500310846, -0.0134141743, -0.0413849652, -0.0186419189, -0.0182769001, -0.1050601304, 0.0093109310, -0.0744915605, 0.0624760091, 0.0933215320, 0.1045866311, -0.0611864626, 0.1026582345, -0.0333407521, -0.1178688109, 0.0152493715, 0.0273653604, 0.0873708650, 0.0245050192, -0.0868197680, -0.1075062454, 0.0791151226, 0.0062897801, -0.1305302829, 0.0157065094, 0.0382623076, -0.1112052500, 0.1136205122, 0.0235486850, -0.0194051806, 0.0209970511, 0.0408580638, 0.0032382940, -0.0694424510, -0.0388781168, -0.0330889523, 0.0106461048, 0.1276728511, 0.0894635618, 0.0036614239, 0.0929646790, -0.0356564857, 0.0209161080, -0.0829623267, -0.1165513471, 0.1030841768, 0.0541411042, 0.1108461320, -0.0927448273, -0.1062405407, -0.0581088588, -0.1141088307, 0.1054524183, 0.1103755236, 0.1053740680, 0.0378856063, 0.0003595921, 0.0573303699, 0.0440682247, 0.0344232321, -0.0188088957, 0.1202537790, 0.0483599603, -0.1052826345, -0.0571441352, -0.0997340381, 0.0493503511, 0.0275856555, -0.1111216247, -0.0145444572, -0.1121890619, 0.0282243825, 0.0585595667, 0.0734346509, 0.0186803639, 0.2458732128, -0.0805617496, -0.3756659925, -0.2872174680, -0.0739563033, 0.0493617579, -0.0022728252, -0.4206351638, -0.0909249932, -0.0424400866, -0.2411525697, -0.0548384264, 0.6440597177, -0.0992436334, -0.1359424740, -0.2393006831, -0.2813414335, -0.0258900244, -0.1111031249, -0.0348142907, 0.0261937454, -0.0053592436, -0.0535586812, -0.1796516329, 0.0069714892, -0.5883961320, 0.0149028655, -0.1933990866, -0.1056813374, -0.5619317293, 0.0599789061, -0.4933455586, 0.0215309840, 0.2428878099, 0.0442648567, -0.0391561277, 0.0544007644, 0.1365958452, -0.2279429883, 0.0607308149, 0.0253952108, 0.1484504193, -0.1118419990, -0.0882015973, 0.2251844108, -0.5370378494, 0.1716787964, 0.0759186149, -0.1065632775, -0.1103539094, 0.1020670310, -0.5193789005, 0.1552223265, 0.0353741162, 0.3646765649, -0.2661373317, 0.2067324072, -0.6030339599, -0.2320722491, 0.4911475182, -0.6610352993, 0.0133659979, -0.1369215697, 0.1416324228, -0.0910818726, -0.1500814706, -0.0075329621, -0.7853901982, -0.1065212414, -0.0290393811, 0.0260775406, -1.1767425537, -0.1276083440, 0.7564082146, 0.0588924438, -0.1811891049, -0.0604045764, -0.0309320912, -0.0530564934, 0.0511404201, -0.0077809123, 0.0524319634, -1.4177913666, -0.0003653771, -0.0968544632, -0.2020431459, 0.0043759798, 0.0676002651, -0.0273645949, -0.0463417582, 0.3567185104, -0.0244828276, 0.0704662129, -0.0945549682, 0.1446856856, 0.0662746355, -0.7240762711, -0.3768725693, -0.1078506857, -0.0134140309, -0.1698189676, -0.0107910177, 0.1692838669, 0.0202444457, -0.0634937510, -0.2598528266, -0.0047290730, 0.0470847040, 0.1939377636, 0.3830975890, -0.0805694684, -0.1717918962, -0.9155140519, -0.0961814523, -0.3104798198, 0.1869267821, -0.2499556094, 0.2585050762, -0.0462046303, -1.0015888214, 0.5691066980, 0.0354382209, -0.5489549637, -0.6510072351, -0.0928436071, -0.2551439703, -0.2273862213, -0.0467295274, 0.0446926355, -0.1052557155, -0.6918732524, 0.2672229707, -0.3775711954, -0.0121220648, 0.1137738228, 0.2771286964, -0.0165155195, -0.0029306614, -0.6383996606, -0.7423085570, -0.0798848718, 0.0947441831, 0.0302409567, 0.0362322628, -1.2232877016, -0.0350902714, -0.0615964383, -0.1819559187, -0.0030442430, -0.0837765634, -0.0755037218, 0.7912708521, -1.2251216173, 0.4280024767, -0.0172832571, -0.0887140930, -1.8586618900, -0.0323823765, -0.6719766855, 0.0025273599, 0.0323079303, 0.0880956948, 0.8349310756, 0.0501962714, 0.0176639371, -0.0686750710, -0.0267225411, 0.1196266115, -0.0830312893, -0.0445705168, -0.0879989713, 0.2103068233, -0.2177617848, 0.1594690084, 0.0859944001, 0.4548374414, 0.0498102345, 0.0091735674, -0.0481737964, 0.0903207213, -1.0936641693, -0.0663354248, -0.0331711397, 0.0013624206, 0.1188186631, -0.1615222991, -0.1822893322, -0.0544811115, -1.6340488195, -0.2694338858, -0.0293716043, 0.0264343321, -0.0199881271, 0.4278637469, -0.4706893563, -0.3550266922, 0.3029966056, -0.3920555115, 0.1728352755, 0.0523206033, 0.0525171421, -0.0698622540, -0.4184876978, -0.3899037242, 0.0405053049, -1.4989060163, 0.8563318849, -0.0488165766, -0.0612318739, 0.4429075420, -0.0061869137, -0.1372357458, -0.0922927335, -0.6479600072, 0.0247427113, -0.1916313916, -0.0927187949, -0.6708531976, -0.3936920464, 0.0836026818, -0.0991185457, -0.3370286822, -0.6823558211, -0.0100607118, 0.0047778315, -0.2537653148, -0.1080633998, -0.3753995597, -0.0180522893, 0.0223091375, -0.0383845642, -0.0208269469, 0.0373158343, 0.3213469684, -0.9828348160, 0.0024349804, 0.0063431920, 0.0108686583, 0.5880234241, 0.4261699915, -0.3825857937, 0.0263179224, -0.5159500837, -0.1909809262, -0.0585946143, 0.0522692725, 0.7946408987, 0.0303950682, 0.4341131449, -0.0659699067, -0.0694117323, -0.0191584881, -0.1486621499, -0.4642776251, -0.2934284508, -0.5681808591, -0.2285586745, -0.1281159669, -0.0808806121, -0.2544734478, 0.0345202312, -0.2909807265, 0.0092294542, 0.1066433713, -0.0251385663, -0.0507981144, -0.0313373990, -0.0247682370, 0.1150289327, -0.0636234209, -0.0655817464, 0.2623868883, -0.0850948766, 0.0334874913, -0.0610210449, -0.0307392776, -0.1904985458, 0.0603559241, -0.4254861176, -0.5059244633, -0.0081659090, -0.3401373029, 0.0008901749, 0.0132088121, -0.1559422314, -0.2797453403, -0.1090592593, -0.2847281694, -0.1856703013, -0.3241534829, -0.0216663666, -0.1594817787, -0.0013790255, 0.2033611685, 0.0564493574, -0.0721501261, -0.0369484052, -0.1268930584, 0.1592522115, -0.0526691638, -0.2135470361, 0.0083452919, -0.4375520051, -0.0594914630, -0.1988943964, -0.0833733678, -0.1259969324, -0.0580328740, 0.1301795989, -0.0400909856, -0.3465171456, -0.1870375127, 0.1907129735, -0.2988519371, -0.4950747490, 0.1587949842, -0.2683748603, -0.0000181440, 0.0160889290, 0.2777242362, -0.0249852967, -0.0458118618, 0.0075025992, 0.0053688483, -0.0967478454, -0.1214570031, 0.0300251748, 0.0977335647, -0.0501437895, 0.0844769627, -0.5132899284, -0.2929826677, -0.0745307580, -0.1267976016, -0.0645871088, -0.0268064551, -0.0946197137, 0.0193258952, -0.2885751724, 0.0623263046, 0.0755135790, -0.1011824012, -0.0424460620, -0.1422682852, -0.2809437811, -0.0540736765, 0.1383603066, -0.0374229923, -0.0865410417, -0.0903801024, -0.1459417939, 0.0513454042, -0.3775693774, -0.8171349764, -0.1352520436, -0.0330178142, 0.0158620235, 0.0680007115, -0.1287064105, -0.5607295632, -0.0428660512, 0.0979742557, 0.0289304145, -0.1163161397, -0.0496353917, 0.0935986117, -0.0560299754, 0.0555525683, -0.2440766841, -0.1887892336, -0.1527904719, -0.0250514913, -0.0276976731, -0.0176607799, -0.1210985705, 0.0737513453, -0.3738361895, -0.1446855068, 0.2026879191, -0.3764306307, -0.0269682929, -0.2134677619, 0.0195796099, -0.0436217450, -0.0224971417, -0.0335018225, 0.2062048912, 0.0831274092, -0.2344521284, -0.0351264775, 0.2049611956, 0.0502051488, -0.0189463571, -0.0787175745, -0.0030449419, -0.1141748205, -0.0259957016, 0.0939686075, -0.2543362975, 0.0056080390, -0.2074036151, -0.1784890741, -0.0226029605, -0.0630307868, 0.0084846774, -0.1190362796, -0.0770695508, 0.1355870515, -0.3151207268, -0.0780468211, -0.1567573100, 0.0206769872, 0.1030557826, -0.0569321960, 0.0102033354, -0.0409065932, -0.0461043157, -0.0432653427, -0.4714029133, 0.0305332765, 0.2242118269, -0.1310577393, 0.0037570209, -0.1807495952, -0.3279884458, 0.0049175196, -0.1540701389, -0.5238772631, -0.0403743573, -0.0056417692, 0.0966965854, -0.4047060907, -0.0371737108, -0.1632061750, -0.0510155559, 0.2553860545, -0.3689938486, -0.0316569284, -0.1843533665, 0.0038046497, -0.1249840483, -0.0393511169, -0.0971451402, -0.1301324964, 0.1503292471, -0.0748964623, 0.0007221309, -0.0961430222, -0.0736216828, -0.2574692965, -0.2132176459, 0.0381950550, 0.1070926115, 0.0249484591, -0.2101662010, -0.1646732986, -0.1536384523, -0.0696339905, -0.0176193640, -0.0936035365, 0.1559015512, -0.1230553687, -0.0954199657, -0.0942188576, -0.0626805201, -0.0466810465, 0.1999241710, -0.1080348343, -0.0582228787, 0.0268558897, -0.0891157091, -0.2682596147, -0.0569118895, -0.1103735790, 0.0061965352, -0.0012355665, -0.0315400138, -0.1200785935, 0.1316350549, 0.3363710046, 0.0094437916, -0.5824211240, -0.1533786356, -0.1308745891, -0.5815171599, -0.0739289373, 0.0181184411, -0.1085383445, -0.2423480451, -0.1960175484, -0.3042115569, -0.0795576721, -0.0165298562, 0.0743321180, -0.1801005453, -0.1693187654, -0.1922419071, 0.0703455284, -0.0743390545, -0.0706421360, -0.0914282277, -0.0733272508, -0.2310637385, -0.0551322810, -0.1240295470, -0.0170643609, -0.0279716719, 0.0188894495, -0.1139979064, -0.2154187709, -0.5546743274, -0.1112602726, 0.3507083356, -0.0634854957, 0.9064953327, -0.0357354432, 0.0800346881, -0.6085051894, -0.0047603212, 0.8049243093, -0.1950260401, -0.0174666103, 0.1110505909, -0.0049777855, -1.9304457903, 0.1091403663, 0.0006246627, -0.0417389944, -0.1490858346, -0.0290078670, -0.1081933826, -0.2359654754, -0.2086566687, -1.3040145636, -0.0583352000, -0.2317677736, -0.0055554006, -0.3100813031, -0.0973946229, -0.0576496534, 0.0587031543, 0.3728552461, -0.1791329682, -0.3387354910, -0.2677394748, -1.0153050423, 0.0804524347, 0.2072363496, 0.0418772995, 0.4584180713, -0.0707031116, -0.0464102253, -0.0373721980, 0.1907262951, -0.0455350056, -0.0793066770, -0.8326714039, 0.0114276772, 0.3221020699, -0.0429976434, -0.1091039479, -0.1734705120, 0.0232388768, -0.2439173460, 0.9638820291, -0.1197598875, -1.4193881750, 0.2360823601, -3.0218338966, 0.5340731144, -0.0906296298, 0.4159850478, -0.5552859306, -0.0538694598, -0.2777796090, -0.0319582857, 0.0039900518, 0.0133522823, -0.0091238925, 0.5880945325, -0.1165349633, 0.1337991804, -0.2942905426, 0.4072741270, -0.0916020870, 0.3271140754, -0.1183497682, 0.1695353687, 0.3135107458, -0.0146582378, -0.0620609671, -0.2160461694, -0.1012447774, -0.2568884790, -0.8276977539, -0.4350374043, -0.0111255199, 0.0726814345, 0.0208508670, 0.2352796644, -2.3019216061, -0.0538039468, -0.1949455142, 0.0086452169, -0.0748193264, -0.0961420313, 0.2932643890, -0.0893574581, -2.8553664684, 0.3883695900, 0.0134089226, -0.0044196420, 0.0032558381, -0.0271942839, -0.2117434293, -0.4663861394, -0.2126258016, -0.3259137273, -0.0002660765, 0.0579627827, -0.3321746290, -0.3522668779, 0.0512675047, -0.0733971223, 0.2135290205, 0.0792531073, -0.2042797208, -0.0784197152, -1.0378136635, 0.0073958067, -0.0645967573, -0.5356145501, -3.0864989758, 0.0413903929, 0.0907910764, 0.0867021605, 0.0034668194, 0.2787893713, -0.1349988133, 0.0082519967, -0.2420035750, 0.0959766954, -0.3647529781, -0.7754611373, -0.0402535424, -0.2332208306, -0.2426744998, -0.1094576493, -0.0977836996, 0.1327355802, -0.1254147291, -0.1242453977, -0.0230003614, -0.0092480155, -0.2782790065, -0.2901885509, -0.3159431815, 0.0907320231, -0.1152882650, -0.0795399919, 0.0196511187, 0.0391267538, -0.2869550288, -0.4493683279, -0.7426943779, -0.4863192141, -0.3311031461, 0.0298520122, -0.3900407851, -0.0139985410, 0.0165028796, -0.0352238044, -0.0027318299, 0.0224471502, -0.2928096354, -1.1012685299, 0.0661339462, -0.1001422927, -0.0272692479, -0.0935523435, 0.2269630879, -0.0699155927, -0.2033720911, 0.3276423812, -0.0628847107, -0.9299703836, 0.0110729933, -0.5545550585, -0.0993327349, 0.0454426035, 0.0977972746, 0.2035390437, -0.2321615517, -0.0646351948, 1.0799809694, -0.1195729375, -0.0589937270, -0.0694542229, -0.0316643752, -0.0242391787, -0.1592081040, -0.2404569685, -0.0007378604, -0.0643330812, -0.0748628080, 0.1209656373, -0.2171752006, -0.9718654156, -0.4072754681, -0.2455340773, -1.2878512144, -0.0212996006, 0.0872838199, -0.2207150012, 0.3770808578, 0.0368092097, -0.3120241463, -0.5847309232, -0.7232880592, -0.0174587723, -0.0520469956, -0.0668769330, -0.3106467724, -0.2604416311, -0.1061178967, 0.8611118793, -0.0929406285, -0.1403419077, -0.0385960564, -0.9489072561, -0.8764565587, 0.0847547054, -0.1323168576, -1.0134335756, 0.7502762079, -0.0282433424, 0.0592641793, -0.3436597288, 0.0947665423, 0.9545854926, -0.6535566449, -0.0314905643, 0.0074439608, -0.0087905042, 0.0499242432, 0.6122336388, 0.3638379574, 0.0037269096, -0.0784021020, 0.0003100845, -1.1753966808, -0.1564803123, -0.7824890614, 0.1265498400, -0.1037051827, 0.1169800535, 0.0154416682, -0.1106479615, -0.0763652623, -0.0585562177, -0.0998460799, -0.0844351947, -0.0630216673, -0.2696370482, -0.0717481673, -0.2543438077, -0.1786501408, 0.0127471667, 0.0619556904, -0.0603629164, 0.0279633701, -0.0849367976, -0.1003938317, -0.0366009474, -0.0565034524, 0.0102861524, -0.0793073997, -0.0283266027, -0.0658995509, 0.0228252802, -0.1002130806, 0.0645587742, 0.0980456397, -0.1039909944, -0.0793247744, -0.1044978201, -0.0403206386, -0.0999966040, 0.0830132067, 0.0638341233, 0.0164402947, -0.0461876094, 0.0896244720, 0.1159715280, -0.0270240996, 0.0715581477, -0.0275125504, 0.0456317663, -0.0470988378, 0.0214724280, 0.0642961562, 0.0359315872, 0.0239048898, -0.0818493515, 0.0335537419, -0.1085212231, -0.0508117974, 0.0685245693, -0.0480700321, 0.0414765328, -0.0449876189, -0.0988169536, 0.1161666214, -0.0508054085, -0.0921344534, 0.0612380914, 0.1237922236, 0.1046095490, 0.0246538687, -0.0482622273, -0.0971085876, 0.0732050836, 0.0034452379, 0.0535958707, 0.0692431405, 0.0145263607, 0.0190122426, -0.0045194328, 0.0219994821, 0.0230965372, 0.0764475092, 0.1199004054, 0.0595719144, 0.0361194611, 0.0950722992, -0.1092411056, -0.1127549559, -0.1219786629, -0.0369708426, -0.1091071069, -0.1151541173, -0.0894886851, -0.0719861090, -0.0991122052, -0.0246897638, 0.0809734464, -0.0677259266, -0.0029788218, 0.0767432153, -0.0478329957, 0.0173746385, -0.0206005685, 0.1062336862, 0.0651214942, -0.0664440095, -0.1279236078, 0.0119505823, 0.0202785414, 0.0378117748, 0.0012517982, -0.0087457299, -0.0667916238, 0.0782097653, 0.0533694327, 0.1062923446, 0.0064551234, -0.0017794335, -0.0799743533, -0.0651878715, 0.1187792122, -0.0601809695, -0.0344523266, -0.0846021250, -0.0879864395, -0.0012609853, 0.0658397377, 0.0069741607, -0.0007475395, -0.0864290595, 0.0531362593, 0.1151382849, 0.0861922204, -0.1151197106, 0.0886893049, 0.1257934570, 0.0802816823, -0.0899892151, -0.0062482744, -0.1033837870, -0.0842424631, 0.0185292419, -0.0837975144, -0.0340773501, 0.0258639138, -0.0336411893, -0.0149864228, 0.0312598087, -0.0509579070, -0.0658606440, 0.0566157512, 0.0473726988, -0.0253383536, -0.0280030780, -0.1164956167, -0.0363079421, -0.0522659719, -0.0545539856, 0.0544838347, -0.0015136601, 0.1235541925, 0.0670651495, -0.0217972528, -0.0308982041, -0.0197217129, -0.0887316465, -0.1159422398, -0.1189889833, 0.0992655456, -0.0800041556, -0.0341964364, 0.0314896703, -0.0004301095, -0.0211407244, -0.0111691952, 0.0414272845, 0.1136561856, 0.0431442857, 0.0205668937, 0.0040949583, -0.0834537148, -0.0660896897, -0.1034010351, -0.0000646956, -0.0886308327, 0.1294717491, -0.0782146454, -0.0469175912, -0.1174795255, -0.0823643431, -0.0212613903, 0.0204801522, 0.0151670575, 0.1061669514, -0.1055460498, 0.0119660255, -0.0150105683, -0.0574913621, 0.0953949317, 0.0581004322, -0.0474835373, 0.0330200270, -0.0720219612, 0.1063281596, -0.0114249587, 0.0930761993, -0.1093904004, -0.0004310649, 0.1120921820, 0.0237957537, -0.0786314607, -0.0816927850, -0.0663535893, 0.0974618196, -0.0299763475, -0.0947189853, -0.0604451634, -0.1001169682, -0.0381832421, 0.0445290506, -0.1068569124, -0.0641109496, 0.0243568178, 0.0430575907, 0.0315956846, 0.0922091305, 0.0635520741, -0.0933542997, 0.1129716039, -0.0306434426, -0.1057031080, -0.0640912950, 0.0674576461, 0.1196494401, 0.0234138705, -0.0262719784, 0.0034705698, 0.0246750768, 0.0291017294, 0.0735590085, -0.0383995175, -0.1043487564, -0.0051847785, -0.0811234638, -0.0497014932, -0.0643304586, -0.0954465270, 0.0857468843, -0.0517060459, -0.1063750684, 0.0604095459, 0.0866461396, 0.0049041500, 0.0696570575, -0.0333360657, -0.0867254063, 0.0633607507, -0.1216592193, -0.0566385277, -0.0327851772, -0.1058976501, -0.1249743104, -0.0389871523, -0.0681318715, 0.0005018375, -0.1055773348, 0.0217375755, -0.0182811320, 0.0386517644, 0.0800475106, 0.0173777211, 0.0565567017, 0.0025135577, -0.0601643920, -0.0517286062, 0.0042564170, -0.0702572539, 0.0741169453, 0.0180699285, -0.0894093812, -0.0692687929, 0.0914143920, -0.0737958327, 0.0290200934, -0.0134243919, -0.0131145818, -0.0267756265, -0.0042800386, -0.1503247470, 0.0796733573, 0.0049857171, 0.0188636184, 0.0488048643, -0.1162002236, 0.0706968457, -0.1411702335, 0.0664142817, -0.0214258973, 0.1035619378, -0.0865927637, 0.0174555089, -0.1249592304, 0.0895501301, -0.0479385257, -0.0231953058, 0.1056643724, 0.0390649512, -0.1279412657, 0.0393808037, 0.0004312470, 0.0821339563, 0.0574349314, 0.0924656093, 0.0534099042, -0.1218123063, 0.0347033888, 0.0581043959, 0.1249108762, 0.0568978675, -0.0818260312, -0.1538899839, -0.0164111089, -0.0302739926, 0.0774780363, 0.0507292710, 0.0524496697, -0.1483239383, 0.0031556466, -0.1321793497, 0.0255474932, -0.1458304822, 0.1043895781, 0.0046204743, -0.0662728101, -0.0876951739, 0.0442787372, -0.0066021471, 0.0927997008, 0.0953147188, 0.0250837989, -0.0638922527, 0.0075236806, -0.0327672549, -0.0507290252, 0.1026817337, 0.0064537451, 0.0555072241, -0.1563822925, -0.0559477806, -0.2082520872, -0.0300169103, -0.1301465780, -0.1192914471, 0.0885462612, -0.0995397344, 0.0865626633, 0.1535572857, -0.0841718912, -0.1284509897, 0.1063927189, -0.1014533937, 0.0003796314, -0.0433629602, -0.0617274381, -0.1495315582, 0.0643971935, 0.1148704588, 0.0354890861, -0.0464567170, 0.0018269259, -0.0270002820, -0.0843998566, -0.0052624405, -0.0039657564, -0.0190205351, -0.0263413228, -0.0169944968, 0.0339459591, -0.1218106821, 0.0189235639, -0.0276992824, 0.0580254085, -0.0457842834, 0.0234517977, -0.0599864237, 0.1023278162, 0.0820820108, 0.2095712274, -0.1674169451, -0.0309508536, 0.0792330131, -0.0918828323, -0.0343531594, -0.1286400855, -0.1232119501, -0.1213556081, -0.1542969197, 0.0913391635, -0.1490941346, 0.1219361275, -0.0288480185, -0.0898898691, -0.0411501601, 0.0503822640, 0.0649385378, 0.0579895079, 0.0668802634, -0.1250398606, 0.0388635024, 0.0155369854, 0.0495456681, 0.0544866398, -0.0804711953, -0.0174970273, -0.0284223855, -0.1248252466, -0.0983158946, -0.0924032107, 0.0496119671, 0.0857140347, 0.0915726125, -0.0203313939, -0.1074931026, 0.0819064006, 0.0277683921, 0.0983929485, 0.1135109961, -0.0016029021, -0.0858557969, -0.1486821771, -0.0682330206, -0.0404632501, 0.0623511747, -0.0172049459, 0.1089531779, -0.0817514285, -0.0629057884, -0.0170567352, -0.0088673057, -0.0134073533, -0.1139461026, 0.0129673230, -0.1888136715, -0.1236299798, -0.0214393828, 0.0478470437, -0.0132927196, 0.0137831066, -0.0047933995, -0.0197449494, 0.0010238950, -0.0122316852, -0.1528993100, -0.0275315512, -0.0837512687, -0.1425437182, -0.0654844567, 0.0376338288, 0.1087308675, -0.1156428754, -0.1022725180, -0.1053112298, -0.1114687473, -0.0809900314, -0.0604658835, -0.0881119668, 0.0397743918, -0.0752372444, -0.0479578637, 0.1684586555, 0.0636806712, -0.0649076253, -0.0779279619, 0.1024530008, 0.0632257313, -0.0307720508, 0.0908284187, 0.1004543975, 0.1361580342, -0.0806295797, 0.0126122646, 0.1150726303, -0.0588279031, -0.0343865193, 0.0608567409, -0.0371160246, -0.0333743952, -0.0560546070, -0.0068878732, -0.0125438003, -0.1056374311, -0.0351316705, 0.0914768055, 0.0765126795, -0.1209274903, -0.0885199904, -0.0553052649, -0.1362268180, -0.0930646509, -0.0331752151, 0.0593019314, -0.1159147769, -0.0322255269, 0.0701448023, -0.0394543447, -0.1104970276, 0.0004070437, -0.0358679444, -0.0102532189, 0.0074897683, -0.0199718177, -0.1119543463, -0.0255208481, -0.0507675409, 0.0106600644, 0.0685282648, 0.0712717921, -0.1019510925, -0.0408943631, 0.0372695625, 0.0130398506, 0.0864591002, -0.1522350460, 0.0410409793, 0.0314746127, -0.1163060889, -0.0011903464, -0.1304996014, -0.4180077314, -0.1019296870, -0.1625968963, 0.0970475227, -0.1146064773, -0.0732569024, 0.0264048837, 0.0379040167, 1.0364432335, -5.8278474808, -0.2163314074, -0.0504571609, 0.0308742747, -0.1259270012, -0.0122616272, 0.3653947413, -0.0191738252, -0.1075413525, -0.0318105333, -0.3865338266, 0.0356270671, -0.1036679447, 0.0334979631, -0.0762246475, -0.1952943206, -0.1041170582, -0.0494035222, -0.0210764632, -0.1479481012, -0.0135685839, -0.1232096627, -0.0046032416, -0.0456563309, -0.2471364886, -0.0749627277, -0.3054023981, -0.4657999575, -0.0947918668, -0.2245877385, 0.1568847597, -0.0707981959, -0.0244630687, -0.0698735565, 0.0534273610, -0.0578051768, 0.2227338552, -0.0675765947, -0.0407274254, -0.6923905015, 0.2775581181, -0.0697786584, 0.0275560543, -0.1835008562, 0.0956297517, -1.2452220917, -0.1660217792, -0.0387326740, 0.1103722677, -0.0767759010, -0.4321247339, -0.4930884838, -0.5963597894, -0.7256546617, -0.0117549561, 0.0027338108, -0.0590672418, 0.0093515050, -0.0350303315, -0.0775176585, 0.0090289423, 0.1956607997, -0.0098632788, -0.1386349797, -0.0534863584, -1.5419352055, 0.0167058781, -0.2019999772, -0.2951599956, 0.5379719734, -0.5891848207, 0.0392577089, 0.0086915484, -0.0839714855, -0.1208096221, 0.5423847437, 0.1105652153, -0.9339666367, -0.2945681512, -0.1749878377, -0.1256457865, -0.0855195001, -0.3983063102, -0.1036420837, 0.2834597230, -0.2528040409, -0.0551888980, 0.0507016927, -0.0671509281, -0.0966101065, 0.3709199727, 0.0992112681, -0.0432184599, -0.0125654675, -0.4241195917, -0.0478647649, -0.0896634087, 0.1501761526, -0.1754066646, 0.2605703175, 0.0073776394, 0.0587687492, -0.3006810546, -0.1578495950, 0.0196674336, -0.1176717579, -0.0860132724, -0.0825819224, -0.1748665273, -0.2467646748, -0.6263083220, -0.0827187300, -0.1583378315, 0.0441795029, -0.4694210291, -0.1214480400, 0.1459702849, -0.1347726285, -0.1628778428, 0.3319602013, -0.1316270232, -0.0288880710, 0.0838543475, 0.0397858098, -0.0525157824, -0.2364559621, -0.0846925825, 0.0998703390, -0.1246335581, -0.8004357815, 0.0088887848, -0.0022950342, 0.4491877258, -0.0998353213, 0.0591175482, 0.1734379679, -0.0671871006, -2.1007735729, -0.3371390700, -0.1965986639, -0.0252557117, 0.0397138186, -0.0369792320, -0.0479719900, -0.5102039576, -0.5482204556, 0.3628312051, -1.4977962971, 0.0073151221, 0.0624680407, -1.0374964476, -0.1287671924, -0.3201274872, -0.0401318744, -0.0518054776, -0.0892828479, -0.4139172435, -0.0466812812, -0.0146107813, 0.0957118720, -0.0579378158, 0.3720689714, 0.1162111610, -0.0209824741, -0.0340738744, -0.2024087310, -0.1138708368, 0.1611234248, -0.4090898931, 0.7523435354, -0.1016352326, -0.1137670949, -0.0496457331, -0.0348404832, 0.2965003848, 0.0103530809, -0.3204656839, -0.1511189342, 0.0383721143, 0.0518377759, 0.0344172828, -0.0800728798, -0.0569220223, -0.1786197722, -0.1584693193, 0.0783210769, 0.0380260684, 0.0488707498, -0.5890201330, -0.1799922734, -0.1481603682, -0.9823077321, 0.1965642571, -0.0358666144, -0.1370802671, -0.2401713580, -0.3767839670, 0.4644567370, -0.3568332791, -0.3676343560, 0.1758792400, -0.0837374702, -0.0357826091, 0.1801329553, -0.2297476828, 0.0372642502, -0.5944140553, -0.0593258142, -0.1156040579, 0.5028085709, -0.1239125952, -0.8307487369, 0.1170135587, -0.0076439204, -0.0546755344, -0.3891162276, 0.2333839834, -0.0150412265, -0.1659747660, 0.3312613070, -0.0338636190, 0.1180645004, 0.0157505032, 0.0050778552, -0.0848907679, -0.0190827567, -0.1895269156, -0.1591635495, 0.0467346758, -0.0765415579, 0.5863103271, -4.6669545174, -0.0202600360, -0.4115750790, -0.5183278918, 0.1164809242, -2.3908107281, 0.0714598149, 0.0127872052, -0.2733028829, -0.5442566872, -0.1707531661, -0.4139370918, -0.7864444256, 0.0403897800, 0.2319390774, -0.0728745982, 0.5137097836, 0.1337332726, -0.4836201370, -0.1624187827, 0.0728082433, 0.3231417537, -0.0158843957, -0.1260846704, -0.2310733795, 0.1062593311, -0.1452671587, 0.0426690169, -0.2332771420, -0.0570189655, 0.0214179363, -0.9992787242, -0.0798629299, 0.0539453514, 0.1664334089, 0.5759632587, 0.0422569178, -0.0291523542, -0.0660249218, 0.0358979963, 0.0026087163, -0.2440831959, -0.8454763293, -0.0620894358, -0.3874170780, -0.0995848477, -0.1299622357, 0.0438974425, 0.3093811870, -0.4913311005, -0.0681180507, -0.1634513885, -0.0478453822, -0.0064591393, -0.0555918440, -0.5596880317, 0.1853423864, -0.0899464637, 0.0195833035, -0.0340625271, -0.1240533590, 0.3119345307, 0.0285680387, 0.0956568345, 0.3169901073, -0.2810476422, -0.0304754674, 0.0251921248, -0.1472052187, -0.0175677538, 0.7047002912, 0.4389833510, -0.1213575825, -1.6119685173, -0.0082751941, -1.1853203773, 0.0303809363, 0.0031751331, -1.4587721825, -0.1943363696, 0.0302890334, 0.3460617959, -0.0330499746, -0.0827277601, 0.0408101194, 0.0056187646, 0.3459360003, 0.0615303814, -0.1076872498, -0.0339477435, -1.0296618938, -0.0039509889, -0.7669588327, -0.0402502902, -0.3676991463, 0.3716469407, -0.0460979752, -0.1498367041, -0.1339185983, 0.0544925481, -0.0289563648, 0.3010651767, -0.0826037079, -0.0158192180, 0.0358768143, -0.0046830382, -0.1098065153, -0.8338144422, 0.0914994031, -0.4424364865, -0.2432317436, 0.0421792008, 0.0551771894, -0.0039792438, -0.0194967557, -0.1665792614, 0.3852659166, -0.0023547723, -0.0038974683, 0.1536163390, -0.0557512902, 0.0845552906, -0.1964143813, 0.0335282162, -0.2526991963, -0.0202788934, 0.0250975881, 0.7418012023, 0.2573401928, -0.1404301375, 0.2228761911, -1.0695115328, -0.0016048651, -0.8819156289, -0.9540031552, -0.1009185612, -0.1565778404, -0.1139902174, -0.1202399358, -1.1946678162, -0.1442412883, 0.5944355726, -0.0174039900, -0.0283473618, -0.0077911164, -0.0478164591, -0.0520828478, 0.0167429522, 0.0556186996, 0.5917162299, 0.0538966805, -0.0434300788, 0.0430283286, 0.0906913057, -0.0983865932, -0.1625428498, -0.0603327155, 0.5721702576, -0.4203839898, -0.0456881635, -0.0075074378, 0.3252233565, 0.0002985346, -0.4425981045, -0.4256456792, -0.0608223751, -0.0510070138, -0.0629582927, -0.1202653721, -0.2972014844, 0.6810835600, 0.2348117977, -0.3198725283, 0.2434663624, -0.0679545850, 0.2465870082, -0.1583440006, -0.1306433231, 0.0068835937, -0.1195544451, -0.0778308138, -0.4141489267, -0.2182890624, -0.0326464325, 0.0773617253, -0.0812121034, 0.1775113940, -0.9268251061, 0.0585491061, 0.0206316281, 0.6013050079, -0.0595123507, -0.4104582071, 0.1345583200, 0.1303812265, -0.0337404422, -0.0805659890, 0.0920150578, -0.6879935861, -0.3567724824, -0.0979274288, 0.4138489068, 0.0097931651, -0.0589810461, -0.0088689327, -0.0698088557, 0.0285792015, -0.2708321810, -0.4997661114, -0.0580338612, -0.1080579609, 0.0589525737, 0.5040642619, -1.5688314438, -1.7837288380, 0.6823141575, -0.1563156843, -0.1055785045, -0.1169101000, -0.0906887352, 0.1920659989, -0.4669840038, 0.2388417721, -0.2541707754, -0.7882619500, -0.3982791901, -0.0632352978, -0.0309359021, -0.4491586685, 0.0971576422, 0.0071466933, 0.1274799407, 0.0732769892, -0.1008050591, -0.5215452313, -0.1275786757, -1.7145000696, -0.0576353408, -0.0948123857, 0.0004887553, 0.3306556344, 0.2559180260, 0.0334890001, -0.1500871330, -0.4239140749, 0.0468338914, -0.0516751558, -0.0073350812, -0.0686831251, -0.0184426736, 0.0530285276, -0.2999536395, 0.3324382007, 0.1554245055, -0.0528009571, -0.4087502658, 0.4357648492, -0.0761936456, -0.5319794416, 0.5527260900, 0.2045675814, -1.9395288229, -0.0492547266, -0.0139599694, 0.0062523745, -0.1429073960, -0.0510630496, -0.0178590789, 0.2775163651, 0.0006805206, -0.1424921155, 0.0016049350, -0.1242076159, 0.2751813829, 0.0368530266, -0.0317518301, 0.0960852802, -0.0740047321, -0.2816821635, -0.0104502840, -0.1652897596, 0.0633774921, -0.0885187909, -0.0408223569, -0.0027306136, -0.1231161505, 0.1275814325, 0.0102631031, 0.0414695442, 0.0264575817, 0.0532882698, 0.0387503691, -0.0871859938, -0.0844300985, -0.1375231296, -0.0158514287, -0.0631321147, -0.0715010241, -0.1929474771, 0.0044470518, -0.1410805583, 0.0447003543, -0.1563429832, -0.0640175790, -0.0502276681, 0.1016887724, 0.1297739744, -0.0316257291, -0.0257973634, -0.0168634783, -0.1264460832, 0.0826106295, -0.1904095262, 0.0246893857, -0.0063459547, -0.0119361458, -0.1399960071, -0.1263647974, -0.0884274989, 0.0441595353, -0.2053213418, -0.1147055030, 0.0602052920, 0.0067614759, -0.0445138738, 0.0460539497, -0.1200210154, 0.0364269204, 0.0342172161, 0.0550687090, -0.2066097707, 0.0372459292, -0.1004906446, -0.1284626424, -0.0485839359, -0.1236288622, 0.0557681695, -0.0256527718, 0.0802868903, 0.0789240152, -0.1303706318, -0.1274342984, -0.1111751273, 0.0796582624, 0.0236524604, 0.0725138411, -0.0269688889, -0.1323056221, 0.0218390860, -0.2152326703, 0.2388944775, 0.0744787455, -0.0736577660, -0.1708130687, 0.0162480678, 0.0563154146, 0.1257127225, -0.1474220157, -0.1000957787, -0.0055112420, 0.0655477270, -0.1725113094, 0.0069234939, 0.0784737393, 0.0479796939, -0.0345753580, 0.0322799087, 0.0917235985, -0.1102557033, -0.0850964636, 0.0314589776, -0.1046606675, -0.0385210514, -0.0599592514, -0.0807158500, 0.0339781605, -0.0249775834, 0.0264190976, 0.1911337078, 0.0362249874, -0.0907115489, 0.0517428480, -0.1337079108, -0.0483796187, 0.0617733188, -0.1037655547, -0.0260735676, 0.0786357224, -0.0624916255, -0.1740305722, 0.0963453948, -0.0122368429, -0.0118018445, -0.1621425003, -0.0549908094, 0.0780064613, -0.0459657311, -0.0024970386, -0.2604552209, -0.0328240618, 0.1422300935, 0.0300079789, 0.0424637757, -0.1076124161, -0.1432715952, -0.0972589552, -0.0217182282, -0.3042361140, -0.0413508043, -0.1101047993, 0.0372968689, -0.0252808537, -0.0840049535, 0.1351942420, 0.0434188396, 0.0791734383, 0.1614746153, 0.0899878889, 0.0257483535, -0.1616762131, -0.0625606105, -0.0161151960, -0.1107867584, 0.0849920586, -0.1223226190, 0.0214511603, 0.0809898227, -0.0984741375, 0.0699970424, -0.1287610680, -0.1001862511, -0.0668397024, -0.0657438561, 0.1128791571, 0.0932465643, 0.0371988155, -0.1155059412, -0.0754614472, -0.0140062897, -0.1145650744, -0.0007838163, 0.0122390538, -0.0553647280, 0.0518672839, -0.0369830430, 0.0669418946, -0.0743991509, -0.0432232954, 0.1062696278, -0.0060606454, -0.0205748323, 0.0487608053, -0.1426797509, 0.0070058564, 0.0987657234, -0.2244455367, -0.0481502265, 0.1101952866, -0.0678142309, 0.0346759893, 0.0022743028, 0.0561687872, 0.0345000252, -0.0726582706, -0.1301549077, -0.0251938738, 0.0112635335, -0.0661565512, 0.0658164099, 0.0129741738, 0.0295195654, -0.0955138132, -0.0360761173, -0.0836213902, -0.1379069686, -0.0501184911, 0.0864423588, -0.1234534234, 0.0667920262, 0.1072972268, -0.0305903070, 0.0578528084, 0.0970778838, 0.0596721061, -0.1640460342, -0.0208545681, 0.0989912599, -0.0498053506, 0.0941778570, -0.1611930132, -0.0240524374, -0.0795018077, -0.0144479992, 0.0740545169, -0.1140548363, 0.0286683422, 0.0422714353, 0.0176169313, 0.0019396418, 0.0689367503, -0.2353164852, 0.0150815835, -0.1126729324, 0.1162791401, 0.0050030057, -0.1088536605, -0.0467922501, -0.2647349238, -0.1316557974, 0.1470840871, 0.0997390822, 0.0482534990, -0.0122895204, -0.1335781962, 0.0401381589, -0.1804216653, -0.0459826477, -0.0884142742, 0.0180820767, 0.0705223531, -0.1437277049, 0.0504640490, -0.1085594147, -0.2585360110, 0.0733472258, -0.0842207223, 0.0464542583, -0.0457633696, -0.2074809521, 0.2500467598, -0.1199567392, 0.1877155453, 0.0409800038, 0.0411275998, 0.1255107820, -0.0317276455, -0.1289459765, 0.1962323934, 0.0335331634, -0.0768518001, -0.0581445806, -0.1733233631, 0.0116469450, 0.0994450375, 0.1205359995, -0.0439554378, -0.0148042906, 0.0492225438, 0.0071410020, 0.2076513171, -0.1263581216, -0.0463120863, -0.1553986520, 0.0005706317, -0.1186849847, -0.0978486389, -0.0892040059, -0.0842116550, 0.0422056839, -0.0921129584, 0.2222124338, 0.0032865331, -0.0962369069, -0.0419188961, 0.0630484670, -0.1778897792, 0.0657049865, -0.1448038071, 0.1662361771, 0.0835917220, -0.0075939121, 0.0262256283, 0.0199330375, -0.1591503769, -0.0622378327, -0.1780014038, 0.1325059980, -0.0967952758, -0.0377096049, 0.1269329786, -0.0153893996, -0.1162984967, 0.1722377539, 0.0880995914, -0.0318168737, 0.1240763292, 0.0265907254, -0.0091047687, -0.0434709154, -0.1032974273, 0.0375741981, 0.0734443963, -0.1192625687, 0.0560122728, 0.0331657119, 0.0902565569, -0.0606624484, 0.0055355770, 0.0726805106, 0.0282254200, 0.0796129853, -0.1253685653, -0.0250625033, -0.0423720852, -0.0779987052, 0.0073492229, -0.1737981737, -0.1170062199, -0.0699972883, -0.0917936265, -0.1292889863, 0.0259151831, 0.1129103601, 0.1200397089, -0.0430906340, -0.0549326912, -0.3466477096, 0.1054190099, -0.0523273535, 0.0752497017, 0.0116701573, 0.0178541448, -0.2016957253, 0.0429163501, -0.0181396175, 0.1397340745, -0.0520076379, -0.0416938551, -0.2742553353, -0.0305253807, -0.0246442202, -0.2058791369, -0.1324659735, 0.0729335397, -0.1547809541, 0.0264636427, -0.0224881023, -0.0341673568, -0.1290901750, 0.0411782973, -0.0167722013, 0.0354069583, -0.2215908319, 0.0655940548, 0.0675166845, -0.0328139998, -0.1112454459, 0.3279753625, -0.0216825772, -0.0965456888, 0.0823332369, -0.0947050974, -0.0782269239, 0.1381844282, 0.1108534336, -0.0045863767, 0.0614004657, 0.0848588049, 0.0445234850, -0.0736352354, 0.0444324389, -0.1047560200, 0.1876481324, -0.0102850990, -0.0504653901, -0.0839843601, 0.1904458255, -0.0446726494, 0.0192627925, -0.1853469610, -0.0799574628, 0.0493499190, 0.0475571826, -0.1305675656, 0.0491626449, -0.1631594747, 0.0149013652, -0.1493763030, -0.1342388391, 0.0746873170, -0.1020862758, 0.0917822570, -0.0503286608, 0.0838145316, 0.2207219601, -0.0452881753, 0.0565867834, -0.1067983657, 0.0679606348, -0.3354722857, 0.0215247609, -0.1338050514, 0.0216899924, 0.0740170553, 0.1655355245, 0.1321366578, -0.0826622620, -0.0404825360, -0.0279038325, 0.0588399284, -0.0881161094, -0.1390352398, -0.1696389318, 0.0050801625, -0.0220278017, 0.0191921052, -0.0330001377, 0.1238025576, -0.1624027640, 0.0006567497, 0.0209035743, -0.2236849368, 0.0641398132, 0.1656764150, -0.1543551236, 0.1766586304, -0.0413760655, -0.0881129727, -0.0519192517, 0.0100210663, -0.0348285623, 0.0216423962, -0.0538444407, -0.0746632218, 0.1264270693, -0.3042838573, 0.2037590891, -0.1739938706, 0.0209197067, -0.0096640121, 0.0770517364, 0.0666602850, -0.0601499565, -0.0449949838, 0.0151259359, -0.0368057601, 0.1073322967, -0.0588209704, 0.0548434258, 0.0451230370, -0.0368453339, 0.4502509236, 0.2004640698, -0.0577889383, -0.1959720999, -0.0369304419, 0.0791190937, -0.0380199440, -0.0972018689, -0.1089942977, -0.1335044652, -0.0602617450, -0.1088625789, -0.1478752643, 0.0962074324, 0.0511796363, 0.0313044004, 0.0493966527, -0.1649332196, 0.0263771228, -0.0180640519, -0.0327172615, -0.1620798558, -0.0571094304, -0.0684201643, -0.2913516164, 0.0640896484, 0.0889993161, 0.0036640654, 0.0884755030, 0.0501713715, 0.0904037878, 0.1236028075, 0.0679010376, 0.0260451213, 0.0823761225, 0.1113818809, -0.1542056054, -0.0355423205, 0.0647315085, 0.0683372021, -0.0994624719, -0.1377629489, 0.1157099381, -0.0727146417, 0.1841316819, 0.0461050309, 0.0485001877, -0.0206656624, -0.0607847609, 0.1158718541, -0.0168977696, -0.0812037215, 0.0805174485, 0.0213868283, -0.0334161222, -0.0481919833, -0.0276882127, 0.1283402294, -0.1348547786, -0.0704151914, -0.1475046724, -0.0880485475, -0.0473196432, -0.0424616411, 0.1028160378, -0.0246262234, 0.1134090871, 0.0581416525, 0.1207321808, -0.2215234935, -0.0738061517, -0.3096133173, -0.0906381682, -0.0384472907, -0.1207181141, -0.2123502791, -0.0490659401, -0.0409985185, -0.1887496859, -0.0647040233, -0.0017060263, -0.0695645139, -0.1151474491, 0.2105122954, -0.0706000179, -0.0025766578, 0.0946632102, -0.1648677737, 0.0440684892, 0.0006831290, 0.0787580237, -0.1185402200, -0.0545873195, -0.0689375922, -0.0317758992, -0.0110502206, -0.0600414872, 0.1164491102, 0.0255137905, -0.0117897140, -0.1731929630, -0.0202640966, 0.0209172666, -0.0515467748, -0.1333790123, -0.2827449739, -0.0067138849, 0.0269751959, -0.0295050349, -0.1318851709, 0.0324370191, -0.1080359891, 0.1563977897, 0.1015114337, -0.0145483697, 0.0316670872, -0.0596349016, 0.0685366690, -0.1637408137, 0.1164317131, -0.2852943540, -0.0120060341, -0.0119675463, -0.0520123057, -0.1437322795, 0.0237272009, -0.0897669643, -0.0692816600, -0.1254743189, 0.0603120811, -0.1134939417, 0.0788228363, -0.0666387081, -0.0301132239, -0.0666477978, 0.0237076189, -0.0555627868, 0.0124808913, 0.0901139602, 0.0503094271, 0.0510994233, -0.1472177953, 0.0571605824, -0.0757493451, -0.0512182862, -0.0325909443, -0.2208437622, 0.0270690955, -0.0246388614, -0.0326909274, 0.0585996099, 0.0428523384, 0.0464201756, 0.0685444176, 0.0028372209, -0.2333173603, -0.0415214971, -0.0107812686, -0.0330923535, -0.1249197274, 0.0949144363, 0.0147664361, 0.0655038953, -0.0016601199, -0.1292539239, 0.0769779161, -0.1768939793, -0.1398650259, -0.0728441328, -0.0276627075, 0.0368073881, -0.1280882657, -0.0338344127, 0.0269309618, -0.1125005260, 0.0141411396, -0.0123859188, -0.0090580871, 0.0046815067, 0.0832021609, 0.0525873154, -0.0359160155, -0.1345915794, 0.0447074771, -0.2189128697, 0.0065046502, -0.0600941405, -0.0487802029, -0.0612044930, -0.1305783093, -0.0478297845, -0.1046201512, -0.0937770158, -0.0123238349, 0.0866054669, -0.1296176761, 0.0625821874, 0.0920000896, -0.0049530459, 0.0401321799, -0.0135241458, -0.0886908099, -0.1223733574, -0.1057669520, 0.1756604463, 0.0380869694, -0.1333264261, -0.0899275094, 0.1388588101, 0.1155599132, 0.0099716857, 0.0770466626, 0.0403692275, 0.0265889633, 0.0161804836, -0.0486202799, -0.0249210503, -0.1145819128, 0.0548555478, -0.1225478351, 0.1100091860, 0.0551474243, -0.0842641294, -0.1399458200, -0.1387799829, 0.0318697914, -0.0776406825, -0.0282652527, 0.0192519836, -0.0126400050, -0.1671517193, -0.0831803456, -0.0309640132, -0.0041663242, -0.0216742288, -0.0776612833, -0.0348537117, 0.0182395373, -0.0378715135, -0.0145263448, -0.1666826308, 0.0311604571, -0.0583287999, -0.0685891286, -0.0825437680, -0.0400342532, -0.0402895510, 0.0448486619, 0.0729246140, -0.1754346192, -0.0033651972, -0.0303970184, 0.1982336342, 0.0402232781, 0.1251264662, -0.0718936846, -0.0517199226, 0.1414663792, -0.0591332428, -0.0220381375, -0.0846627578, 0.0012990721, -0.0235519484, 0.1358185112, 0.0922462791, 0.0828882158, 0.0962331817, -0.0600454397, -0.1621208042, 0.0867482722, -0.1055080444, -0.0729906335, 0.0158114787, -0.1400813907, -0.0394440889, -0.1148449704, -0.0835880488, -0.0143767120, -0.1232236698, -0.1779816598, -0.1944917142, -0.0156505872, 0.1811092198, 0.0067201583, -0.0837449208, 0.0349857472, -0.0417573787, 0.0240784381, -0.2101869136, -0.0520237684, -0.0779625848, 0.0934477374, 0.0636449829, 0.0175750051, 0.1610066146, -0.0094436072, -0.0133969514, 0.0774849430, -0.0030491068, -0.5382196307, -0.0916394442, -0.1282696277, 0.1120172143, 0.0695862249, 0.0940206647, -0.1097317338, -0.1407209188, -0.1359781772, 0.1029518470, -0.1081647798, 0.0590445697, -0.1012874618, -0.0042609093, -0.0912037939, 0.0143045112, -0.0180251896, 0.0991793498, 0.0563200787, -0.0826331228, 0.0503265336, 0.0826546773, 0.1931262761, 0.1648621410, -0.0128310677, -0.0316439345, 0.1394011229, -0.0268202741, 0.0067733550, -0.0339352861, -0.0831199810, 0.0250177756, -0.0682262927, 0.0808487386, -0.1125356555, -0.3336253762, -0.0215488933, -0.0170615595, 0.1281519085, -0.0542489700, 0.1087858155, -0.1001806483, 0.0558010712, 0.0301032588, 0.0064134821, 0.0134116448, 0.1091628820, -0.0615940429, -0.0325815901, -0.0303960461, -0.0251052659, -0.0876344517, -0.0236489046, 0.0201471709, -0.0708304495, -0.0429649204, -0.0272737816, -0.1566314697, -0.1082719713, 0.0296742320, -0.0019865069, -0.1996528655, -0.0193218943, 0.0777601004, -0.0991872326, -0.0890366137, -0.1033835113, -0.0126727633, -0.0217145681, 0.1350159645, -0.0954859704, 0.1291819066, 0.0998025909, -0.1354606897, 0.0357452929, -0.1530990601, -0.2143992186, 0.0019080844, -0.2155060768, 0.1106149629, -0.0558647700, 0.0817325711, 0.0217091851, -0.0044208332, -0.1174615771, -0.1449727416, -0.2180429995, 0.0230305512, -0.0952083617, 0.0954406336, 0.1180573031, 0.2531478405, 0.0640427619, -0.1965292841, 0.0356002189, -0.0616058707, -0.1142373979, -0.1040639356, -0.1039372385, -0.0681202412, 0.0310340822, 0.0578421764, -0.0848213285, -0.0805896148, -0.1898868233, -0.0159701053, -0.0156263877, 0.1097873226, -0.2052490413, -0.0560059547, -0.1472865343, -0.2092835754, 0.0943590328, -0.0885887891, 0.1067762226, -0.2569151819, 0.0486563966, -0.1249888018, -0.1155933440, 0.1341394186, -0.0593994930, 0.0252507627, -0.0336902924, -0.0385719761, 0.0103923557, -0.0141828656, 0.0433156788, 0.0417578816, 0.0851669759, 0.1373583823, 0.0575884022, -0.0493363962, 0.0832961500, 0.1136237234, 0.0466873571, -0.0485989712, -0.1221701279, -0.1621815264, 0.0644287318, 0.0456857719, -0.0916145444, 0.0819633976, -0.0032901990, -0.0116439927, -0.0128457164, 0.0908136591, 0.0003049245, 0.1472016126, 0.0733195767, 0.0719008744, -0.1034547538, -0.0701045841, 0.0064889421, 0.0436586924, 0.0054821810, 0.2176835686, -0.2614053488, -0.1364069581, 0.0230804998, -0.0679516792, 0.0273267478, -0.1377675682, 0.0057615768, -0.0363731496, 0.1249229014, 0.0062758173, -0.1448256224, -0.0878312737, -0.0096533271, -0.0551466122, 0.0262261257, 0.0818488672, -0.0765369982, -0.1188483834, -0.1765537858, 0.2222123742, -0.2407052219, 0.0681330487, 0.0059964461, 0.0772730336, 0.1160505340, -0.1241553128, -0.0439477600, -0.0059794947, -0.0089895036, 0.0851486251, -0.0373563133, 0.0757149383, 0.0968436450, 0.0862164721, -0.0854358599, -0.1460756212, -0.2861833870, 0.0009033318, -0.1055379659, -0.1183205247, 0.0811859667, -0.0251918770, 0.1318024695, 0.0019437665, -0.0705677420, -0.2035611570, 0.0028451381, 0.0051170290, -0.1350058317, 0.0591795780, -0.0564029887, -0.1335062832, -0.0464485064, -0.2196722776, 0.0835742652, 0.0440841913, -0.0185662303, 0.0342327617, 0.0274010729, 0.0649287254, 0.0840685293, -0.0283039808, -0.1422247887, 0.0333804935, 0.0962040275, 0.0083931042, -0.1085081398, 0.0539115816, 0.0481568240, 0.0478041954, -0.0066883611, -0.0063588829, -0.1343405992, 0.1096641570, -0.1942971349, 0.2682380080, -0.1231799424, 0.0447815061, -0.1094916165, 0.1742154211, -0.0882084742, -0.0355538130, -0.0416861214, 0.0406730026, -0.0023913244, -0.1988906711, 0.0186753292, 0.0710485950, 0.0749025717, -0.1147727594, -0.0031212096, -0.0259999447, 0.0548979342, 0.0072672404, -0.1208546758, 0.0607337542, 0.0970775709, 0.0044328654, -0.0504536889, -0.0393298492, 0.0066829864, 0.2670898139, -0.0432810336, 0.0788836405, 0.0599821694, 0.1540648788, 0.0263454616, 0.0025198122, -2.4237985611, -0.0042551025, -0.3802890182, 0.0056850268, -0.2228178233, -0.2789610922, -0.0671180412, -0.1363574117, -0.0670651346, -0.0165739357, -0.3825732470, -0.1815174669, -0.0139651243, 0.0136833144, -0.1917203814, -0.1065982506, -0.8529196382, -0.1699763983, 0.5042316318, -0.0012449843, -0.1737674028, -0.1762865037, -0.0609487928, 0.0451088548, 0.0761796683, 0.0156487990, 0.3302032351, 0.0508947670, 0.0493855998, -0.1308266371, -0.1335292757, -0.1023563594, 0.3036486208, -0.1387319565, -0.1453796327, -0.0886908099, -0.0476829037, -0.4366395175, 0.0334523432, -0.3279847205, 0.4042883217, 0.0758843571, -0.0900035128, -0.0353932902, -0.0559364259, 0.0757612959, 0.3495465815, -0.1555805653, -0.1577486247, -2.9022004604, -0.0554448888, -4.4680671692, -0.2668643892, 0.0223509669, -0.9527450204, -0.4086638987, 0.0088400375, -0.4008307457, -0.7506347299, 0.0137301618, -0.0783944502, 0.0028007557, -1.3951596022, -0.0196306277, -0.1396201104, -0.1404840350, -0.0749402642, -0.1439842433, -0.4947187901, 0.1471528858, -1.7010118961, -0.0418357551, -0.0361752100, 0.0601792373, -0.0117532965, 0.1001933366, -0.3456417322, -0.6514282227, -0.2693141699, -0.1220068038, -0.0322136730, -0.0386286117, -0.1692285538, -0.6560495496, -0.0282723866, -0.3779303730, 0.0684939623, -0.0178915132, 0.0084044132, -0.2334425747, -0.1369751096, -0.4450870752, -1.1073718071, -0.0022629015, -0.0135676805, -0.0830904171, 0.0181275569, 0.0043879859, -0.0082419179, 0.0792964026, -1.5701668262, -0.0091476925, -0.0384009704, 0.0095220068, 0.0502367243, -0.1443947703, 0.0277431738, 0.2027665526, -0.0841002166, -0.5248380899, 0.0844284892, 0.0724092573, -0.0977799669, -0.1642971337, 0.3107874990, -0.2729808092, 0.0104170665, -0.6249340177, 0.3285999000, -0.0379816256, 0.6935611963, -0.2255281657, -0.1076514125, 0.0601214096, -0.0042118379, 0.0013981869, 0.2315091193, -0.1103064492, 0.1173575446, 0.0433075912, 0.5280647278, -0.0183130316, -0.0132203549, -0.0131868608, 0.0429295935, 0.0171807278, -0.2304286659, 0.1036129519, -0.2755855024, 0.5991348028, -0.1575020999, -0.0184653662, -0.0595480576, 0.0214626659, -0.1092066765, 0.0278538540, 0.0074036201, -0.3245476782, 0.5137892962, 0.0233463868, -0.0048947376, -0.3877079189, -0.0614287779, -0.5630419850, 0.0520233959, -0.0793477297, 0.0250738282, -0.1253441572, -0.2079903632, -0.0218654349, -0.0934477746, 0.0181910004, 0.1450883597, -0.3409779370, -0.0317760669, 0.0875722617, -0.0154496878, -0.0189969931, -0.5168119073, -0.5444424152, 0.0905629247, -0.0859677196, 0.1536880583, 0.0043382347, 0.2261987329, -0.2819851339, -0.0210858993, 0.2548497617, -0.0183184464, -0.1076427549, 0.0056126113, 0.0778225437, 0.0333519019, -0.0108147711, -0.1420263499, 0.0856194720, -0.0509873331, -0.0487115830, -0.5821207166, 0.2995995879, -0.0524821542, -0.7525510192, 0.1073261499, 0.1464984864, -0.1084069833, 0.0677205622, 0.1802765131, -0.4118953049, -0.5185016394, -0.0479659811, -0.1753380746, -0.3855034411, -0.0273631997, 0.0245736483, 0.3065440059, -0.2977851927, 0.0489810817, -0.2599653304, 0.3482314050, -0.1805526465, -0.1360623837, 0.1259017736, 0.4670039117, 0.3596190214, -0.0746721700, -0.1749158800, -0.9874761701, 0.1545112729, 0.0172304660, -0.1764938831, -0.3492693007, -0.0557047650, -0.2111503333, -0.5312612653, 0.0580176711, -0.1813685149, -0.0141522139, -0.1535936296, -0.2346879244, -0.1168007776, 0.0866696239, -0.3743371964, -0.2261666805, 0.0212847106, 0.3137514591, -0.8010596633, 0.0915383771, 0.1671921760, -0.1492187381, 0.0759908035, -0.0889298990, -0.2381635159, -0.1785721779, -0.0608063526, 0.2787326872, 0.0381320380, 0.3430180252, 0.0346450284, 0.2391834706, -0.1274589598, -0.2681874633, 0.4352130294, -0.0912242904, -0.1190032512, 0.0935946330, -0.0142608313, -0.6627231836, -0.0151198748, -0.2263948768, -0.0814594403, 0.0424794331, 0.0243556239, 0.0864859298, -2.2899372578, 0.0458012968, -0.1425681263, 0.2722052932, -0.2759352624, 0.0053164749, -0.0249360614, -0.1381889731, -0.0199159142, -0.5492415428, -0.1212534085, 0.8459092975, 0.0065024211, 0.1150159761, -0.2595250905, 0.0188303366, -0.1325809956, -0.3723905981, -0.1004750580, -0.1984835118, -0.0460288487, 0.0689739212, -0.0194911230, -0.1027874202, -0.3160975575, 0.2028924823, -0.1190704629, -0.0716664791, -0.0371649340, 0.1059762388, 0.0124402232, 0.0437308848, -0.2013090253, 0.0446198843, -0.3693265319, 0.0751649067, 0.0451341793, -0.2176924050, 0.0332746767, -0.0630903989, 0.4224510491, 0.0573543943, -0.3315512538, 0.0645285621, 0.2384546995, -1.0622762442, -0.1082492322, -1.5954759121, 0.3420298100, -0.0414066389, 0.1735587865, -0.0099957073, -0.1159853786, -0.0250428617, -0.0066961651, 0.2417932898, 0.0363177173, 0.0480848216, -0.1258658320, 0.1278022230, -0.0641609430, -0.7576762438, -0.0444736890, -0.2102369219, -0.3449723125, -0.0595077202, -0.0416120104, -0.0189769566, -0.0971348062, 0.0467465073, -1.6114063263, 0.3519846797, -0.3921330273, -0.1574940979, -0.0437750854, -0.1416434497, 0.6070719361, -0.1967138797, -0.4016424716, 0.0688534975, -0.0152127976, -0.0564999916, -0.0082805138, 0.0226469599, -0.1654550433, -0.3938605487, -0.2230880409, 0.0034037202, -0.0191363450, 0.0268820338, -0.1286816448, 0.2622186244, -0.2033928782, -0.6930440664, -0.0195367076, -0.0570337959, 0.0369448289, 0.1995156705, 0.0283895023, -0.0481544398, -0.0157970022, -0.1412752122, 0.0844804570, 0.3362801969, 0.0386245809, -0.1546267122, -0.0388157442, -0.0287188794, 0.2762126625, -0.0623321868, -0.4520607293, 0.0015290648, -0.1251292080, 0.0248048771, 0.0980648994, -0.1204296574, 0.0142031498, 0.1680914909, -0.9460906386, -0.3469562829, 0.7521730065, 0.0951227695, 0.4161408842, -0.2402260453, -0.0062872916, -0.0234021582, -0.8027696013, -0.0090795746, -0.0064437911, 0.5878025889, 0.0071423589, -1.9723688364, 0.5464809537, -0.1114422157, -0.2021000981, 0.0192745812, 0.0152982054, -0.1569749415, 0.0326516032, -0.1826251298, -0.2587609887, -0.8246235847, -0.1962548941, -0.1219595373, -0.8347959518, -0.1140484214, 0.5650930405, 0.0016410210, 0.0010197181, 0.0429506861, 0.5022596121, -0.3416838944, -0.0025509265, -0.0144901592, 0.0153712286, -0.1355505735, 0.5104702711, -0.0802629143, -0.1428476870, -0.2215133756, -0.1865629852, -0.2440784574, -0.2183838785, -0.0678172931, -0.1235226095, 0.0431298353, -0.0904553831, -0.4016848207, 0.1952238679, -0.1389191151, 0.0230483580, -0.0533024929, 0.0597475953, -0.0742076635, -0.4617735445, -0.1858831793, -0.6912516356, -0.1497308910, -0.0209875219, 0.1233311892, 0.0116510829, -0.1236576214, 0.1910505742, 0.3036242127, 0.1968013942, -0.0276161321, -0.0501436852, -0.0882536396, -0.1176723242, -0.4349860251, -0.6836956739, -0.0941804647, 0.1161478460, -0.3276290298, 0.2507992387, -0.0932943821, 0.0062530376, -2.5840871334, 0.1658504009, -0.2574567795, 0.0290517882, 0.0270965993, -0.1049346849, 0.0272596441, -0.1678543389, 0.3855584860, -0.0531146005, 0.0843428150, 0.0612698421, -0.6739584804, -0.2367324084, 0.0175429713, -0.0231520571, 0.2095748037, 0.0547399633, -1.8418130875, -0.2451460809, -0.0654729009, 0.0163172279, 0.0303990729, 0.2237892598, 0.7583997250, 0.0800853446, -0.2387529463, 0.0493340082, -0.1250611097, -0.1429097205, -0.1367503703, -0.3225578070, 0.0565101095, -0.8492257595, -0.2101940513, -0.0506078303, 0.1104322970, 0.5016745925, -0.0409629047, -0.0776895210, -0.1880192310, -0.0873301029, 0.2164285630, -0.0618926659, -3.0816960335, -0.2339023352, 0.5076797605, -0.0831919834, 0.0197628364, -0.1009694487, -0.1014778465, 0.1197771430, 0.0529302955, -0.0496848077, 0.1185059249, -0.0114863068, -0.0143969581, 0.0583625808, -0.0631521717, -0.0697251335, -0.0939449966, -0.1010627076, -0.1139547452, 0.0898984373, -0.0189011097, 0.0686442554, -0.0259439945, -0.1194594875, 0.1130698621, -0.0019731373, 0.0449041165, 0.0221030824, -0.0979329497, 0.0571864806, 0.0264722705, 0.1157769263, 0.0327812545, -0.0062692277, 0.0145929102, 0.1041463390, 0.0010995567, 0.0494768955, 0.0646488070, -0.0245802552, 0.0887859091, -0.0572468452, 0.0815645531, 0.1196274981, 0.1122404635, 0.0515096262, -0.0446020812, 0.0516588576, 0.0487480834, -0.0444412231, 0.0011126682, -0.0410285890, 0.0807835609, 0.0181831326, 0.0594866723, -0.0593219772, 0.0504394583, -0.0693651363, -0.0322709978, 0.0496676899, -0.0205822010, 0.0053000152, -0.0657323375, -0.0695336461, -0.0336621106, 0.1079716310, 0.1244146451, -0.1109927744, 0.0772188902, -0.1238285899, 0.1187331527, 0.0998605564, 0.0640266463, 0.0946477428, -0.0382747613, -0.0314913988, 0.0633142292, 0.1176157296, -0.0258985814, -0.0866179839, -0.1063650250, -0.0044739246, 0.1137881950, -0.0739578307, 0.0940947309, -0.1179700643, 0.1134942546, 0.1067240313, 0.0981259272, -0.0264903605, -0.1042329669, -0.1025128067, -0.0918397829, 0.1011825353, -0.0023166125, -0.0284132622, 0.0036263764, -0.0539983213, 0.0609288625, 0.0384821445, -0.1156685352, 0.1305053234, -0.0493358411, 0.0562251173, 0.0391233489, -0.0457346141, 0.0187623519, 0.0399502404, 0.0667968690, -0.0162112247, 0.0007053912, 0.0185054243, -0.0282594655, 0.0236857831, -0.0601898022, 0.0290830135, 0.0033868849, 0.0409633145, -0.1068888158, -0.1160704046, -0.0031673554, -0.0383146703, -0.0688836202, 0.0518837869, -0.0043621063, 0.0549108014, 0.1084863544, -0.1262984872, -0.0475028791, -0.0468102619, 0.0064531099, 0.0510685183, 0.0883174613, -0.0568870306, -0.0564264171, 0.1153711081, 0.0423178561, -0.1079268381, -0.0012442096, -0.0155504541, -0.0740835518, -0.0927265882, 0.0976969674, 0.0892705694, -0.0358937457, 0.0147155067, 0.0540013947, -0.1058896333, -0.0116419736, -0.0585252233, 0.0439430773, 0.0728655979, 0.0187082291, -0.0172948595, -0.0804114938, -0.0160137713, -0.0663201064, -0.0085147312, 0.1004502773, 0.0785974860, 0.0923986584, 0.1208848506, 0.0170841217, 0.0061991811, -0.0515793413, 0.1055722684, 0.0226701200, 0.0361695886, -0.0062878728, 0.0122395176, 0.0600653328, 0.0279032290, -0.0688770190, 0.0273175240, 0.0615418255, -0.1029078290, 0.0343367755, 0.0346492901, 0.1294019967, 0.1213595197, -0.0877519548, -0.0812054574, -0.1154199094, 0.0116596818, 0.0971259028, 0.0874759480, -0.0962613523, 0.0807829797, -0.0775239468, 0.0567618012, 0.0990418792, 0.0291883182, -0.0714909211, 0.0344462991, 0.1082340181, -0.0853768289, -0.0231465939, -0.0079779625, -0.0414349921, 0.0919014290, 0.1015108898, -0.1245752573, 0.0093102157, -0.0180605054, -0.1028163806, 0.0132705960, 0.0164805762, -0.0383211970, 0.0464976616, 0.0895527750, 0.0444951057, -0.1134055853, -0.0925562978, -0.0222604387, 0.0752075836, -0.0000324585, -0.0843811333, 0.1202573776, 0.0521754399, 0.0152965188, 0.0770249665, 0.0022312785, 0.0587185621, 0.0511394590, -0.0539292209, 0.0230350122, 0.0960296318, -0.1193501055, 0.0866826698, -0.0986501426, 0.0525771976, 0.0903963372, 0.0923460424, 0.0169479847, -0.0345684141, -0.0512128174, 0.0925749838, -0.0506868064, 0.0897166282, -0.0144078666, -0.0741761103, -0.1025283337, -0.1017594412, -0.0211334415, -0.0244337842, -0.0198740661, 0.1072571948, -0.0501359515, 0.0275065396, -0.0437128283, -0.0456357673, 0.0788329691, 0.0863865018, 0.0656429157, 0.1031241119, -0.0574006103, -0.0409406424, -0.1111899912, -0.0761365294, -0.1141242534, -0.0229926258, -0.1467141509, -0.1131984740, -0.0943188369, 0.7591123581, -0.0243158545, -0.1806618273, -0.1376120895, -0.0825722069, 0.0626708120, -0.1032020748, -0.2469128519, -0.0860395730, -0.0748149306, 0.2833660245, -0.3485561311, 0.0076927599, -0.0725813583, -0.1263938248, 0.0271408893, 0.6874808073, -0.9067847133, -0.2653907537, -0.0168486871, -0.1176115423, -0.0571997315, 0.0252691880, -0.0942009836, -0.2201401889, 0.0373255908, -0.3819297254, -0.0676422268, -0.9138832688, 0.0476446226, 0.1210531667, 0.4818651080, -0.4284013212, -0.1698515862, -0.1352422535, 0.0135084093, -0.0278198309, 0.4946784973, -0.1367613524, 0.2392984331, 0.1562117785, 0.2355599403, 0.0961890966, 0.0170748550, -0.0694067329, -0.0320999175, -0.3782728910, -1.0268605947, -0.0868356302, -2.2536258698, -0.2353672683, -0.5915965438, -2.0262513161, -0.0896973610, 0.7330827713, -0.1042104587, 0.0968998373, 0.2369847149, -0.4863444269, 0.0006070451, 0.0439063646, -0.0139751164, -1.5050032139, 0.0478712209, -0.1092141047, -0.0175294671, -0.0588394105, -0.1072356701, -0.8797799349, -0.1526177078, -1.4336223602, 0.2615672052, -0.1489131302, -0.1168034077, -0.1223907545, -0.0220351927, -0.1368868947, -1.0042479038, -0.1096627861, -0.0295018796, -0.2695398331, 0.1149499416, 0.1202683449, 0.3089358807, 0.1250278056, 0.1484611779, -0.0443992987, 0.0432940722, 0.0693436041, 0.1484010071, 0.0157097280, -0.0874815062, 0.8652716279, -0.0805798322, 0.0406377390, 0.0050928639, 0.0102103492, 0.0482323393, 0.3144741654, -0.0066169794, -0.9929884672, -0.0243438389, 0.0531101823, -0.8776735067, 0.3336554170, -0.1382532716, 0.1791402251, -0.4192285538, -0.1439284235, 0.3198955655, -0.1985921711, -1.1164904833, -0.0484884419, 0.0537000448, -1.1218086481, -0.6666117311, -0.0279057231, -0.4583903849, -0.3935071826, 0.0208693761, -0.1653907597, 0.0417160168, -0.0145217292, 0.0929893032, -0.0483512618, -0.5215678811, -0.6102191806, -0.0247319452, 0.0212020203, -0.6368321180, -1.3872393370, -0.0958837271, 0.0204810277, -0.1887870729, -1.5697121620, -0.0574898422, -0.1794788539, 0.3562482595, 0.0001019349, -1.2593685389, -0.4755551219, -0.0081475526, 0.0622075275, -0.0020501865, -0.0327357166, -0.1381117851, 0.6082412004, -0.9196313024, -0.9115028381, 0.9922717214, 0.0220603738, 0.7087724209, -0.1779295802, 0.2264858484, -0.0214400645, 0.0128203332, 0.0636371672, -0.7405586243, -0.1257081181, -0.0380512998, 0.1125645414, 0.0069608553, -0.0847640559, -0.2777622640, -0.1367926002, 0.0557943359, 0.0575737990, -0.1466063112, -0.4323546290, -0.1761368066, -0.1380602568, -0.0028630069, -0.0073270374, 0.0088861557, -1.9496446848, -0.8612250686, -0.0492325202, -0.6129701734, 0.0079225665, -0.0726888105, -0.1004721746, -0.1223377436, 0.0646003485, -0.8918657303, -0.0819241628, -0.1113566980, 0.1182703674, -0.0519575253, -1.4971014261, -0.1199941933, -0.3656684160, -0.0363418274, 0.1746160090, -1.1655704975, -0.1309524029, -0.0250449870, -0.5704953074, 0.0961156413, -1.1776814461, -0.0943166316, -0.0614928566, -0.6561542749, 0.0427316166, -0.0106539326, 0.6212288737, -0.5407676697, -0.0420958623, -0.1586593240, 0.3231931627, 0.0666164011, 0.0370901711, 0.0929510668, 0.3218248487, -0.6355633736, -0.0076038409, -0.1025707945, -0.4663289189, -0.4396109283, 0.0263388492, 0.1065387577, -0.0103642624, 0.0996267498, 0.1071319059, 0.1680610329, -0.1018914804, -0.1397494823, -0.0705953389, -0.2417542189, 0.3209308684, 0.1005571932, -0.0487397425, -1.1214486361, -0.1705663949, 1.1350253820, -0.4790746570, -1.3972322941, 0.2716324627, -0.0888484567, -0.1706647277, 0.0062782587, 0.1460804790, -0.3826998770, -0.0702537298, -0.3690344691, 0.3991546333, 0.0632188916, -0.2876307368, -0.0327854902, 0.3109455705, -0.2572619915, -1.3723468781, -0.1758302003, -0.1097121462, -0.2785887420, -0.4285728335, -0.0758202523, -0.4433948398, 0.0045265215, -0.2262721658, -0.0559256710, -0.0989131853, -0.0533081517, -0.1016336083, 0.3207280934, -0.0752583817, -0.0925061181, -1.2271077633, -0.8978632689, -0.0288621094, -0.0865127370, -0.1290526390, -0.1468054801, -1.0016099215, 0.1113777682, -0.3229648471, 0.0047693951, 0.2521720231, 0.0598477609, 0.0152864913, 0.0180501789, -0.6017503142, 0.0261048041, -0.0655524656, -0.0255095437, -0.5223385096, 0.1161295399, -0.1016620919, 0.0351441354, -0.5437579155, 0.1352107525, 0.0712654069, 0.0704418868, -0.1624817997, 0.1988124102, 0.0507834665, -0.3317849338, 0.2267224193, -0.3762864172, 0.0713860616, -0.0831234306, -0.0577011220, 0.0026223096, -0.7736815214, -0.1600856930, -0.1766687483, -0.5869226456, -0.1887969375, -0.3608273864, 0.4698554277, -0.4109825194, -0.2922218442, -1.1384065151, -0.0778238773, -0.0593792610, -0.1704439968, 0.0748085603, -0.1283402592, -0.0065675760, 0.8133723140, -0.1888575852, 0.1048924699, -0.1336228848, -0.3074486256, -0.0911822915, 0.8663892150, -0.3249769211, -0.5135364532, 0.6615693569, -0.1707731187, -0.1625903696, -0.0398732498, 0.0491008572, -0.5846372247, 0.1112562642, 0.2844801247, 0.0979356766, 0.0566246249, -0.0888853073, -0.0407782644, -0.2108248919, -0.1413364708, -0.5285359025, 0.0005152112, 0.0153266387, -0.0828882083, -0.0424599946, -0.1334341913, 0.5909332633, -0.4654269218, -0.1386277080, 0.0352126807, -0.1264772266, -0.0313847810, -0.1972716004, -0.5782246590, 0.0131862564, -0.3194000721, 0.0020707482, 0.0759501234, 0.0457110256, -0.5177960992, -0.0941005126, -0.7556060553, -0.7412088513, -0.1634076834, -0.0635562614, -0.1494653821, 0.0272307657, -0.0816843063, -0.1426020116, 0.7556987405, -1.0556229353, -0.1402743757, 0.1373380721, -0.4889568985, 0.1318382472, -0.4003887177, -0.0494263656, -0.0923072845, -0.1438005716, -0.1112050191, 0.2766149342, -0.0745904967, -2.1343317032, -0.0002932923, -0.2806516290, -0.4252217710, -0.0631425083, -0.0351808444, -1.7762677670, 0.5212143064, 0.0081541426, 0.4654310644, -0.1190392300, -0.0574927405, -0.7352294922, 0.0026057218, -0.0068456875, -0.0750254020, 0.0097662639, 0.0505081825, -0.2053897679, -0.0108917411, 0.8658671975, -0.9825204611, 0.1216315031, 0.0045600953, 0.8162961006, -0.0386399813, -0.4154838622, -0.0093489112, -0.0610190853, -0.0450055972, 0.2364951670, 0.4970886111, 0.0536628067, -0.0312383249, 0.0098148445, -1.1815873384, -0.1619185358, -0.0005470564, -0.1284269840, 0.4516066015, -0.1335003972, -1.4601532221, -0.1130447388, -0.4289202690, 0.1180779636, -0.0809412822, -0.0086632017, -0.0664262474, -0.2421945632, -0.0424434692, 0.3407025635, -0.0304279719, -0.1265209466, 0.0434150472, -0.4103396833, 0.0981527269, -2.4125282764, -0.0589088723, -0.0002560920, -0.1468058825, -0.1583607942, -0.4775225222, 0.6040982008, -0.4159025848, -2.1700277328, 1.0648206472, 0.4469560683, -0.0716973990, 0.0171442050, -0.2994524240, -0.1180507019, 0.1745260358, -1.3373740911, -0.3154115379, -0.6951543093, 0.0125805540, -0.0013941273, -0.5235725045, -0.1470858306, 0.0562792458, -0.1115618050, -0.0635107681, -0.0042257877, 0.0322444253, -0.0725607350, -1.2116416693, 0.0971626043, -0.0162519366, -0.0448599756, 0.2320917249, 0.3413024545, -0.0055585215, 0.0318796784, 0.0086657722, -0.1305109560, 0.3076795042, -0.8984384537, -0.0639415979, -0.0259428211, -0.0092908619, -0.1878598481, -0.2953632474, -0.5392451286, -0.0371667221, 0.0198372677, 0.0564110205, -0.1584638953, -0.2588369250, -1.1263086796, 0.1701867580, 0.5047441721, -0.0522782765, 0.0816161260, 0.0618949570, -0.3257476985, -0.1359712780, -1.8731347322, -0.0287424512, -0.0258891042, -0.3211885393, -0.0693315268, 0.8806543946, -0.6278802156, -0.0084762583, -0.2060250938, -0.1466040164, 0.2658111751, -0.0612934753, -0.0172240213, 0.4601571262, 0.0014303089, -0.7309499979, -0.0287509672, 0.0944735631, -0.1237549335, 0.0271621887, -0.2526891828, -0.0956733823, 0.0341477990, -0.3642218411, -0.7874869108, -0.0064802105, -0.2167696208, -0.0267766360, 0.0626640171, -0.2974150181, 0.4812176228, 0.3312936425, 0.0137763824, 0.2902974188, -0.1712832153, -0.0990045220, -0.0053596688, -0.1326513886, -0.6638173461, -0.4206636250, -0.1508741230, 0.0315296389, -0.1374114901, -0.1349095255, 0.1871358007, -0.1354194283, -0.0502015129, -0.0326854549, -0.0873455703, -0.0026117885, 0.3159833848, 0.0183305480, 0.2715642750, 0.2992363870, -0.3541236520, -0.0381815359, -0.1561022401, -0.0020480382, -0.1836799979, 0.5908086896, -0.0363423154, -0.0396115780, 0.3342376649, -0.1795375347, -0.3864875734, 0.4672549665, 0.0285767242, 0.0816093758, 0.7083183527, -0.1889211088, 0.1845584661, 0.1938230544, -0.0095961755, -0.0548596159, 0.0147208106, -0.6310883164, 0.0840298012, -0.1545020342, -0.1469118297, -2.3506581783, -0.0655790940, -0.3465346098, 0.0517498776, -1.1082683802, -2.6913602352, 0.0288760923, -0.1106615067, 0.0515551791, 0.0887336954, 0.1037432775, 0.1967285872, -0.0062188576, -0.2423485368, -0.1917060167, -0.0542586558, 0.0021889955, 0.1161691844, -0.1131047234, 0.1201490238, -0.0117675541, -0.2726553977, -0.0116364323, 0.1547065824, -0.1169779673, -1.3939552307, -0.0589460470, -0.1820956171, -0.0094768815, 0.0056355991, 0.0391191356, -0.0133498730, -0.3192918301, 0.0065233088, -0.3875637949, -0.0000999319, -0.0439555384, 0.2706474066, -0.1666706949, 0.0339924991, -0.0753776878, -0.1063563973, -0.0449179411, 0.0815071985, -0.2306817770, 0.2346925139, 0.0522876680, 0.0710544810, 0.0408302918, -0.0860265493, -0.0470725149, 0.4065280259, 0.1898406744, -0.0144284097, -0.0617930256, -0.1277348399, -0.1248207986, -0.0005280511, -0.4492993951, 0.0274613332, -0.0735547990, 0.2412869781, 0.1144014373, 0.2314598709, -0.3431237936, -0.0996008515, -0.1002017111, -0.1109687462, -0.6107981205, -0.0543601476, 0.3238855004, 0.0916703045, -0.0906374156, 0.7063577175, -0.0055630491, -0.3176448047, 0.0194411352, 0.0083804876, 0.0280206967, -0.2328691483, -0.6366741657, 0.1792106032, 0.2467651069, -1.1291877031, 0.0335974246, 0.3661363721, -0.2282886505, -0.3007150292, 0.0091976430, -0.1755889952, 0.0222862344, -1.1745700836, -0.0797102824, 0.0104496386, -0.0623745061, -0.0138827292, -0.4632818997, 0.2259839177, -0.0018600380, -0.1890289485, -0.5452311635, -0.1060915887, 0.3529374003, 0.0783406645, 0.1400884837, -0.0928193852, 0.0289476849, -0.0335967913, 0.2055032998, 0.2843154669, -0.1416779160, -0.9961141944, 0.0277396291, -0.0950138047, -0.0356500261, -0.0069704251, -0.2125535756, 0.1114729121, -0.0361329652, -0.1120234951, 0.0496028736, 0.0453553684, 0.1910893172, -0.6240521073, -0.2695930302, -1.0051702261, -0.1836199164, -0.2489611357, -0.0339908823, 0.0618646741, -0.5752412677, -0.3387827277, -2.2284388542, -0.0523998514, -0.1089148521, 0.0381645970, 0.0614059530, -0.0495897084, -0.0387047976, -0.1642673016, -0.0543729924, -0.2955398858, 0.4438335896, 0.0012004619, -0.3005416393, -0.1506095082, 0.6177904010, -0.1860878319, -0.0675918683, -0.2218618840, 0.3503761590, 0.1423441470, 0.0059086420, -0.1861943454, -0.8452568650, 0.1198874712, -0.1173418239, 0.5880314708, -0.1117044389, -0.0999020934, -0.0682974085, -0.0347638093, -0.1585989296, 0.1094527319, 0.0819819570, 0.0413764864, 0.0924827978, 0.1651708931, 0.0738681555, -0.5822179914, 0.0742042139, 0.4508037567, -0.0522196479, -0.1340159178, -0.0317202285, -1.3670444489, 0.0627359971, -1.0486915112, -0.2631547749, -0.0411099829, 0.2691244483, -0.1058366150, 1.0217316151, -0.3363014460, -1.3055019379, -0.0482960939, 0.0654967427, 0.1183935404, 0.1082059443, 0.0537796319, -0.1131878793, -0.1225504279, 0.0021105111, -0.0468049645, -0.0589875281, 0.1053257883, 0.0124560893, 0.0845115483, -0.1108959913, -0.0518373251, -0.1090913713, 0.0828059018, 0.0285286307, 0.0997473300, -0.0081632137, -0.1055441201, -0.0016083419, -0.0478340387, -0.0955917239, -0.1052209735, -0.0490569174, 0.0656046271, 0.1177255809, -0.0395314991, 0.0856447220, -0.0022706091, -0.0875421762, 0.1224715114, 0.0908402205, 0.0869642496, 0.0369655788, -0.0792582035, 0.1142058671, -0.0754293203, -0.0033973455, -0.0413632691, 0.1111540198, -0.0120394826, -0.0993191600, -0.1230889857, -0.0104350448, -0.0864634812, -0.0599964857, 0.0819694698, -0.0121802688, 0.0601573586, -0.0862368345, 0.0365616381, -0.0077366531, -0.1237128973, -0.0061806440, -0.0666812360, -0.0516020954, -0.1066133678, -0.0659942329, 0.0821022093, 0.0843894780, 0.0442105830, -0.0903215110, -0.0377629697, 0.0959236920, 0.0606231093, 0.0490437150, -0.0492193401, -0.0565449297, 0.0650134981, 0.1023024023, 0.0021709204, -0.1050570011, 0.0459042490, -0.0797139108, -0.0581071675, -0.1095306873, -0.0344742239, -0.0074174404, -0.0372584164, 0.1134082377, 0.1069533527, 0.0270303488, 0.0023834705, -0.0571058095, 0.0273708403, -0.0858826935, 0.0713445842, 0.0253072977, -0.0048893690, -0.0407081544, 0.0042417347, 0.0750584602, 0.1194835603, 0.0295005739, -0.0818250775, -0.1034508944, -0.0855093300, 0.0255449712, -0.0391798317, 0.0249298513, -0.0295372903, 0.1208360791, 0.0266705751, -0.0516393185, -0.0226047635, -0.0830754936, -0.1066429913, -0.0296224654, -0.0087004304, -0.0342362821, 0.0936236382, 0.1025458574, 0.0667395890, -0.0443020761, -0.0258822739, -0.1110803783, -0.0143603086, 0.1245073378, 0.0951348543, 0.0928021967, -0.0815814734, -0.0913830698, 0.1011629105, -0.0633903742, -0.0669132173, 0.0634833872, 0.0792699158, -0.0477133691, 0.0484375358, -0.0505616367, 0.0043576360, 0.0123637617, -0.0200041831, -0.0945276618, -0.0724692345, -0.0076948404, 0.0086360574, -0.1077736318, -0.0744957030, -0.1063932478, 0.1199690998, 0.0327743292, 0.0188408196, -0.1154508889, -0.0012119710, 0.0016354620, -0.0647278130, -0.0269254744, 0.0348452926, -0.0492118895, -0.1108883023, -0.0627304614, 0.0672377348, -0.0106754899, 0.0371790230, 0.1068345606, -0.0914411247, 0.0641510189, 0.0481984615, 0.0555067956, 0.1054786146, 0.1069703698, -0.1132100523, 0.0045427680, 0.0666425228, -0.0299810469, -0.0862517655, 0.0379360914, 0.0278265476, -0.0059858561, 0.0807109773, -0.0064491928, -0.0170188844, -0.0344171822, -0.0432967842, -0.0860926509, 0.0543881953, 0.0936093330, 0.0065530539, -0.0303069949, 0.0083026588, 0.1071885824, 0.0683736205, 0.0385167301, -0.0846377909, -0.1156701744, -0.0692503750, 0.1242853999, 0.1176464856, -0.1151697338, 0.0019988418, -0.1185790002, 0.0807368457, -0.0854428113, 0.0486896038, -0.0497555733, -0.0817143917, -0.0318180621, -0.0436451733, 0.0449711680, -0.1232765913, 0.0882946849, 0.0117840469, 0.0057775974, -0.0359444320, -0.0491074920, 0.0973204076, 0.0153759122, -0.0067627430, 0.0064624250, 0.0682198703, 0.0558766127, 0.0649529696, 0.0064839721, 0.0134806931, 0.0366588533, 0.0665733814, 0.0282672346, 0.1023501456, 0.0315507948, -0.0296685100, 0.0339588523, -0.1092310846, 0.0219790041, -0.1024401486, -0.0351366997, 0.0884763598, 0.1098869741, 0.0890921354, -0.0615282357, -0.0178875625, -0.0945348144, 0.0910113752, -0.0659346282, 0.0788311064, 0.0609500706, -0.0753309131, -0.0566539764, 0.0076604784, 0.0482242703, 0.0130092800, 0.1161895692, 0.0900380015, 0.0375970900, -0.1138501763, 0.0291776657, -0.0884681940, 0.1132427454, 0.0366985202, -0.1031456590, 0.0488226116, 0.0035770535, 0.0800309777, -0.0745343268, -0.5426774025, -0.0746077076, 0.1005836129, 0.1201300621, 0.0457087122, -0.1221667975, -0.0845900774, -0.1322904080, 0.1555733383, 0.0133658452, -0.0038649670, -0.1415149868, -0.0872571394, -0.0178928673, -0.0371633917, 0.2277972549, -0.0250727497, -0.0242761858, -0.2214742452, -0.0394205116, -0.1442792118, -0.2924505174, 0.0848011822, -0.0795095637, 0.0529502034, 0.1805534512, 0.0342591107, -0.0582616329, 0.1399836689, -0.0811325982, 0.0205168966, -0.0861597210, -0.0380241610, -0.3684434593, 0.0124607328, -0.1473696381, -0.5477386713, -0.1013826877, -0.1730801314, -0.0182094797, -0.0298280697, -0.0366533361, -0.5052203536, -0.1368699521, 0.0690570399, 0.1384973824, -0.3315630853, 0.0328815840, 0.0325398110, 0.1390881240, -0.0424938239, -0.0913485140, -0.0836327896, 0.0645963475, 0.0214752760, -0.0540234782, -0.0396205336, 0.0232575685, -0.0067893756, -0.7994036078, 0.1481300294, -0.0927267075, -0.0513302833, -0.1807818711, 0.0843570828, 0.0906362161, -0.0317754336, 0.0482470989, -0.2767172158, 0.1078099906, -0.2844859660, -0.0195401497, 0.0914512873, -0.0822203085, -0.0817280114, 0.0187941529, -0.0184867010, 0.1141379774, -0.0631686747, -0.3930678666, -0.0783236623, -0.3631311059, 0.0853616744, 0.0096771177, -0.0415238924, -0.1463244855, 0.1152187884, -0.4580169022, -0.1090840697, -0.1444095522, 0.0472253002, -0.0091433525, -0.0866583064, 0.0474056900, 0.0025119355, -0.0616501570, 0.1355997771, 0.0558989346, 0.1604717821, -0.0248874929, -0.1657934338, 0.0629334450, 0.0591697618, -0.4693914056, 0.0466301925, 0.0075613749, -0.2128466964, 0.1264223307, -0.0539961606, 0.2994297147, 0.0004750788, -0.6747776270, -0.0235951710, 0.0716953576, -0.1848573387, 0.3839586675, -0.0307292640, -0.6491571069, 0.0556367636, 0.0528132394, -0.2589725852, -0.0317491591, 0.0657480732, -0.0335930213, -0.2328419685, -0.1006590128, -0.0576224625, 0.0451843515, 0.0400122143, -0.1239070520, 0.0416129492, 0.0296068154, -0.1256339550, -0.1726277620, -0.0669395998, -0.2716168463, -0.0386334211, 0.0147370854, -0.0239412542, -0.2687463760, 0.0864076018, -0.2056089491, -0.4066076577, -0.0043383767, 0.0501001589, -0.1554291099, 0.0638575256, -0.0648297369, -0.0204392802, -0.0774396956, -0.0191112421, -0.1576390117, 0.1362408400, 0.0933065191, 0.1000731364, -0.1256028116, 0.0123223793, 0.0756975859, 0.1813725233, 0.0214860439, 0.0525507331, 0.0371693373, -0.0866316259, -0.0090714982, 0.0223624147, 0.0900943652, 0.0728872716, -0.3268615007, -0.3395818472, -0.0662169755, -0.0310555249, 0.1069483981, 0.1242156401, 0.1378931999, -0.0652737394, -0.7064730525, -0.1701124310, 0.0288829971, 0.0396814048, -0.2535516620, -0.2478916198, -0.0223544277, 0.3808023930, -0.0512109883, 0.1129349768, -0.0813722387, -0.0915267766, -0.0531220287, 0.0999444053, 0.0494238101, -0.0373151600, 0.1104623377, -0.1064307392, 0.0968348831, -0.1636846513, 0.1036154032, 0.2659411728, -0.1317825317, 0.0881808102, 0.0526246019, 0.0392758548, -0.0854989588, 0.1257345974, 0.0938481763, 0.0554773882, 0.2009020895, -0.2615163028, -0.1155671179, -0.0089412797, 0.1228404343, 0.0111306068, -0.0360762738, -0.0001887677, 0.6529363990, 0.0286983550, -0.1019871607, -0.0106223654, -0.3985835314, -0.3184936345, -0.0075871050, -0.0790346786, 0.9165786505, 0.1905661821, -0.0728555769, 0.1020045951, -0.0864288956, 0.1101990566, -0.0535354689, -0.1321908981, -0.1117815971, 0.0690665245, 0.2047403306, -0.0438251831, 0.0013472436, -0.1319657117, -0.0214260444, -0.3525744379, 0.4580127299, 0.4264343977, -0.1472482681, -0.0469429977, 0.3980085254, 0.0625335574, -0.0404335707, -0.1352973431, 0.1017948166, 0.1044678763, 0.0397960842, 0.1393832862, 0.0619479194, 0.0292938482, -0.2210800052, -0.4129918516, 0.0126725705, 0.1017525122, 0.0956415609, -0.0744267330, -0.0441325307, -0.0164129585, 0.0285256505, 0.0927632526, 0.0130011896, 0.0238810759, 0.0788047314, 0.0156665016, 0.0236564018, 0.0194548927, -0.0104888529, 0.0224695224, 0.0644651353, 0.0324106030, 0.1009547710, -0.0673014820, -0.1470408589, -0.0565658808, -0.0493850037, 0.1095612943, 0.1002683789, 0.1061499566, -0.0288976785, 0.0365624987, 0.0793714598, 0.0251807440, -0.0630218014, 0.0768200830, -0.0225079302, 0.0378402956, 0.1024910063, -0.1408438981, -0.0836720914, 0.0057915836, 0.0181996431, 0.0285187550, 0.0906535909, 0.0030015891, -0.0299762674, -0.1064951122, -0.0641062781, 0.0453945957, 0.0786271840, -0.0475236736, -0.1133332327, 0.1039587334, 0.0725672692, 0.0950665697, -0.1220716536, 0.0052585839, 0.0073782746, -0.0419619083, 0.1135003492, -0.2227986604, 0.0913131237, 0.0132968556, -0.0412368067, -0.0681416169, 0.1418491155, -0.0724103600, 0.1010956541, -0.0016239787, -0.0368309245, -0.0160605069, -0.0139849186, 0.0956492573, 0.0398928337, -0.0354687497, 0.0326723903, 0.0207781605, -0.0126800751, -0.0881603956, 0.0405773558, -0.0920942128, 0.0539419092, 0.0377385765, -0.0741843432, 0.0823872983, -0.0057063028, -0.1171769500, -0.0021771865, -0.0202578027, -0.0467834100, -0.0518482178, -0.0853792727, -0.0568692684, 0.0834331661, -0.0094328597, 0.0464152023, 0.0781888515, -0.0976964831, 0.0088689541, 0.0460021943, 0.0743100420, -0.0929549038, -0.0819821879, 0.0797459483, 0.0708858222, -0.0000546853, -0.0242418945, -0.1169243157, -0.0509404987, 0.0185340587, 0.0848553181, 0.0313150547, -0.1056227684, -0.0346921049, 0.0247741323, 0.0240674913, 0.0442706048, 0.0531020314, -0.0680063590, -0.0911438763, 0.0480563641, -0.0077160932, -0.0110905105, -0.0640872866, 0.0587436147, -0.0127780996, -0.1295255721, 0.2269273698, 0.0870658159, 0.0573972911, -0.0003920014, 0.0879433081, 0.0577457249, 0.0270826127, 0.0023673677, 0.0998202413, 0.1245795414, 0.0229021478, 0.0260488354, -0.0688604340, 0.0245012045, 0.0270020273, -0.0309804659, 0.0078377463, 0.0845815092, -0.0111896964, -0.0309282597, -0.1651348174, -0.0940529481, 0.1325204670, 0.0470093489, 0.0041960902, 0.0604224838, -0.0830939710, 0.0422697552, 0.1006811559, 0.0187541600, -0.1243101880, -0.0778149292, 0.0655974895, -0.0414443314, -0.0030712790, 0.0165298227, -0.0510237850, -0.0046317535, 0.0156859159, 0.0811276436, -0.0659353733, 0.0799072161, 0.0239021257, 0.0653138086, -0.0053397906, 0.0390014686, 0.1586740613, -0.0208958611, 0.1004579291, 0.0337770507, -0.0104227979, 0.0526958555, 0.1073573753, -0.0553549342, 0.0753107592, -0.0438110605, 0.1077028885, 0.0481432825, -0.0450901538, -0.0113895312, -0.0523646735, 0.0046215388, -0.1158859432, -0.1552896351, -0.0472325236, -0.0134006841, 0.0916363746, -0.0444503725, -0.0873199627, 0.0585203171, 0.1106555760, 0.0244919658, 0.0545835830, 0.1033158973, -0.0288045071, 0.0746070445, 0.0894959494, -0.1254392117, 0.0659315437, 0.1024294794, -0.0319419093, 0.0255419966, 0.0075395773, -0.0928635523, -0.0634397864, 0.1200893894, -0.0084734038, 0.0975736752, 0.0189707596, -0.1217616051, 0.0133840451, -0.0873340890, -0.0614721142, 0.0195726156, -0.0925553814, -0.0370991416, -0.0408723205, 0.0140455384, -0.0858078301, -0.0996758118, -0.0234321710, -0.0815219060, 0.0111320382, -0.0440556332, -0.0664615855, 0.0407696664, 0.0590485074, -0.0398513004, -0.1067707539, -0.0368930735, -0.2079255730, 0.0271159597, -0.0938997790, -0.0016846120, 0.0212805811, 0.1203854084, 0.0452973396, 0.1661312878, 0.0174817313, -0.0822504535, -0.0373965465, -0.0038001842, 0.0462537967, 0.0241918564, -0.0795710981, 0.0808060169, -0.0920356810, -0.0804315880, 0.1018020883, 0.0909081697, 0.0101483781, -0.1769711226, -0.0821249783, 0.0221528150, 0.0085412301, -0.3927339315, 0.0266221445, -0.4628235400, -0.1530546248, 0.0934733897, 0.1947654635, -0.0098483618, -0.3068062663, -0.0914691538, 0.0472573899, -0.0511724576, 0.0246120486, 0.2619313002, 0.0481378287, -0.0222348459, 0.1323636472, -0.3851136267, 0.0143925296, 0.0399821699, 0.0016626078, -0.0574943908, -0.0249276310, 0.3040754199, -0.3024415672, 0.0124259144, 0.0575273260, 0.1303307861, -0.0818917304, -0.0823356733, 0.0997449756, -1.0314555168, 0.0116488505, -0.0911146849, -0.0363868549, 0.0582999550, -0.3285290301, -0.0786375254, -0.7287714481, -0.1976502836, -0.0165519789, -0.1217095554, -0.2301149070, 0.1684626788, 0.0557556935, 0.1661078036, -0.1679143459, -0.3657162189, 0.0699463040, -0.0092652766, -0.0633647218, 0.0319248401, -0.3777405918, -0.2507824898, -0.0232715104, 0.1594839841, 0.0201853178, -0.4267710447, 0.2671076059, 0.3453076184, -3.4157001972, 0.1436997205, 0.0377256125, 0.1989869773, -0.0273607094, -0.0903799981, -0.0812337026, -0.0067813648, -0.8328094482, 0.0918189660, -0.0695754737, -0.0849993825, 0.0628369451, 0.0136429602, -0.4688199162, -0.0471230075, 0.0193115883, 0.1542000026, -0.1645084023, -0.1638558656, -0.0049884785, -0.0823319554, -0.3009563386, 0.8445904255, -0.1198088080, -0.0930641592, 0.0165738687, -0.1301247925, -0.0241822582, -0.8982110023, 0.0173862707, -1.2054492235, 0.0447508916, -0.0402331650, -0.0911148936, -0.0088425064, -0.0412649512, 0.3635863662, -0.7531942129, -0.0114871562, 0.0248421524, -0.0015519819, 0.0276264977, 0.0187789276, 0.2281268686, -0.0075118337, -0.3853856027, -0.0150868027, -0.1295576394, -0.3256965578, 0.2013255805, 0.0314448848, 0.1160565093, -0.5756230354, 0.0027165068, -0.0239768308, 0.2550378442, 0.0172769744, -0.0262575708, -0.1339897960, -0.4520619214, 0.2504059076, -0.1111718118, -0.7804588675, -0.2472923100, -0.0283680297, 0.1583007127, 0.0290542524, 0.0800331831, -0.0112907635, -0.3843568265, 0.6515759826, -0.0471027717, -0.4654542506, -0.1790224016, 0.4800177515, -0.3326645195, 0.0066965888, -0.1063212231, 0.0666966438, -0.7829698920, -0.0649666786, -0.1614229977, -0.4220474362, 0.0608146228, -0.7134734988, -0.0866876096, 0.0035708656, -0.0752789602, 0.0004346368, -0.1514176875, -0.1104867756, -0.6044850945, -0.2120375782, 0.5495882034, -0.4199539721, -0.1053258628, -0.4940877855, 0.0199149083, -0.7842290401, -0.0035286616, -0.1323699802, -0.0465307236, -0.3989105523, -0.8794828057, -0.0030770507, -0.0754285529, 0.0201625489, -0.0238488913, 0.1373484880, -0.0065045385, 0.0442878082, -0.0935685113, -0.0147413695, -0.1239474490, -0.5383179784, -0.2465938330, 0.0080158720, -0.1021137536, -0.1275937855, 0.2869955301, -0.2587585747, -0.0832278952, 0.3904772103, 0.0071336790, -0.1619049162, -0.0340263508, -0.0066347760, -0.0287057888, -0.0103876609, -0.0969593078, 0.0232700221, -0.0991872996, -0.1506380588, 0.0191032980, -0.4940540791, 0.4959247708, -0.1518703550, -1.0131202936, -1.2108445168, 0.0271761250, -0.0765548348, 0.0584775247, -0.1419862509, -0.0585571565, 0.0910123512, 0.1877279729, 0.0400073044, -0.0837627500, -0.0243438073, 0.6243105531, 0.1291879267, -0.2867730558, -0.2047901899, -0.2186504304, -0.0402346142, -0.2032153755, -0.1200535223, 0.0872238427, -0.0549844317, -0.1421567798, -0.0405145288, -0.5945904255, 0.3208284974, 0.0311988983, -0.0756727532, -0.1698744744, 0.0259539559, -0.3485228717, 0.2024720609, -0.0522852577, -0.1352666616, 0.0469222330, 0.0098890690, -0.4850821197, 0.3747446835, -0.1978565454, -0.1321645826, -0.1325617582, 0.1551909149, -0.0669552609, 0.0689103752, 0.1858368963, -0.4112247825, -0.0689898878, -0.0344789177, -0.2082069218, 0.0087882895, -0.0333652496, -0.0706717074, 0.1252452880, -0.0421451293, -0.1623938382, 0.0263287537, 0.5874077678, 0.0305741895, -0.8664806485, -0.7561339140, -0.0124001009, -0.4747649133, -0.1442995816, -0.1848155707, 0.2130253017, 0.0202830825, -0.9694885015, 0.0205981508, -0.0472090058, -0.0416906178, -0.0186875630, 0.1507208943, -0.0839551017, -0.1163351238, 0.1939960420, 0.7421707511, -0.0167976208, -0.0592840761, 0.0132610220, -0.3641292453, 1.2954950333, -0.2586370111, -0.3617472947, 0.0017775071, -0.3517743349, 0.1756052226, -0.0363747813, -0.1272596568, 0.1269992143, -0.2544349432, -0.3461620212, 0.0243850518, -0.3822062910, -0.0045643118, 0.4423080981, 0.2678546309, 0.7581441998, -0.1102421656, 0.0348791331, 0.0243053194, 0.2333701253, 0.6974562407, -0.1040988490, -0.3061469495, -0.1780663729, 0.3931390643, -0.0495207831, -0.1104594171, -0.0541191995, -0.0546044372, 0.5720048547, 0.1677738279, -0.0014185341, -0.1753196269, 0.2981012166, -0.1885856390, -0.9478258491, 0.0294329096, -0.6518326402, 0.5974231958, -0.1277298629, 0.0262918733, -1.7062623501, -0.0265355296, -0.0309057776, -0.0098810950, -0.1249357164, 0.3618246019, 0.0167407468, -0.1918965280, -0.9361844659, 0.0157578290, -0.9102439880, 0.1325138956, 0.2707153559, -0.6267832518, 0.0365012176, -0.0009471313, -0.1092082113, -0.1384522468, -1.1837407351, 0.2336861342, 0.1374818236, 0.1527420133, 0.1192037165, 0.0014087260, 0.1482489407, 0.5428051353, -0.0085027181, -0.6950387359, 0.0902957171, -0.0174964312, -0.0918942839, -0.1056770906, -0.1012343988, 1.0972658396, 0.3620841801, 0.0148224412, 0.0030635302, -0.4075066149, 0.0388173498, -0.0943846405, 0.4309185445, 0.0628412440, -0.9769923091, -0.0019293363, 0.0056385407, 0.1035684422, 0.7318405509, -0.0156208016, 0.5071452260, 0.8829430938, 0.0302446373, 0.2012855411, -0.0229498837, 0.8372223377, 0.1306733489, -0.1499628425, -0.2926052511, 0.1512610018, 0.1106570810, 0.6255823374, 0.1016605943, 0.0747996643, 0.8414446712, -0.0489623062, -0.0580916442, -0.3324693143, -0.1405862421, -0.7384433150, -0.1891671121, -0.0196085144, 0.3158366084, 0.6893698573, 1.6310681105, 0.0194802079, -0.1467276365, 0.6823351979, -2.3351008892, -0.1249627024, 0.3530070484, -0.0592914596, -0.5196524262, 0.2760204971, 0.2130961567, -0.0952777416, 0.0053560548, 0.0056937793, -0.0462155603, -0.0134695955, -0.0938936546, -0.0639249757, -1.3987326622, -0.4057427049, -0.1671680063, -0.7681933045, -0.0694873706, 0.8065111637, -0.0247440729, 0.0247224979, -0.0238625370, 0.4758217633, 0.0380932763, 0.0702250972, -0.0276228618, 0.0383492000, -0.6612787247, -0.0836952627, -0.0015903175, 0.0116368895, -0.4452650249, 0.2227685750, 0.2465994954, -0.3247801363, -0.2788303196, -0.0358645394, -0.0805388018, -0.0503672771, -2.1824860573, -0.5359273553, 0.0145310806, -0.7464786768, -0.0786470175, -0.0856872052, 0.0588789694, -0.2315928191, 0.0423565991, 0.2022262812, 0.0315116197, 0.0515252911, 0.0371792018, 0.0052711754, -1.3136200905, -0.7304646969, 0.0158107132, 0.6371722221, 0.2080622315, 0.5299036503, -0.0340826698, -0.0942686275, -0.1656876057, 0.3560061455, 0.7234255672, -0.0611515045, -0.5916346312, -0.1188621745, 0.0201129951, 0.0073636943, -0.6744487286, 0.0172043461, -0.0920394808, -0.2657660544, -0.8085672855, 0.0891364962, 0.2234840244, 0.0100867171, -0.8014181852, 0.1127508059, -0.0564362146, -0.0272935983, -1.6944742203, 0.5255383253, -0.0150055643, 0.0092167193, 0.1167808250, -0.1597620845, -0.0872811079, 1.0612047911, 0.0111375740, -0.0524481945, -0.0208509434, 0.1608688831, -0.2686142623, 0.4914143384, -0.0400520042, -0.8254699707, 0.1346460432, 0.1474226266, 0.5140402317, -0.3225092292, 0.0195964295, 0.1794103682, -0.2283494174, -0.0728596523, 0.0221329350, -0.6642618775, -0.1457263976, 0.3833649755, 0.2917405963, -0.0244126394, -0.1734346896, -0.0311763156, 0.1225317717, -0.0265677944, -0.1401430368, -0.0323546082, 0.0707475096, -0.2083872110, 0.1955787390, -0.1046198085, 0.0235877503, 0.0011445783, 0.1042175218, 0.1126403809, 0.1261556000, 0.1104158014, 0.0189720057, 0.0857340693, 0.0986711383, 0.0904581100, -0.0245046429, -0.1076160818, 0.0527005047, -0.0326625369, -0.1024152115, -0.0937885195, -0.0040509426, -0.0944729373, -0.2130571306, -0.1066333428, -0.0250233449, 0.0356872901, 0.0358684100, -0.0546609610, -0.0563219860, 0.0322283059, 0.0550695658, -0.1385343373, -0.0838354230, 0.0705573037, -0.1183306128, -0.0537431836, -0.0747274309, -0.0033293089, 0.0387333632, -0.0290117506, 0.0852576047, 0.1167982668, 0.0838223472, 0.0310151577, 0.1311550438, 0.0574257113, 0.0528345704, -0.0286656506, 0.0243893526, 0.0032283012, 0.1384421140, 0.1128068790, 0.0237247199, -0.0421805345, 0.0627499595, -0.0694543570, 0.0637837127, -0.1230360940, 0.0774291009, 0.0575267002, -0.0357298106, -0.0831864700, -0.1103071645, 0.0991555154, 0.0650768280, -0.0003589501, 0.1353123784, -0.0992483124, 0.0275703967, 0.1109171733, 0.2710584402, 0.0419224836, 0.0510992855, -0.0036983860, 0.0786328614, 0.0298753995, 0.0573883653, -0.0370545089, -0.0235327892, -0.1118239239, -0.1041006520, -0.0556928366, -0.0047321208, 0.0941368788, -0.0673876479, 0.0151283145, 0.0085419631, 0.1440413892, 0.1233369857, -0.0627743527, 0.0258571524, -0.1035342738, -0.0017477572, -0.0736351758, 0.0246115923, -0.0374833271, 0.0253537428, 0.0589989908, -0.1043783650, 0.1305018961, 0.1495351642, -0.1181504875, -0.0977354497, 0.0185468327, -0.0462810025, 0.1226980388, -0.1027998626, -0.0296100341, -0.0136484597, -0.0562082678, 0.2026468068, 0.0961828902, -0.0715015456, 0.0866207629, -0.0414305516, -0.1173606068, -0.0977931097, 0.0951015055, -0.0392785370, -0.0791939497, -0.0808011293, 0.0613078810, -0.0423120931, 0.0902883857, -0.0774614438, -0.0386505537, 0.0956010520, -0.0625596792, -0.0629186481, 0.0902786329, -0.0171395000, -0.0631085411, 0.0734563321, -0.0305807833, -0.0530486964, 0.0069458317, 0.1343851388, 0.0281368066, 0.0514740199, 0.0654323623, 0.1272078454, -0.0564377196, 0.1336449236, 0.0630317479, 0.0161001999, -0.0267244224, -0.1038668230, -0.0869735703, 0.0627376139, -0.0645899251, -0.0661775842, 0.1053124443, -0.0832592323, 0.0569306388, -0.1281518489, -0.0165350996, 0.1194977537, -0.0462517403, 0.0612406768, -0.0815258920, -0.0243863016, -0.1438483447, 0.0367554240, -0.0306703951, 0.0149979424, 0.1522837728, 0.2310461551, -0.1131860539, -0.0543777719, 0.1171697751, -0.0548173003, -0.0471909121, -0.1596176624, 0.0379090793, 0.0612405427, -0.0103688585, 0.0119136302, -0.0074011385, -0.0028819249, -0.0322754122, -0.1205107272, -0.1191375926, -0.0635010004, -0.0540079810, -0.0506872497, 0.1044725180, 0.0926340371, -0.0094851917, 0.0211600251, -0.0457801521, -0.0268942714, 0.0732844770, -0.0921198130, -0.0662448108, -0.0272227023, -0.1092085615, 0.0559561402, 0.0610309318, -0.0646397993, 0.0142083168, 0.0539884605, -0.0381287076, -0.0806962997, 0.0226356983, 0.0406450778, -0.0179807153, -0.1050228700, 0.0563785806, -0.0325729847, 0.0207572989, 0.0943405181, -0.0986800939, -0.1283521950, -0.0957497656, 0.0016395051, -0.1323167384, -0.0330081694, -0.0341809094, -0.0383594334, -0.1150792912, -0.0002402269, -0.0421196036, -0.0508321263, 0.0640609935, -0.0835224614, -0.0403391346, -0.0773164853, 0.0001965213, -0.0130632818, -0.0815419033, 0.0397159979, -0.0226187054, 0.0641942471, 0.0485925116, 0.1549667865, 0.1236855164, -0.1269069910, 0.0135924043, -0.1123693734, -0.0779866129, -0.1007425115, -0.0387504548, -0.0900931433, 0.0626515001, 0.1225257069, -0.1467050612, 0.0654956326, -0.1219828650, -0.0926842391, -0.0874019042, 0.0857183859, -0.0562397875, -0.0616310798, -0.0019464999, 0.1096697748, 0.1657151282, 0.0212843865, 0.3058711588, -0.3581866324, -0.1812226921, 0.5653872490, -0.0032532411, -0.7008631229, 0.0391168743, 0.0278944355, -0.1636363864, -0.0351192690, -1.1513203382, -0.0917819813, 0.0773154721, -0.0025507575, -1.1723991632, 0.0182068478, -0.1226043180, 0.0477796681, -0.0913254693, 0.2175418884, -0.0752562657, 0.6298766136, 0.0009933817, 0.2557369769, 0.0971605703, -0.0358588398, -0.0900912508, 0.2073809355, 0.0430440307, 0.3695289493, -0.0728867352, -0.2766739130, -0.1295315772, -0.1523075700, 0.0622742325, -0.2298618406, -0.0249545760, -0.1381707340, -0.0359852500, 0.0552848466, -0.0839532614, -0.0160602015, 0.2032057792, 0.2091793865, 0.2681902945, 0.1201034710, -0.0800909251, -0.1062589586, -0.0622431710, -0.5920637250, -0.0255323648, 0.0939025283, 0.2187450677, -0.1073199138, 0.2716948986, -0.7100977898, 0.2358296961, -0.7416911721, 0.2575903535, -0.0039340341, -0.0814378560, -0.1791813970, -0.0556464642, -0.1435203254, -0.0298253763, -0.5835988522, 0.0711673126, -0.0283952467, -0.1200313941, -3.2538259029, -0.1260430664, -0.0456407852, -0.0132642854, 0.6579317451, -0.0082376990, 0.0114469221, 0.0333946943, -0.0181825403, -0.0050775358, 0.6485469937, -0.6189451218, -0.6591526270, 0.1215321645, 0.0504609682, -0.1224147156, 0.1743111014, -0.4144074023, -0.0453360938, -0.2465693951, 0.1114255786, -0.0379660092, -0.1262172610, -0.0091176974, -0.1274667382, -1.1758888960, 0.1926358789, 0.0564990938, 0.0283144824, -1.1281014681, -0.1495640278, -0.2153830230, -2.2270734310, 0.0386258624, 0.3155157864, -0.0251281634, -0.1502214968, -0.7334360480, 0.0857259557, -0.0191187412, 0.0901295245, -0.1343737841, 0.0301810913, -0.0213878639, -0.2649237216, -0.0504355393, -0.1442715824, -0.1152086928, 0.5830419064, -0.0356291495, 0.0384884328, -0.8780478239, 0.4546310604, -0.0613476224, -0.1005427837, -0.2033614963, -0.0628388375, -0.2176797241, -0.2336490005, 0.1921239048, 0.0440578461, 0.1829802096, 0.0289773047, -0.5697792172, -0.0535132326, 0.0367067344, -0.0991878808, 0.2152640969, 0.4715352952, -0.0055478215, 0.2611723840, -0.2592087686, 0.3414870203, -0.6479541063, 0.2598416209, -0.3154687285, 0.0441029407, -0.0106092114, 0.0196425989, 0.0331295691, 0.5319896340, -0.1551895589, 0.4094878733, -0.6078027487, -0.1927572191, 0.7073357105, -0.0997343287, 0.1365209967, -0.0425466150, 0.0532548167, -0.0347635634, -0.0759486929, -0.5056714416, -0.0078138439, -0.0766881406, 0.0296331402, 0.1604659855, 0.0296969358, -0.0603654981, 0.0879908726, 0.2790703475, 0.0130099636, -0.0347274095, -0.3768198788, -0.3970168233, -0.0850351602, 0.1955220252, 0.0491366498, -0.4762796164, -0.2775403559, 0.0879178569, -0.6969289184, -0.0601113401, -0.1375007778, -0.0164341554, -0.2432582676, -0.0109267980, -1.6424195766, 0.0032124957, 0.0688361600, -0.1172470003, 0.0110855019, 0.4471590519, -0.0869087800, -2.5379030704, -1.1327575445, 0.0855437964, 0.1155065000, -0.0518397465, -0.1276812255, -0.1346995384, 0.4589932561, -0.3735024929, -0.0487411879, 1.0753257275, 0.1093717441, -0.0885320231, -0.1035508513, -0.4015292525, -0.0712902024, 0.0098169306, 0.2925987840, 0.3742281497, 0.0840271115, -0.6785420179, -0.0566143766, 0.8370517492, -0.4042927623, -0.0878850892, -0.5018271804, 0.5369299054, -1.1194562912, 0.0470558405, -0.1365864575, -0.1955693960, 0.0591367111, -0.6652689576, -0.2246374637, -0.0984506458, 0.1334958225, 0.0366908535, 0.1993838847, -4.3202867508, 0.0360095464, -0.0289404634, 0.4262057543, -0.0838204473, -0.8276859522, -0.0829088464, 0.8497482538, 0.1542804390, -4.2381997108, -0.1661685556, -0.1415065676, 0.0284286570, -1.0211640596, -0.1746643931, -1.1676166058, -0.2051537037, -0.0328351036, -0.5106047988, 0.0000397556, -0.2206133157, -0.1218533218, -0.2873205543, -0.0954379290, 0.0328158699, 0.0053827446, -0.1399163008, -0.1222345829, -0.0125044668, 0.0864578187, -0.1255819499, 0.0803085119, 0.1342359930, -0.1201973483, -0.1221308932, -0.0700554997, 0.0384676680, 0.0304371174, 0.0190721527, -0.0919978544, -0.0877712741, -0.0777092874, 0.0201779325, 0.0595912337, -0.0447447523, 0.0279020220, 0.1158966199, 0.0764290467, 0.0202577468, -0.0345238224, -0.0303926989, 0.0172253735, -0.0377785601, -0.0667425096, -0.0623909123, -0.0195625201, 0.0258887745, -0.0913842842, -0.0526052862, -0.0014192234, -0.0469064973, 0.0767604560, -0.0845317245, -0.0192475747, 0.0921056718, -0.0323569998, 0.1127599999, 0.0742026120, 0.0490450785, -0.0917773098, 0.0557761714, 0.0057757515, 0.0146081029, -0.0705992579, 0.0942071080, 0.1213127449, 0.0648001358, 0.0983470753, -0.1685563177, -0.0556942485, -0.0538913198, 0.0198375471, 0.0591929294, 0.0528444685, -0.0714309663, -0.0201747846, 0.0399916731, 0.0014984709, 0.0733717233, -0.0656927675, -0.0477355234, 0.0730175897, -0.0741939545, -0.1023666412, -0.1068661511, 0.0406193100, 0.0145528922, -0.1408911943, -0.0609306768, -0.0739203617, -0.0167752933, -0.0786181092, 0.0410678908, -0.0974757820, -0.1316490173, -0.0412325077, 0.0362338498, 0.0784635320, 0.0425199270, -0.0240062680, 0.0082091494, -0.2607027292, 0.0435756184, 0.1544856876, -0.0146311754, -0.1274135262, -0.0818515420, -0.0801295042, -0.0703800321, 0.0660771355, 0.2228157818, 0.0833840370, 0.0768052116, -0.1525679976, 0.0431072041, 0.0038289244, -0.0590912253, 0.0169553012, -0.0348439328, -0.0224964917, -0.0036680626, -0.1077833325, -0.1236032471, -0.0387354605, -0.0901033282, -0.1167267710, 0.0066460613, 0.1148701087, -0.0934377387, -0.1474803537, 0.0056150891, -0.1466291398, -0.0880302563, 0.0578901544, -0.1169637293, -0.0051494921, -0.0214692503, -0.1145240515, -0.0002124012, -0.1467567980, 0.0789721906, 0.0456734523, -0.0648275614, -0.0384418853, 0.0277754478, -0.1485905349, 0.0968618840, 0.0151438545, -0.0377991833, -0.0107161682, 0.0784479827, -0.1218403727, 0.0353757553, 0.0616008490, 0.0348469242, 0.1313759536, 0.0846576169, -0.0819632411, 0.0502456091, -0.0135420738, -0.0413998216, -0.0803942829, -0.0241114963, -0.1130270958, -0.1295308471, 0.1863629073, 0.0344670638, 0.0353532620, -0.0944267139, -0.0598221086, 0.0280439965, -0.1213406995, 0.0862004906, -0.1453475952, 0.0721153095, -0.1635678411, -0.3061017394, 0.0691000074, -0.0246169604, 0.0816391110, -0.0249933079, -0.0760256946, -0.0442759469, 0.0882937685, 0.2380483896, -0.0927989110, -0.0373673961, 0.1061613485, -0.0975784361, 0.0719786286, -0.1264265925, 0.0501782969, 0.0521312170, -0.0694167763, 0.0226927176, -0.0822609812, 0.0273612328, -0.1401221901, 0.1018186510, 0.1426488459, -0.0312944353, -0.0297580715, 0.0078543136, -0.1006517857, 0.0667852387, -0.1064370051, -0.0555290133, 0.1691515744, 0.0947910473, 0.0206449125, -0.1254131943, 0.0352748111, 0.0749327540, -0.0803623348, 0.0382504389, -0.0891869888, 0.0140944934, -0.0578586906, 0.0779364109, -0.1215187088, 0.1097746491, 0.1104258746, -0.0017218270, -0.0448667519, -0.0925861895, 0.0498492196, 0.1230266765, -0.1385581493, -0.0034878543, -0.0688263848, 0.0846805945, -0.1226178259, -0.1103567928, -0.0160619970, -0.0052623441, -0.1688898504, -0.0106059769, -0.0167921372, -0.1190298572, -0.0836096480, -0.0617899522, -0.0328993089, -0.1159862205, 0.0129550435, -0.0233979635, -0.0827874094, -0.2588109374, 0.0590691306, -0.0454715975, 0.0177412834, 0.0738898218, -0.0395740010, -0.0493496284, -0.0298945196, -0.0840436146, -0.0895330012, -0.1034025997, -0.0631929338, -0.0914058164, 0.1235553026, 0.0071238992, -0.4638629556, -0.1218142956, -0.0261454284, -0.1179528236, -0.0727101713, -0.5056463480, -0.0731647462, -0.1654442251, -0.0795511305, -0.0017833114, -0.1136264801, -0.1022846401, 0.0285667479, -0.0855555534, -0.0149963200, 0.0610733032, 0.0033929646, 0.0480071604, -0.0079555213, -0.0658150017, 0.0185174048, 0.0765050650, 0.1237721145, -0.0840603113, 0.1046576798, 0.0003848970, -0.1130598187, -0.0220737755, -0.0611166954, -0.1102521122, -0.0795418024, 0.0342648029, 0.0889460146, 0.1066079736, 0.0122990012, 0.0186039209, -0.1075631678, 0.0706943274, -0.0585163236, -0.0972251892, -0.0305564404, 0.0616793036, -0.0134811699, -0.1014138460, 0.0368993282, 0.0866886079, -0.0872495174, 0.0652568340, 0.0762360990, 0.0389377475, 0.0070658326, -0.0082353354, -0.0919219851, -0.0662156940, 0.1108281314, 0.1066606641, 0.1068631411, 0.0285840929, -0.0672546327, 0.0570984483, -0.1134568155, -0.0069931746, 0.0653359294, -0.0136433840, 0.0484122038, 0.0165175498, 0.0355885327, -0.0158513784, -0.0991045535, 0.0915385187, 0.0360364020, -0.0747675896, 0.0714014471, -0.0447561741, -0.0132161975, 0.0629538596, 0.0090155900, -0.0431466997, -0.0662320256, 0.0396874547, 0.0517684221, -0.0738964379, 0.0842540562, -0.1135467291, 0.0725645721, -0.0833013356, 0.0059273243, -0.1179367900, -0.0946158767, -0.1135814786, 0.1123635769, -0.0309800506, 0.0699061751, 0.0648694932, 0.1211010814, -0.0067740083, -0.0832218528, 0.1214010417, 0.0233496428, -0.0084252656, -0.0488540530, -0.0203725994, -0.1144445539, -0.1233708858, 0.0533279181, 0.0830557644, 0.0669082105, -0.0613611341, -0.0880816281, 0.0640730262, 0.0276284218, 0.1095227599, -0.0326054394, 0.0051621497, -0.0955903232, -0.0090679824, 0.1208565831, 0.0721648335, 0.0792150795, 0.0471152365, -0.0709345043, -0.1014587283, -0.0302371979, -0.0924499035, -0.0707807839, 0.0793263316, 0.0830555856, -0.0438745916, -0.1117632985, -0.1051644683, 0.0297993124, 0.0970904231, -0.0651397407, -0.0809110403, -0.0255145133, 0.0799863636, -0.0255656242, -0.0551345944, 0.0275079608, -0.0292143524, -0.0382394493, -0.0921112597, -0.0265541077, 0.0003359318, -0.0705685914, 0.0116160810, -0.0304099619, 0.0236091614, 0.1174372435, -0.0836180449, 0.0447118878, -0.0544661283, 0.0991223752, 0.1049352586, -0.0050848722, 0.0638283193, -0.0269159079, 0.0733824372, 0.0897152722, -0.0069652498, -0.0278634429, -0.1117509305, -0.0955150425, -0.1164504588, -0.0591200888, 0.0522108078, 0.1116066575, -0.0625447035, 0.0308687389, 0.1022732258, 0.0985203385, -0.0471172333, 0.0385056138, 0.0831817091, 0.0921728015, 0.0831471086, 0.1129480004, 0.0947089195, 0.0141501725, -0.0400859714, 0.0181364417, -0.0434999466, 0.0311240554, 0.0785191357, -0.0120513737, 0.0999235213, 0.0388477445, -0.0825370252, 0.0184709728, 0.0789908767, 0.0094116926, 0.0585908890, -0.0726236105, 0.0891817212, -0.0374847353, -0.0295911133, 0.0056304038, 0.0147944987, -0.0650306940, -0.0755333602, 0.0087260902, -0.1220499873, -0.0688238144, 0.0581286550, 0.0156558156, 0.0538081229, 0.0379514694, -0.0849808156, 0.0481377542, 0.0790768564, -0.0715615451, -0.0129141808, -0.0249544978, 0.0410759449, 0.1025770307, -0.1020534635, 0.0120130777, -0.0355872214, -0.0822979510, 0.0278496444, -0.0577062070, 0.0487800241, -0.1194040179, 0.0604527891, 0.0309935808, -0.0064514875, 0.0363436341, 0.0249591172, -0.0150429904, 0.0028197467, -0.0393862426, 0.0534126163, 0.0539102852, -0.0091302693, 0.0204327703, 0.0291888714, -0.0595330000, -0.0645034909, 0.0123396814, 0.0048910677, -0.1215483546, 0.0428002775, 0.0209560990, -0.0932689607, 0.0661856234, 0.0741169751, -0.0437116623, 0.0210209191, 0.0436842442, 0.0401458442, -0.0067871213, 0.0698480010, 0.1189521849, 0.0091975629, 0.0677436292, 0.0867242813, -0.0651553273, 0.0258228183, -0.1053266823, -0.1087453365, -0.0343969762, 0.0039792657, 0.0654982030, -0.0233613849, 0.0814094767, -0.0686613470, -0.0696750581, -0.2397191525, 0.0418470055, -0.0472874641, -0.0245671235, 0.0970147401, 0.0091081383, -0.0217207689, 0.1342189014, 0.0006220089, 0.0279379636, -0.0920628011, -0.0663109869, -0.1352979392, 0.0343366414, -0.0204614252, -0.0637583733, -0.0546681769, 0.0789309219, 0.1064811349, 0.0811417922, 0.1221025661, -0.0446021594, 0.0155918179, 0.1191377789, -0.0967601687, -0.1201743186, -0.0065047084, -0.0778993517, 0.0064959549, 0.0037157512, 0.0129715102, 0.0896839201, -0.0127829146, 0.0373991132, 0.0486582592, 0.0394141413, 0.0418285206, 0.0252936427, 0.1259167343, -0.0363243707, 0.0272451863, 0.0971950069, -0.0199881289, -0.0053479658, -0.0097198170, 0.0583413579, 0.0921569094, 0.0971584022, 0.1311978847, -0.0107381074, -0.1480583251, -0.0792134702, -0.1044450328, 0.1160137504, -0.0426734239, 0.1900288165, -0.2483435869, -0.0157979280, -0.1365040690, -0.0327702388, -0.0287301727, 0.0316671729, -0.1128779426, -0.0757505670, -0.0928153470, 0.1153926328, 0.1465881020, 0.0241840333, -0.0511265211, 0.0196790267, 0.0972671434, 0.1873637736, -0.0652918890, -0.0400670357, -0.0200959444, 0.0428213999, -0.0698128045, 0.0023726148, 0.0814391971, -0.1198052764, 0.0452268049, -0.0645902380, -0.0774588734, 0.0123751462, 0.0672403947, 0.4154952466, 0.0435120240, -0.0363820232, -0.0138154617, -0.0332025252, 0.0533546805, 0.1150159612, -0.0158918221, -0.0287805628, 0.0639222711, -0.1997577995, -0.1864879578, 0.0648904517, -0.0036310323, -0.0856946111, -0.0330589935, 0.0031662993, 0.1009449139, 0.1134359166, -0.0415031537, -0.0569102503, 0.0183650535, -0.0524397828, 0.0661850572, 0.0163399335, 0.0587443262, -0.1142643839, -0.0988111645, -0.0993778855, 0.1252321750, 0.1042795032, 0.0235079881, 0.0336187929, -0.0455135293, -0.0513844080, 0.0347983390, -0.1487918943, -0.0342135988, 0.0156684685, 0.0163568128, 0.1506680548, -0.0865656212, -0.0496201925, -0.0361810699, 0.1071339771, 0.0567001663, 0.0709185079, -0.1087226868, 0.1034072787, -0.0445846058, -0.0904615819, 0.0809925720, 0.0166336428, 0.1169723123, 0.0320438296, 0.0466173738, -0.0804637372, 0.0234710760, 0.0640184879, -0.0880098864, -0.0206996072, 0.1109827533, -0.1042707041, -0.0494915172, -0.1895049959, 0.0331028253, 0.0007710316, -0.1096815616, 0.1385984868, 0.0598187633, -0.1370781660, -0.0044740974, -0.0685501099, 0.0680925995, -0.0820697844, -0.2437226772, -0.0919528827, 0.0344586745, -0.0096266912, -0.0184183661, 0.0778174624, -0.0328634791, -0.0541933179, -0.0470532179, 0.1353714168, 0.0684358254, -0.0394636728, -0.0041158427, -0.0514344461, 0.1664601713, -0.0795093477, 0.0239173044, -0.1388147771, -0.0348568074, 0.0418664590, -0.0191704072, 0.0271068104, 0.0552443303, -0.0011634342, 0.0113858078, 0.0589167215, 0.0122485030, 0.0852304399, -0.0572017431, 0.0448098630, 0.0708455220, -0.0659411028, -0.0397220217, 0.1016391069, -0.1335206330, -0.0613700971, -0.0990025699, -0.0367561914, -0.1191377565, 0.0181920864, -0.0058900341, -0.0474757105, -0.0085303700, -0.0409738831, -0.0482113212, -0.0295126215, -0.1139579788, -0.0639560297, 0.1483716071, -0.1547632813, -0.2533370554, -0.0111162663, -0.0144409658, 0.0336458012, 0.0983287096, 0.0869251341, 0.0894236192, -0.0863172635, 0.0333350748, 0.1939863712, 0.0676007569, 0.0039879330, 0.1007873267, 0.0142470133, -0.1204112768, -0.0273130760, -0.0088993674, 0.0219615828, 0.0093826689, 0.0525235645, 0.0961577147, 0.0732026845, 0.1308654398, -0.3036701381, 0.0664590970, 0.0729233250, 0.0346610323, -0.0465430990, 0.0602468699, 0.2394258529, -0.0242303275, -0.1342605203, 0.0067811352, 0.1235640422, 0.0014389679, 0.0868072212, -0.0039902278, 0.0413353965, 0.0269832686, -0.0472783633, 0.1314722747, 0.2863920927, 0.0166590530, 0.0760977864, -0.1322531700, 0.0367239006, -0.2754701376, -0.1147431061, -0.1593022943, -0.0070698201, -0.2259637266, -0.1643681526, -0.1658827960, -0.0664230958, -0.1010464951, -0.2108297497, -0.1188877225, -0.0495945439, -0.2526215017, -0.0774965063, -0.0177890677, 0.0160629451, -0.1701380014, 0.0161833819, -0.1522653699, -0.2378776073, -0.0302170329, 0.0051259627, 0.1955341846, -0.1685723513, -0.0293190833, -0.0871300995, 0.1485263854, 0.1809456199, -0.0320060886, 0.0076318872, 0.1431326717, -0.0678676665, -0.1575913280, 0.0149063291, -0.1383063644, -0.0763863102, -0.1089709774, -0.1289873123, -0.2100890130, -0.2437364608, -0.0937436819, -0.4050594270, -0.0557028353, 0.0178576484, -0.1748993993, -0.0459031053, 0.0104803387, -0.0100390557, -0.0408583954, -0.1464531720, -0.0428006314, 0.1321633905, -0.2405391037, -0.2620130777, 0.2063348740, -0.1741935909, -0.0135011096, -0.0522978082, -0.0766799897, 0.0023217406, -0.1571286470, -0.0236432385, -0.0183754973, -0.0116027268, -0.1890349984, -0.2071403265, -0.0409937575, -0.0954779908, -0.1936887503, -0.1230436116, -0.3340016007, -0.1484618336, -0.3729976416, -0.1066768393, -0.1521498710, -0.1061617732, -0.0370254740, -0.0173539817, -0.4744857252, 0.0571070611, -0.1183185503, -0.1704088151, -0.0027865449, -0.0108257942, -0.0693915039, -0.1077431366, -0.0344293341, 0.0363006219, 0.0260715894, -0.1866239607, -0.0162426531, -0.0310065914, -0.1271913201, 0.0303047076, 0.2990446091, 0.0114301620, 0.0210599229, -0.1144923717, -0.0520231202, -0.0823410749, -0.4868134856, -0.0466190316, -0.1974831074, -0.0269131903, -0.0512883663, -0.3789072633, -0.0038877309, -0.0316988379, -0.0714360252, -0.0659837648, 0.0263847690, -0.1421716958, 0.0244166180, 0.0011361657, -0.0488482080, -0.0590899810, 0.0018967026, 0.0252588820, -0.2274865508, -0.3734838367, -0.6747296453, -0.1191714182, -0.2568812668, -0.1399225444, -0.0070264465, -0.0360447727, -0.2260950953, -0.0412027352, -0.2021015137, -0.3832614720, -0.1414227039, -0.2185239345, -0.1036456600, -0.0928022787, -0.0808608457, -0.1940587014, -0.0411536805, -0.0415268540, -0.1717418879, -0.4046571851, 0.0366174169, -0.0840793028, -0.1062657610, -0.0321847238, -0.0094822031, -0.0063918536, -0.1096693650, -0.0931964293, -0.3077836633, -0.4114926159, -0.0468527302, 0.2221817672, -0.1513653845, -0.1448943168, -0.1016555727, -0.0089550233, 0.0305167008, -0.0299010016, -0.0988431498, -0.2893244922, -0.5106456876, 0.2241023928, -0.0753048658, -0.0045458316, -0.1510838717, 0.0804246441, -0.1072798446, -0.0388486609, 0.0427063778, -0.1518880725, -0.0699743554, -0.1774285883, 0.0853881016, -0.0517201386, -0.0758740529, -0.1615205854, -0.3615971208, -0.0155001227, -0.0564452037, 0.0629863739, -0.1009472013, -0.1607426554, -0.1238921732, -0.2798566818, -0.1078248098, -0.1773677319, -0.0929539874, -0.0309404284, -0.0787992999, -0.0909646228, -0.0023298441, 0.0240429174, 0.0308034588, -0.2102440447, 0.0169015117, 0.0817994177, 0.0366797112, 0.0605381243, -0.3091803193, 0.0849090293, -0.0388653390, 0.0560445637, 0.0160327386, -0.0979539081, -0.1415496767, -0.0293931328, -0.2767198682, -0.1122161299, -0.1688989103, -0.1291112453, -0.0686099976, 0.0129804667, -0.0348013118, -0.0339830853, -0.4459721744, -0.1994504333, -0.0935605541, -0.0683236197, -0.2926512361, -0.0903327614, 0.3906306624, -0.0872451589, 0.0625527725, -0.1443346739, 0.0647205636, 0.0038987815, -0.0190672521, -0.0926793963, 0.0137874922, -0.1023939103, -0.6256352067, 0.1940811872, -0.0968805030, -0.0049753212, -0.0404450297, 0.0587616153, -0.0147931324, -0.1744948775, -0.1198423877, 0.0526609756, -0.0122046685, -0.0084615694, -0.1303445250, 0.2517500818, -0.0144614810, -0.4849413335, -0.1018160209, -0.0643260926, -0.1085239947, -0.0406949781, -0.6720578671, -0.9974460602, 0.1184119284, 0.0490787365, -0.1827227771, -0.0875699818, -0.0013038625, -0.0329724215, -0.0635105222, 0.1117842868, 0.1284902990, 0.0624743327, -0.0729370639, -0.0034082271, 0.1368867159, 0.0198929254, -0.0657163262, 0.1129161865, 0.0076532522, 0.0552627146, 0.0007634299, 0.0101198405, -0.0920575187, 0.0675290674, 0.0275680907, 0.0285978727, 0.0377695747, 0.0052080089, -0.0273503494, 0.0002408845, 0.0678655878, -0.0908488259, -0.1076544821, -0.0427335501, 0.0217792522, -0.0968113840, -0.0197607819, -0.0902095735, -0.0355680250, -0.1111251935, -0.0309492312, -0.0348600596, 0.0470480025, -0.0714532286, 0.0860220864, 0.0258194618, -0.0226554386, 0.1431388855, 0.0459915772, 0.0521370284, 0.0549069569, -0.0601304173, -0.0825754106, -0.0700492039, -0.0093508894, -0.1011672318, -0.0837509111, -0.1633650959, -0.0863535628, -0.0096969558, -0.0215983130, 0.0460742079, -0.1158117279, -0.0125788311, 0.0150335087, 0.0326202661, 0.0111349383, -0.0585782379, 0.0196775310, 0.2103930116, 0.0973055065, -0.0491798371, 0.0538276434, -0.1117540896, 0.0579812787, -0.0717041790, -0.1271079034, -0.0743358582, 0.1180070192, -0.0379614569, -0.0293564294, -0.1110655740, 0.0293750633, -0.0328038186, 0.0218719468, -0.0008228494, -0.1011502221, 0.0869899690, -0.1077985168, -0.0486422777, 0.1189706475, -0.1737156510, 0.0516637787, -0.0428074747, 0.0616046302, 0.1018228531, 0.0280488301, -0.0689805821, -0.0635747537, 0.0251413882, 0.0259556193, 0.0969377533, 0.0873262733, -0.0010689923, -0.2434017062, -0.1329354644, -0.0165336952, 0.0051690857, -0.0286394935, 0.0803226158, -0.1139990985, 0.1052680761, -0.1244894117, -0.0342655592, -0.1736598313, 0.0925094634, -0.0558360182, -0.0675356239, -0.0919312686, 0.0541041605, -0.0930489376, -0.1375391483, -0.0368749462, 0.0941044390, 0.0557521917, -0.0807546228, -0.1352429688, -0.0932081863, -0.1310443133, 0.0956790671, 0.1356324553, -0.0478146560, 0.0089672301, -0.0426136144, 0.0707439706, -0.0477059856, 0.0720931143, -0.0895883068, 0.0985929742, -0.0790257677, 0.0905156359, -0.0035364809, 0.0682668760, 0.0864027888, 0.1722675264, 0.0111514721, -0.0420112684, -0.0892787352, -0.1013641357, -0.0672649145, -0.1379893720, -0.0442552753, 0.0396031328, 0.0463129990, 0.0438040160, 0.0245944634, -0.0405710042, -0.0775636062, -0.1382519156, 0.1288397610, 0.0791757926, 0.0306940451, -0.0951938182, -0.1061466709, -0.0295330752, 0.0819421783, -0.0143572120, 0.0889838710, 0.1122587770, -0.1426863670, 0.1235903502, -0.0199249089, 0.0644379035, 0.0667893812, 0.0237309486, 0.0725795552, 0.0875790268, -0.0892862827, -0.0563364625, 0.0324545838, -0.0267111529, -0.0249265730, 0.0733855814, 0.0414017849, 0.0862677917, 0.0651367828, -0.0559077375, -0.1045520380, -0.0896437094, 0.0785098001, 0.0492912941, -0.0181196444, 0.0189589933, 0.0000536782, -0.0342874192, -0.1039303243, -0.0042654211, -0.0617531426, 0.0616207868, 0.0509375371, 0.0765237734, -0.1698899418, -0.1003538221, -0.0671650171, -0.1359820366, -0.0515123382, 0.0792745277, -0.0681335852, -0.0244807694, -0.0461622104, 0.0388887674, 0.0778290182, 0.0569524541, 0.0342452750, 0.0881052986, -0.0683909282, 0.1668056697, 0.0237588584, -0.1292247772, 0.0911096781, 0.0373919755, -0.0800752267, -0.1058859006, 0.0583091788, 0.0240683742, 0.1205727309, -0.0822860971, -0.0306334179, -0.0916792974, 0.0893052667, 0.0377467647, -0.1122069433, -0.0121411085, -0.0654715598, 0.0406981111, -0.1325758845, 0.0350263380, 0.0883938149, -0.1341219693, -0.3174333274, -0.0156038003, 0.1660357416, -0.0284072869, -0.1376322806, -0.0140534118, 0.1990193725, 0.0223469436, 0.0987129509, -0.0339073949, 0.0172451753, 0.1433434635, 0.1796405911, 0.0556727685, 0.0363345779, -0.2904909253, 0.0494910255, -0.1648427099, -0.0730754882, -0.0369579755, -0.0108663132, 0.0750357136, -0.0099662477, -0.0946604088, -0.1315556914, -0.1445838213, 0.0181429107, -0.1477542669, 0.1174087003, 0.1102434099, -0.0011707310, 0.0496344790, 0.0700388551, -0.0906299353, -0.1206087321, 0.0382711515, -0.0192909595, 0.0527736321, 0.0203512385, 0.1136711761, 0.0484088361, -0.0460508838, 0.0851320624, 0.0607506074, -0.1030046046, -0.1904156953, -0.0149751315, -0.1361762285, -0.1171544343, 0.0128277373, 0.0313332826, 0.0398227535, -0.0844447687, -0.0518851355, 0.0259376485, 0.0303519424, 0.0386731885, -0.0365787521, 0.0617816113, -0.0102585759, 0.0759030357, -0.1350767314, 0.1713835895, -0.0519338287, 0.2034649104, -0.0421920680, -0.0056314734, -0.0835311040, -0.0563004985, -0.0160274897, 0.0727622807, -0.0049145310, 0.0718368664, 0.0592896454, 0.2486182004, -0.3134633303, -0.0237527024, -0.1144845709, 0.0565443076, -0.0669844002, -0.0649461523, 0.0736371428, -0.1490989625, 0.0871275365, 0.1087299958, 0.0484106950, 0.0610852279, -0.0273803174, 0.0593249798, -0.0159261301, -0.0938118845, 0.0264342092, -0.0567078292, 0.0484473333, -0.3085952699, -0.0892875865, 0.0582764670, -0.0581141114, -0.0949440226, 0.0824213400, -0.0429472364, 0.0339263044, 0.0176584460, 0.0806330517, 0.0108022355, -0.0984975025, -0.1283827424, 0.0425744280, -0.0146688409, -0.0293699969, 0.0951486975, 0.0611927025, 0.0706791729, 0.0259251390, 0.0495582223, -0.0106758531, -0.0583381392, -0.0847306624, -0.0396199450, -0.0417934544, -0.0222872831, 0.0317022763, 0.0433920696, 0.1392624825, -0.0372621305, -0.2000123858, 0.0904691070, -0.0522623956, -0.1114651561, -0.0398193635, -0.0776165500, -0.0971602425, 0.3548924923, -0.1000500619, -0.0363495275, 0.1042860746, -0.0835902840, -0.0106163807, -0.0458547994, -0.0927242115, 0.0589435659, -0.0451129451, -0.0462241136, -0.1846542954, 0.0279250517, 0.0769503415, 0.0803647488, 0.1184499338, 0.0342355184, 0.0691715181, 0.0994912758, -0.0753579661, -0.0989438742, -0.0814718232, -0.1180951074, 0.0850184262, -0.0524507612, 0.0406971276, 0.0226180535, 0.0194017459, 0.0615629293, 0.0916462317, 0.0964441970, 0.0996412039, 0.1352737695, -0.0941702574, -0.0463447124, -0.1262039989, 0.0785325617, -0.0799456686, 0.0685634688, -0.0803804547, -0.0076237610, -0.0184290316, 0.0014536442, -0.1578235328, -0.0504476391, 0.0854222551, -0.2617138624, 0.0220082346, -0.0957810283, 0.0293253195, 0.0189605895, 0.0065134098, -0.0337637365, 0.1027646512, 0.0785773322, -0.0171741676, -0.0087725651, 0.1102404892, 0.0345470160, -0.1184847057, 0.1081384122, -0.0054893750, 0.0419433676, 0.0630080178, 0.1143457219, -0.2815821767, -0.0528784394, -0.0212051198, 0.0610077009, 0.1282476187, 0.0579492524, 0.1033564657, 0.0819035098, -0.0539911129, -0.1881548017, -0.0665154904, -0.0511491820, -0.0431452468, 0.0433494151, 0.0544944331, 0.0556217581, -0.0575238205, -0.1034701765, -0.0375606716, -0.0016639041, -0.0181853082, -0.0262473021, -0.0275583863, -0.0578176342, 0.1221705675, -0.0038842265, 0.1955206543, 0.0295193046, -0.1339329630, 0.1294308156, 0.0753146932, 0.0238347463, -0.2686515450, -0.0484909602, 0.0643968210, -0.0101898685, -0.0278625041, -0.1173122823, 0.0439264998, -0.0872809440, -0.0721552819, -0.0933775231, 0.0422884002, 0.0925201848, -0.0493565425, 0.0052664564, -0.0176826119, -0.1020788178, 0.1491499245, 0.0321174264, -0.1452779919, 0.0693058744, 0.0008416809, -0.0850468054, -0.0285530388, -0.2492930740, 0.1121165082, -0.1026660055, 0.0314140841, -0.1272071898, 0.0800468549, -0.0576104932, 0.0206632968, -0.0149209509, -0.0165911894, -0.0093985721, 0.0964386836, -0.0788617879, -0.1644527018, 0.0967287719, -0.1282684505, 0.1025720015, -0.0357601382, -0.0779313147, -0.0690066740, 0.0027150621, 0.0969799012, -0.2277951837, -0.0748716518, 0.1209392399, 0.1333302557, 0.0980342478, -0.0192373134, 0.0483841784, -0.0209688377, 0.1689324975, 0.0257809144, -0.0641625673, 0.0910823792, -0.0955648422, 0.0419982634, 0.0950402319, -0.0397741497, 0.0025974663, 0.0584043190, -0.1007366180, -0.1131931841, -0.1815153211, 0.1152637675, 0.0301594939, 0.0409481525, -0.0557294935, 0.0254182238, -0.0753882825, 0.0621084459, -0.0205515269, 0.0492346883, 0.1292285472, 0.0622152276, 0.1177350581, -0.0391614139, 0.0492395945, 0.0613320805, -0.1289873570, 0.0320169479, 0.0973431543, 0.1181839108, -0.1486273855, -0.0767955333, -0.0698507354, -0.1484674364, -0.0396399572, 0.0836434439, -0.1017880812, 0.0553465225, 0.0134749664, 0.0748597905, -0.1006353647, 0.0601255186, 0.0801339373, 0.0285425745, -0.0389568619, -0.0311548300, 0.0813631341, 0.0849267542, -0.1344743073, 0.0794430152, 0.0100524174, -0.1378284842, -0.0876096338, 0.1001021788, 0.0152996266, -0.0033291637, 0.1157389954, -0.1111732423, -0.0709055588, 0.0631258041, -0.0187176224, 0.1496337056, 0.0875363424, 0.1084575728, -0.0475863814, 0.0219654515, -0.0669373274, -0.0332728550, -0.0305550750, -0.0947265327, -0.0928724408, 0.0200699605, -0.0455145165, 0.0788127109, -0.0192183405, -0.0780310184, -0.0988178402, -0.1719833910, -0.0840287805, -0.0868944600, -0.1398035735, -0.0537474677, -0.0144725041, 0.0517010465, 0.1555810273, 0.0396703593, -0.0291972738, -0.0784648955, -0.0585801676, -0.2564816177, -0.1340777874, -0.0236600619, -0.1510834396, -0.0082329074, 0.0453701727, -0.0065039280, -0.0455502197, -0.0376980044, -0.0514293574, 0.0610617623, 0.0646604896, -0.0177570619, -0.0532786846, -0.0649291128, -0.1193067804, -0.0462762713, -0.0830100477, -0.1074240580, -0.0045995391, -0.0589985624, -0.0721209496, -0.0123622445, -0.1361773163, 0.0366295390, 0.0217120927, -0.1490221620, 0.0629289150, -0.0091401367, 0.0933636129, -0.0124705499, -0.1122585312, 0.0363615043, -0.0328363962, -0.0139067499, 0.0571246482, 0.0626785085, -0.0843428895, -0.0583830066, -0.1284642220, 0.0815350860, -0.0031387792, -0.0932303965, -0.1085901558, -0.0134263979, -0.0023442369, 0.1120696887, 0.0914049447, 0.0772200450, 0.0154449753, -0.1378057897, 0.0824918672, -0.1206954345, 0.0807749331, -0.0996656418, -0.0142852264, 0.0082732867, 0.0197848231, -0.0628951788, -0.1630098224, -0.1000146121, -0.0392812490, 0.1067996398, -0.0933943242, 0.0397032872, 0.0115573462, -0.0633279607, 0.0593269467, -0.1067741066, 0.1331887841, 0.0399237312, -0.0878643915, -0.0087263081, -0.0216726456, -0.0497945957, -0.0686655194, -0.0239582192, -0.0802699029, 0.1341945678, -0.0272710305, 0.0396923088, -0.1226157472, 0.0866185576, 0.1146494225, -0.0434834324, -0.1540018469, 0.0294697192, 0.0938610137, 0.1027755365, 0.0121719893, -0.0050833402, -0.0960956961, -0.0387299061, -0.0193256438, 0.0514201894, -0.1159378290, 0.1150490791, -0.1804660708, 0.1955247521, -0.0483172685, 0.0491270311, -0.0913287252, 0.0011429602, 0.0847895741, -0.1063243225, 0.0095644305, 0.0160373524, -0.0798452422, -0.0098028928, -0.1060266942, -0.0491086394, -0.0037516796, -0.1518619657, 0.0778529495, -0.0049572694, 0.0119824372, -0.0172174238, -0.0987171829, -0.0595827103, -0.1444402337, -0.0778687373, -0.1121875718, -0.0772100687, -0.1179322526, -0.0087895310, -0.0829224959, 0.0234279856, 0.0231807325, -0.0757678449, -0.1153120175, 0.0624424629, -0.1158969998, 0.0283291936, 0.0830211937, 0.0077564260, -0.1118885875, 0.0027068642, 0.0379145183, 0.0011533579, 0.1745710522, 0.1001350135, 0.0184355006, 0.0435957201, 0.0524112508, -0.0315946750, -0.1612536907, -0.1251089722, -0.0741317868, -0.0064479513, -0.0477526672, -0.0629112199, -0.0415918678, -0.0597526617, -0.0338580199, 0.0939330310, 0.1250353605, -0.0410240926, 0.0961959735, 0.0338668525, -0.0093091000, 0.1168581918, -1.5230693817, -0.1462188363, 0.0390073843, -0.0412698723, -0.0331487991, 0.1406141371, -0.0531190000, 0.0203984994, -0.1357315034, -0.1095785722, 0.3503713608, -0.1250429600, 0.0279938858, 0.4186546206, 0.5177947283, 0.0182941724, -0.1255360246, -0.0676063672, -0.0407487601, -0.7280004025, -1.4755078554, 0.8242787123, 0.0000457367, -0.0571835414, -0.1244097278, -0.1026346162, 0.0522391610, 0.0567044057, -0.3984223306, 0.0318844318, 0.0000043611, 0.1331325620, -0.1156182513, -0.1063671038, -0.2006703913, -0.4093074203, -0.0613436401, 0.0043513225, -0.1170997843, -0.0486554131, -1.6724359989, 0.0245273653, -1.8199825287, -1.2295198441, -0.0381201543, -0.1002989635, 0.0357766859, -0.0220874380, -0.0587850474, 0.6221354604, -0.8023965955, -0.0005041705, -0.0117763430, 0.0597606786, -0.4755897224, 0.1251369715, 0.4426271319, -0.3568221927, -0.0170340110, -0.0230221450, -0.1176771075, -0.1898473650, -0.0300061498, 0.0030883385, 0.0020400789, -1.3738154173, 0.0651737824, 0.0973316357, 0.0051577035, 0.3333598077, -0.0695126653, -0.5301665068, -0.1681403816, -0.4220016003, -2.5418155193, 0.0039062041, 0.0100980336, -0.0216647498, -0.1409409344, -0.1788498312, 0.1151124015, -0.8115661740, -0.0666711628, 0.0514599495, -0.0479213223, 0.0745497867, -0.3335999548, -0.0450211763, 0.2587658167, 0.0691526085, -0.1030544043, -0.1227140352, -0.0062523666, -0.0248696301, -0.0522582456, 0.5139123797, -0.2317371666, 0.0524307415, 0.0447511747, -0.0030719626, -0.0823536590, -0.7267277241, 0.0742879286, 1.4477142096, -0.0212885644, -0.0361428484, -0.1409955621, -0.0960499272, 0.0180761162, -0.3325662315, 0.0045181313, -0.0144380359, 0.3785321116, -0.7610616684, -0.0119566256, -0.0531498455, 0.0513949282, -0.5192359686, -0.5240771770, -0.1514954865, 0.6068598032, 0.1581921130, 0.0164690781, -1.4174348116, -0.0744535401, -0.0009129141, -0.0920943022, 0.0592161976, -0.1253146380, -0.3410428762, -0.8280181885, -0.1008567065, 0.4941521883, 0.3363479674, -0.0225366522, -0.0026656280, 1.1553711891, 0.4405395389, 0.1083715931, -0.5968470573, -0.2284352928, -0.2160085440, -1.8255975246, -0.0059688650, -0.0401955619, -0.0228673853, 0.0026427798, -0.1730630398, -0.0203043763, 1.3866981268, -4.1881303787, -0.2058889717, 0.3955642581, -0.1292883754, -0.6427856684, -0.0379134305, 0.2536197305, 0.0096007148, -0.0428352430, -0.1488765031, 0.9359427094, -0.1042708904, -0.0233804677, 0.0079864124, 0.0252884980, -0.1613092571, 0.4889962673, 0.0690351650, 0.0284494646, -0.5020873547, -0.0379669778, -0.3704994321, 0.2627978325, -1.0355259180, -0.0118655488, 0.0345150642, -0.1494790912, 0.0102210836, -1.4568129778, -0.0681350306, -0.2593920231, 0.0214742124, -0.0854201615, -0.0858537480, 0.0357123837, 0.1046462879, -0.5513556004, -0.3550560176, -0.0814866275, -0.1117174923, -0.1155160367, 0.2652859986, -0.0077660494, -0.4791623652, 0.3049416542, 0.1255707592, -0.1742276400, 0.0042385808, -0.0052614859, -0.1391395628, -0.0630580112, 0.3824907541, -0.0047899820, 0.1806027591, 0.1433319300, 0.0452863686, -0.0395836644, 0.3652558625, -0.0356937759, -0.0514500290, 0.1937170476, -0.0116244638, 0.0077877524, 0.0538845919, 0.0288319215, 0.9137793779, -0.3587599397, -0.1096885651, -0.0627654344, -0.2091878504, -0.2521071732, 0.0476312414, 0.0139701515, -0.0747560412, -0.0799418613, 0.0559301451, -2.0615525246, -0.1195769012, -0.0513422936, -0.1021154895, -0.1838624179, 0.9020273089, -0.7567030787, -0.0824878514, 0.2043856829, -0.1631412208, 0.0126258563, 0.2042921185, -1.3812505007, 0.1400170773, 0.0735314339, -0.0541937351, 0.0619884394, -0.0301295035, -0.1505645514, -0.0974744186, 0.3855453432, -0.6614835858, -0.0796953589, -0.0395783409, 0.0171874817, -0.1495411843, -0.1214329004, -0.2503946126, -0.1162523031, 0.0150996307, -0.0772244036, -0.1040181518, 0.0131729795, 0.0466512442, -0.1056865826, -0.0224186480, -0.0251207128, 0.0362673290, 0.0233921632, 0.0574551895, 0.0059245876, -0.1180942357, -0.1033232883, -0.0598694794, 0.0338398963, -0.1169983819, 0.0717351809, 0.0157622844, -0.1255920231, 0.0982213765, -0.0991834253, 0.0922679007, 0.0768289492, 0.1161964536, 0.0754268840, -0.0250756741, 0.0214461088, 0.1255671531, -0.0918888003, 0.0405535661, 0.0103273168, -0.0134803709, -0.0110642686, 0.0249923915, 0.0530196242, -0.0635070130, 0.0522012897, -0.1124707088, -0.1014705673, -0.0037077887, 0.1188940406, 0.0830943137, 0.0587534606, -0.0174700245, 0.0717148930, -0.0016778315, -0.0142764309, 0.0133396657, 0.0610450283, 0.1262373775, 0.0258458890, -0.1117112413, 0.0468505919, 0.1062911153, -0.0227114093, -0.0883459076, -0.0857833028, 0.0041064653, -0.0679564774, 0.0309035480, 0.0401057750, -0.0093932487, 0.1246971041, 0.0604038239, -0.0944568217, 0.1130689904, 0.0158805922, -0.1251540035, -0.1063612849, 0.0448583066, 0.0843803883, -0.0076416591, 0.0077173114, -0.0263599921, 0.0681232512, -0.1074168682, -0.0933774710, 0.0513601899, 0.0883275568, -0.1244836375, -0.0368980393, -0.0040151933, 0.0314545147, -0.0521583296, -0.0824348330, -0.1269549131, -0.0779629946, -0.0716888234, -0.1023494601, 0.1174935997, 0.0260696262, 0.0052583516, -0.0788502544, -0.0299273729, 0.0040169586, -0.0964605361, -0.0218281765, 0.0823455751, -0.0882074311, 0.0262169931, 0.0420719460, -0.0646011382, -0.0499458276, -0.1206745505, 0.1090187132, -0.0609598160, -0.0703829825, 0.1194504872, -0.1159490049, 0.0651534349, 0.1159400344, -0.0342888422, -0.0662756786, -0.0668470562, 0.0973824635, -0.0856035054, 0.1069134176, 0.0224184692, 0.0075603426, 0.0190172493, -0.1093926951, -0.0068634152, 0.0828980878, -0.0110432589, 0.1013932675, -0.0297064055, 0.0699911267, -0.0762539878, -0.0180949457, -0.0143884122, 0.0226791501, 0.0656987578, -0.0184371769, -0.0775589570, -0.0048354887, -0.0540639833, 0.0497766510, -0.0307896510, 0.0688717738, -0.0945520699, -0.0276585761, 0.0732174069, -0.0496237315, 0.0787481442, 0.1150256395, 0.1222882271, -0.0684307441, 0.0870652497, -0.0023590853, 0.0776823610, 0.0323795080, 0.0987249017, 0.0350078158, 0.0869301111, -0.0146965981, -0.0827000141, -0.1094509363, -0.0695687458, -0.0098619759, -0.0777102709, -0.0143553913, -0.1076950580, 0.0862940624, 0.0593913496, 0.0328514613, -0.0403787680, -0.0526044257, 0.1298516244, 0.0452305302, 0.1193627492, -0.1306014955, 0.0084407926, -0.0192968920, -0.0778936595, 0.1030062586, 0.0316781737, -0.0316947289, -0.1197949424, 0.0970914140, -0.0271256529, 0.0445342660, -0.0823090374, -0.1223764718, 0.0393160023, -0.1019057035, -0.0230981894, 0.0783559158, -0.0890140682, -0.0460136533, 0.1017606258, 0.0159062147, 0.0777313188, -0.0170494951, -0.0142942835, 0.0204465594, 0.0488659143, 0.0301067606, -0.1189937890, 0.0148273408, -0.0552744344, 0.0524652638, -0.0338917077, 0.1052094772, -0.0888350382, -0.0202344060, -0.0481336415, 0.0631655380, -0.0200329740, -0.0913478881, 0.0059193927, -0.0452355295, 0.0493619740, 0.0793607533, -0.0161397774, -0.1048874557, -0.0837484300, 0.1114990041, 0.0558602512, -0.0487186089, -0.0537562594, -0.1048449799, 0.0362058766, -0.0796795487, -0.0794227868, 0.0260841846, -0.1172561049, 0.0256902575, -0.0932908654, 0.1059367061, -0.0276624393, 0.0652968585, -0.1279626191, -0.1038973033, -0.1094515175, -0.0349126756, -0.1227355748, 0.1036778465, -0.1193330437, -0.1050851271, -0.0026926277, -0.0915191174, 0.0579042360, 0.0695996881, 0.0271576717, -0.0608923733, -0.0485290587, -0.0363999903, -0.1183863059, 0.0547934994, -0.0775515214, 0.0103242984, 0.0403677039, -0.0334979296, -0.0701662302, -0.0123405010, -0.1361364573, 0.0467608571, -0.0971651599, 0.0144321527, -0.0682107136, -0.1259573251, -0.0747918561, 0.0590502061, 0.0459522940, -0.0585169867, -0.0555000529, 0.0488300808, -0.0339465886, -0.1114387140, -0.0531393699, 0.0680200383, -0.0209016707, -0.0532446355, -0.0079127392, 0.0822051615, 0.1738274843, 0.0586591177, -0.0685131177, -0.1108033508, -0.0629247725, 0.0998070538, -0.1340876967, -0.1140701622, -0.1375441253, -0.0479506925, -0.0090807248, -0.0118915308, 0.0292499196, -0.1324100047, 0.0609605499, 0.0495432615, 0.0628411919, 0.0208008960, 0.1078529805, 0.1000980884, 0.0404770188, -0.0688152462, 0.0955504328, -0.1413863003, 0.0310348105, 0.0151771829, -0.0683197081, -0.0843842253, 0.0678368062, 0.0718798935, -0.0685331076, -0.0675732046, 0.0024391669, 0.1313132197, 0.0948614255, 0.0772968158, 0.0344807096, -0.1281597167, -0.0279754344, 0.0400171541, -0.0714631826, -0.0542226322, 0.0637961179, 0.0033056866, 0.0338199474, -0.0385634042, 0.0354218073, -0.0899740979, -0.0284777302, -0.0756173059, 0.0172869414, 0.0661185309, 0.1216787919, -0.0405952260, 0.0103561385, -0.0147982724, -0.0135797225, 0.0690019354, 0.0989240482, -0.0033445864, 0.0735802427, 0.0274600964, -0.0591525882, 0.0996279716, -0.0995424837, 0.0523469523, -0.0100102825, -0.1397437006, -0.0256214589, 0.1173099577, -0.0799295828, -0.0359100848, -0.1201689616, 0.0039030558, -0.0360699780, 0.0966688618, 0.0593605526, -0.0588937737, 0.0339836925, 0.0933413580, -0.1012366414, 0.1113236323, 0.0260958355, 0.0530047752, 0.1657695919, 0.0471643470, -0.1084952876, 0.0227603633, 0.0238358751, 0.0120119052, 0.1300610751, 0.0882320553, 0.0767390504, 0.0251625869, 0.0300330110, 0.0346906930, -0.0865319148, -0.0930266455, -0.0887792259, 0.1111429408, -0.0156588703, 0.0540838614, 0.2518245280, 0.0929738656, 0.0168888140, -0.1332699358, -0.0524092577, 0.0644715503, 0.0354902148, 0.0252572820, 0.0067760623, 0.1069218665, -0.0463294871, -0.0599468984, 0.0957833529, 0.0433516875, 0.1007371247, -0.0361793041, 0.0088077383, -0.0200927611, 0.0402954333, -0.0470012538, 0.0623774342, 0.0281669945, -0.1281515211, -0.0128087942, -0.1127021685, 0.0020183667, -0.1545266956, 0.0971187055, 0.0964068100, -0.2095478773, -0.0371792652, 0.0610931180, -0.1149104312, -0.0549062826, -0.1524933726, 0.1209676191, 0.0209624637, -0.1537603438, -0.1443042010, -0.1262190044, -0.1312285960, -0.1361233294, 0.0555395372, -0.0148429302, -0.2673052549, 0.0382392965, -0.0840760916, -0.0641630590, 0.0226563122, -0.0908026993, 0.0292834081, 0.0890863314, 0.0021138943, -0.1353946030, -0.0326208957, 0.0456918813, 0.0789134353, 0.0262544807, 0.0339396298, -0.0988378674, 0.1024760678, 0.0174482148, -0.0766499415, -0.0135662835, -0.1062350869, -0.1419921964, -0.0228147749, -0.1378357112, -0.1162293851, -0.1366513073, -0.0829873234, -0.0467917807, 0.0738022327, -0.1093466878, 0.0891472623, -0.0299568120, -0.0360354930, 0.0133363791, -0.1587721854, 0.0017645609, -0.0168366041, -0.0257480573, 0.0520011075, -0.1877723783, 0.0432001352, -0.0336280726, 0.0995342955, -0.0584326498, 0.0543788075, -0.0037072622, 0.0230244100, -0.1326670647, -0.0239659511, 0.0093575055, -0.1576079428, -0.1131316796, -0.1745622009, -0.0572995022, 0.1056325808, 0.0598797798, -0.0434736088, 0.0139078060, -0.0841400847, 0.0044637895, -0.0969859362, -0.0352908894, -0.0606338196, -0.1552042663, 0.0576355495, 0.0498201996, -0.1379009038, 0.0204333887, 0.0066633145, -0.1229981631, 0.0212667994, -0.0072275260, -0.0448736884, 0.1047461554, 0.0119122025, 0.1448210329, 0.0311616920, -0.1067376658, -0.0309754536, 0.0986260250, -0.1322901398, -0.1603776515, 0.0355015397, 0.0134278918, 0.0651515871, -0.0752799585, -0.0452444926, -0.0618532673, -0.1913400441, 0.1012649685, 0.1007239223, 0.1031155884, -0.1157550737, -0.0720940232, 0.0761401132, -0.0027348280, -0.4072164595, -0.0042882757, -0.0234156828, -0.2887997627, -0.1351684183, 0.4896679819, -0.1389497370, -0.0378676131, -0.4270389080, 0.4428295493, -0.0367054716, -0.1003713310, -0.1148391441, -0.0370294526, -0.3366177380, -0.3703996241, 0.2482173145, -0.0014663952, 0.2585752606, -0.1650046110, -0.1162860617, -0.0500050038, 0.1064248532, 0.1060120910, -0.0963156298, 0.0205727797, -0.1940562576, -0.0407824181, -0.6819790602, -0.4509029388, 0.2419753224, -0.0337313898, 0.0706733018, -0.0409441702, -0.1064326689, 0.3916301429, -0.1065350473, 0.2118740827, 0.2541170418, -0.0161179435, -0.0783543661, 0.0333338007, -0.1343331337, 0.0181243438, 0.4308632910, 0.1233579144, 0.0342462026, -0.4060163498, 0.0764587894, 0.4334050119, 0.0300550293, -0.7748490572, -0.2010203600, -0.0388022810, -0.1266880333, -0.0906428397, 0.3710671961, -0.0676834062, -0.1328213513, -0.0036841633, 0.1941704452, -0.0864166841, -0.1090648845, -0.0903837010, 0.3278370798, -0.0484304614, 0.5378204584, -0.2859721482, -0.3665353656, -0.1327885687, -0.0144882500, -0.0552973263, -0.1262824833, 0.0127453366, 0.0781445354, -1.4247603416, 0.1244141683, -0.1572927386, -0.1644435674, -0.1133464351, -0.0897331759, -0.0783755556, -0.1248872578, 0.1401174068, 0.0516510755, 0.1208127216, -0.0566620715, -0.0756346211, -0.0500664748, -0.5507315993, 0.0999835655, -0.1103166193, -0.0035790165, -0.0408125296, -0.0064666909, -0.1223780364, 0.0566092506, -0.0332772210, 0.5606215000, -0.0058678044, 0.0233665351, -0.3521713912, -1.5467154980, -0.1445350647, 0.0394576080, 0.3402678668, 0.0283976942, 0.0255171936, 0.1970614195, 0.5293604732, 0.1662773192, -0.1475707591, 0.0792048648, -0.7188987136, 0.0028030870, -0.6859309673, 0.0652024075, -0.0038294452, 0.1321125329, 0.0038157238, -0.2025277764, -0.1585201770, -0.2613477409, -0.1461974829, -0.3418942690, 0.4568955600, -0.0350657478, 0.0673273802, 0.7211645842, -0.0231957696, -0.0461596064, 0.2427615225, -0.1004156992, -0.0998239815, -0.5238364339, -0.0418293327, 0.2800680101, 0.2051448375, 0.1675747037, -0.1464792639, 0.0591093078, 0.0017668798, -0.0559555702, 0.0504319966, -0.6952920556, 0.0029478620, -0.6399558783, -1.0773518085, 0.0360283405, -0.8553457260, -0.0239192415, 0.0676234514, -0.0230787192, -0.0711807311, -0.0640391335, -0.0247115344, -0.3404778838, 0.0730874166, 0.1048454717, 0.0124469334, -0.1933496892, -0.7512643337, -0.0343923308, 0.0406688824, -0.2515331209, -0.1348064244, -0.1629000306, -0.2941430509, -0.7416821718, 0.0348683558, -0.0683046728, 0.0015743766, 0.1826929897, -0.4463121295, -0.1614061594, -0.7849643826, 0.0009917726, 0.0473546758, 0.0348210558, -0.1392803043, -0.0790574104, 0.0513898470, -0.1862992048, -0.0305254869, -0.0757646561, -0.0240310058, -0.2762625217, -0.2065148950, 0.4057438970, -0.8188250065, 0.0605196767, 0.0520843752, 0.0082698260, -0.0276852120, 0.0745706335, -0.8890135884, 1.0702470541, -0.3461233377, -0.1115301847, -1.0906680822, -0.0835200772, -0.0405108035, -1.0842024088, 0.3324888349, -0.1246848106, -0.1468655914, -0.7997804880, -0.0214399416, 0.0505909771, -0.1304426193, 0.1999852061, 0.1040841937, -0.0656492412, 0.0108214216, 0.4951689541, -1.3783116341, -0.0249541923, -0.0273260325, -0.6195361614, -0.1074946150, -0.1030527279, 0.3582951427, 0.0520549640, -0.0656472668, 0.0159425456, -0.7186371088, -0.0692357197, -1.2435209751, -0.0412032828, -0.3034533858, -0.0868209600, -0.4328429699, -1.0147554874, -0.4719572663, 0.1030462161, -0.1899967194, -0.1622602940, 0.0161021091, -0.0061627422, -0.9033393860, -0.0187869817, 0.6257103682, 0.1835357845, -0.0671181157, -0.1295132190, -0.0555709675, 0.1759380102, -0.1601596028, 0.4340251088, -0.0034976304, 0.0480143130, -0.1154864132, 0.0729109943, 0.0344641805, 0.0847997963, 0.0088339448, 0.0114847124, 0.0416055620, -0.1154068112, 0.0018490255, 0.0700043142, 0.0535477996, 0.1236713827, -0.0845707655, -0.0621095896, -0.0343030095, 0.0376124084, 0.0980033278, 0.0598518848, 0.1226590574, -0.0222740471, -0.0785541236, 0.1097527742, 0.1207910478, 0.0010755360, -0.1079896390, -0.1096190810, 0.0736959279, 0.0377863944, 0.1247132421, -0.0221001208, 0.1049102247, -0.0175348818, -0.1170780361, 0.0549095869, 0.1153967083, 0.0829525590, 0.0314325690, -0.0181689262, -0.0866913497, -0.1045442522, 0.0213400722, 0.1044593155, 0.0315643251, 0.0704620779, -0.1151645780, -0.0348796248, 0.0232507885, -0.0326042771, -0.1003147960, 0.0473492146, -0.1077137291, 0.1140520573, 0.0050944686, 0.0216189325, 0.0815984905, 0.0513142943, 0.0931728184, 0.0453358591, -0.0975194275, -0.0710161924, -0.0655887723, 0.0183981955, 0.1163245440, -0.0305046439, -0.0320853889, -0.0856399536, 0.0502272844, 0.0869249403, 0.0280549228, -0.0095427036, -0.0784378350, -0.0337272882, 0.0586032569, -0.0263387263, -0.1204926372, -0.0740732849, -0.0546323657, 0.1070688367, -0.1112009585, 0.0416302979, -0.1075718999, 0.1049637198, -0.0626900494, 0.0033254325, 0.0027003288, -0.0894738138, 0.0098735392, 0.0051865876, -0.0167455673, -0.0370513797, 0.0446405113, -0.1181479096, 0.0140971541, 0.0979942679, -0.0569346547, 0.0198461115, -0.0186496675, 0.0285987854, -0.0308194757, 0.0554256141, 0.0827554166, -0.0126937926, 0.0413732231, -0.0769329965, -0.0029225051, -0.1222736537, -0.1158870161, -0.0596174896, -0.0821850896, -0.0850902796, 0.1204930544, 0.0900786221, 0.0964446068, -0.0639576912, 0.0773660839, 0.0730436146, -0.0889031589, 0.0667804480, -0.0085639060, -0.1156309843, 0.0522961318, 0.1116609275, 0.0056168437, -0.0877453089, 0.0649082661, -0.0036178529, -0.0789988339, -0.1146637201, 0.0765525997, 0.1009785533, -0.1213256717, 0.0458147526, 0.0639470220, 0.0372010767, 0.0062224269, -0.1089667380, 0.0237925947, -0.0429177880, 0.1092168987, 0.0719914436, 0.0122663379, 0.0671079457, 0.1117285490, -0.0465638638, -0.0502771139, 0.0474024713, 0.0814051628, 0.0783734918, -0.0441618562, -0.0155192018, -0.1167747378, 0.0932501853, 0.0010841191, -0.0384605229, 0.0825802684, -0.0151447356, -0.1166260839, 0.0477513671, 0.0328508914, -0.0631927550, 0.0572716296, 0.0156318843, 0.0903718472, -0.1012014151, 0.0255698860, -0.0460514426, 0.0813742280, 0.0775349736, -0.0879695714, 0.1101657450, 0.0753288567, 0.0902386606, 0.1216820478, 0.1070879400, 0.0457127392, 0.0779597461, 0.0999604762, -0.0436871350, -0.0860338211, -0.1152802408, 0.1101982594, 0.1187631786, -0.0789104104, -0.0222502053, -0.0661716461, -0.1190941334, -0.0257061422, -0.0935372114, -0.0485438704, -0.1159111261, -0.1015057266, -0.1081857383, -0.0593861341, -0.0840956271, -0.0536179245, -0.0607124567, 0.0809340775, 0.0555935204, -0.0785136819, -0.0287028849, 0.0503896475, 0.0523648858, -0.0961743891, 0.0741576552, 0.0501502156, 0.0887036324, -0.0395061672, 0.0063793361, 0.0665976703, 0.0904930234, 0.1110050678, 0.0945595205, -0.0877218544, -0.1229402125, 0.1204746962, 0.0452033281, -0.1017537415, 0.0120190084, -0.0816137493, -0.0477264524, -0.0997855067, -0.0987264812, 0.0001307428, 0.0616278052, -0.0945798159, -0.0798372328, 0.0628442764, 0.0054382682, 0.1205001771, 0.0503627062, -0.0744914114, 0.0231569409, 0.0869795680, 0.0069961846, -0.0227925479, 0.0606841743, 0.0260601044, 0.0461531878, -0.0116198063, 0.1057434678, 0.0336305201, -0.0041595101, -0.0482417643, 0.0620912611, 0.0527834892, 0.0222130716, 0.1071096361, -0.0084555447, -0.0684704483, 0.1198033392, 0.0045576692, 0.0719112158, 0.0806180537, -0.0683791935, -0.0697099864, -0.0619981587, -0.0040145516, 0.0129670799, -0.1113457680, 0.1215524673, 0.0480854213, 0.1182073727, 0.0211372115, -0.0041796206, -0.0820512474, 0.0502227917, -0.0810549259, 0.0159358680, 0.1012765914, 0.1268137842, 0.0552509911, -0.0292310417, -0.0249549318, -0.0761191696, 0.0865701884, -0.0821435824, 0.0071480926, 0.0440140963, -0.0582536869, -0.1074746177, -0.0905812979, 0.0212046802, 0.0247257352, -0.0860223472, 0.0670038462, 0.0294222087, 0.0297373235, 0.0141873658, 0.0401765406, -0.0701611713, 0.0410493575, -0.0010265112, 0.0983036608, -0.0932426900, 0.0329355970, -0.0503271222, -0.0480252802, -0.0807374418, -0.0676288605, -0.1133556664, -0.0918397307, 0.0533915795, -0.0753967017, -0.0442639887, -0.0048939940, 0.0764220357, 0.0758463740, 0.1281310618, -0.0754104853, -0.0711186826, -0.0334045179, 0.0014184128, 0.0383571088, 0.0939513147, 0.0348709710, -0.0006647420, -0.0578461401, 0.0591746122, 0.0568595491, 0.0191818178, -0.1042349860, 0.1062676087, 0.0440917090, -0.0361559168, -0.1059017479, 0.1113381982, -0.0921451151, 0.0507786274, -0.0378369689, 0.0978575796, -0.0607582107, -0.0803372562, -0.0776875913, -0.0175652485, 0.0669003725, -0.1288368106, 0.1194127202, 0.0591617823, -0.0589113235, 0.0942590460, -0.0867341459, 0.1023609713, -0.0606081784, 0.1000563130, -0.0394479036, -0.0488891117, 0.0280134678, 0.0055488348, -0.0872589350, 0.0157254934, -0.0400461555, 0.0494482517, 0.0969918221, 0.1069928333, 0.0926292464, -0.0937774926, 0.0471685231, 0.0766161159, -0.0362159684, 0.0513947010, -0.1203017682, 0.1115291715, 0.0800210536, -0.0457078740, 0.0520225167, -0.0323217511, 0.0487749875, -0.0821906626, -0.0834629089, 0.0600339547, 0.0834352672, 0.0098220408, 0.0723429024, -0.0975466892, -0.0667224824, -0.1191657782, -0.0662050247, 0.0155241787, 0.0603209473, 0.0990034789, 0.0204051454, -0.0319963433, 0.0913461372, -0.0500647686, 0.0507912040, -0.1068060324, -0.1116872132, -0.0832505971, 0.0923335403, 0.0039425222, -0.0954489112, 0.0338982940, 0.0416150950, 0.0517549478, 0.0468181260, -0.1174203455, 0.0373981185, -0.0250889547, -0.0011423388, -0.0291103311, -0.1130312979, -0.0422716439, -0.0795233995, 0.0574747324, 0.0644360706, 0.0211672504, 0.0600593984, -0.0422250926, -0.0316226482, -0.0977348685, 0.1028328836, 0.0564569533, 0.0797362030, 0.0413441584, 0.0682429671, 0.0141650736, 0.0054450142, -0.0643635690, 0.0249419194, 0.0292356219, 0.1228458360, 0.0383852422, -0.0001478681, 0.0422833264, 0.1128219217, -0.0485888720, -0.0815421417, -0.0884084105, -0.0371166617, 0.0673798248, -0.0626169816, -0.0692857504, -0.0361198485, -0.0472548269, -0.1099243462, -0.0800534636, -0.0065227360, -0.0715887770, 0.0609906018, -0.0389262736, -0.0531192422, -0.0813346505, -0.1103561819, -0.0054422272, -0.0329938233, 0.0716866851, -0.0352704227, -0.0296713151, 0.0973487794, -0.0987732261, 0.0659209266, -0.0140704894, 0.0641081333, 0.0030917227, 0.0579445064, 0.0049349470, 0.0514517874, 0.0706458837, -0.0448859930, -0.1038849205, 0.0873359069, 0.0267148577, -0.0531118773, 0.1067784131, 0.1096809804, 0.0388305485, 0.0078575956, -0.0279580951, -0.0791780353, -0.0002228320, 0.0535019785, -0.0476299115, -0.0479493067, -0.0606843233, 0.0867131203, 0.0210166518, 0.0257989466, 0.0185326934, -0.0689946339, -0.0756676048, -0.0905913115, 0.0863626897, 0.1074674129, 0.0627315342, -0.0098703504, -0.0937407911, -0.0478231907, -0.0845144838, -0.0654201210, -0.0328855589, -0.0284530222, 0.1025839522, 0.0557358861, -0.1024169847, -0.0455303155, -0.0426687747, -0.0856391490, -0.0472121462, 0.0382798910, -0.0809311196, -0.0715093911, 0.0017287135, 0.0024949673, 0.0214886051, 0.0623031482, -0.1222175360, -0.0419421494, 0.0293343663, 0.0687271059, -0.1189768016, -0.0692573264, 0.0309500601, -0.8574705720, -0.4630538225, -0.0912721679, 0.1134832501, -0.0211245269, -0.2677780390, -0.0110940849, -0.0608395152, 0.0272541568, -0.0197609607, -0.9736248255, -0.0230122078, -0.0149603561, 0.0886866003, -0.2655176222, -0.0122230994, -0.0315503292, -0.1858562678, -0.1361451745, -0.2784285247, -0.7569509149, -0.5103895068, 0.0023351728, -0.2809233665, -0.0337510407, -0.0942421034, -0.0726455823, -0.7170623541, 0.2207240760, -0.0401522964, 0.0077557960, 0.7224842310, 0.0083128344, -0.0485751890, -0.3370265365, 0.1705015749, -0.0803805739, -0.0221554507, -0.0054189875, -0.2253112942, 0.0159625169, -0.0541548543, 0.3098195195, 0.0504812561, -0.4926602244, -0.1299732924, -0.0974846259, 0.0848161206, -0.2827406228, -0.2941738069, 0.1066144407, 0.0522745363, -0.2324075848, -0.1207353845, -0.1474615782, -0.0734371692, 0.0774789602, -1.0062201023, -0.3862614930, 0.0062498958, -0.0005200224, 0.0667785779, 0.0375827774, -0.1433086395, -0.0003271452, 0.6247109175, -0.1562165618, -0.0595314465, 0.0582875088, 0.1406681985, -0.0933757350, -1.3249999285, -0.4512492120, 0.3807759583, 0.1266988665, -0.1668301672, -0.0622567944, -0.1905068904, -0.0688299909, 0.3982199728, -0.7104515433, -0.4780128002, -0.0820818916, -0.0390219018, -0.1150553524, -0.0666605532, 0.5066208839, 0.0189965367, 0.3326912522, 0.0304467641, -0.1255848259, -0.0610150397, 0.0859455764, -0.0375726223, 0.2043598741, 0.8714053631, 0.0463198647, 0.0411200225, -0.0424541198, 0.0037747768, -0.1643580347, 0.2513489127, -0.1121050790, -0.5660282969, -0.0381627157, -0.1471880823, -0.2958441079, 0.1233822256, -0.0312850177, -1.7205955982, 0.0677535757, -0.1270856559, -0.1388257891, -0.1413923055, 0.0488538295, -0.0144046135, -0.1046626940, -0.3417044282, -0.6832088232, 0.0623415112, -0.1045048460, 0.1702883542, 0.0348778516, 0.3984447718, -0.3629113138, 0.0059111905, -0.0832130909, -0.0855746120, -0.1691325158, 0.0349280983, 0.3619013727, -0.0635212883, -2.4040064812, 0.0408176295, -0.0484405607, -0.0445248820, -0.6449678540, 0.0387098044, -0.1707309186, 0.0135216620, -0.0298998710, -1.0934267044, -0.6415784955, 0.0423641764, -0.1602284461, -0.1046150029, 0.0127387885, -0.1534665674, -0.0226547923, -0.0032496273, 0.0871991292, -0.0905480906, -0.4787014425, -0.1458581090, -1.8479492664, -0.0231835134, 0.0121969683, 0.0202565361, -0.0916366577, -0.0320644155, -0.3429425061, -1.1268105507, 0.0239271875, -0.1355971396, 0.0110256821, 0.3159656227, -0.4116885364, -0.0354671068, 0.1121025383, -0.3445430100, -0.0886502340, -0.0807682201, 0.2523255944, 0.8105721474, -0.0002199324, 0.0405848622, 0.0806697011, -0.5733981133, -0.9565352201, -0.0149460547, -0.5848662257, -0.0095364498, -0.0942482129, -0.1535327435, 0.0766807944, -0.1181480214, -0.4750484228, 0.0088906530, 0.0170446299, -0.0367915221, -0.0260340944, -0.6468365192, 0.9025226831, 0.2890905142, -0.6375030875, 0.2810847461, -0.2620694637, -0.1856115758, -0.0975780785, -0.3579650223, -0.6233797073, 0.0437311046, -0.8979043961, -0.1696013510, -0.0264283102, 0.0568794981, -0.0300243963, -0.3241315186, 0.1619948745, -0.1567096263, -0.1080006212, -0.3805651367, 0.0461206175, -0.9381959438, -0.1193498448, -0.6032488942, -0.2235030681, -0.0869680122, -0.1025926322, 0.0903315991, 0.4278299809, 0.0421970002, -0.1419103593, 0.0964162797, 0.0667978674, 0.0292372983, -0.7233192325, 0.0210490637, 0.0552635901, -0.0447778180, -0.2810147405, 0.4309293032, 0.4752773046, -0.1971602887, 0.0970042720, -0.1292565167, -0.0642953590, -0.3918398619, 0.1527980119, 0.0929200351, -2.3522582054, 0.0241735242, 0.0432757437, -0.0067455703, -0.1447818130, 0.0320544951, 0.5442355871, -0.5054734945, -0.0442154370, 0.0611607246, -0.1129673272, -0.0886935070, 0.1335677058, -1.6889766455, 0.0930948704, -0.0580088757, -0.3368935287, 0.0859257281, -0.0874486864, 0.0521252751, 0.0777854174, -0.1876752079, 0.1198093370, 0.1208632514, -0.1776579171, -0.1905485392, 0.0381307602, 0.0556646585, 0.1038481072, -0.0243286900, -0.0072267056, -0.0327079929, -0.1799374670, 0.1035839617, 0.0656554401, -0.0041112378, 0.0914570689, -0.0169258770, -0.1374829113, 0.0320453458, -0.0000153652, -0.0295904279, 0.1213479638, 0.0387832485, -0.0944798067, -0.0482634343, 0.0629381314, 0.0802939385, 0.0786957145, -0.2877786756, -0.0397187471, 0.0144664319, 0.0287425183, 0.0288237985, -0.0142461564, 0.0141833853, 0.1291346550, 0.0144820279, 0.0399429277, -0.0999349728, -0.0613793433, 0.0876518115, 0.0357270315, 0.0257613175, -0.0593923256, -0.0936316177, -0.0245493334, 0.0476153977, -0.0708881617, -0.0006165504, 0.1011885330, 0.0868658796, 0.1460062265, -0.0377337746, 0.0626973882, -0.1110602245, 0.0197639745, -0.0126117691, -0.0386120714, -0.0321603194, -0.1468939036, -0.1452354938, 0.0661804006, 0.0628544837, -0.0886528939, -0.0968231559, 0.0165110230, 0.0148655111, -0.0824382305, -0.0898717269, 0.0026988804, 0.0402146094, -0.0363186002, -0.1571689993, -0.1149645150, -0.1200676113, -0.0992437676, 0.0418285690, 0.1102225706, -0.1125843748, 0.1053803563, -0.1047578678, 0.0281345360, 0.0087645082, 0.1015143245, -0.0324641541, 0.1098923907, 0.0732175931, -0.1370460540, 0.0654303133, 0.0293703862, 0.0825025439, 0.0298136715, 0.0902813226, 0.0882714093, 0.1052087843, -0.0111649446, -0.0494635515, -0.1074908972, -0.0389044471, -0.0421145856, -0.1122749448, -0.0380991064, -0.1803614199, -0.0316638947, 0.0252175536, 0.0692707598, -0.1043231487, -0.0754394606, 0.0259125363, -0.1400292516, -0.0207540374, 0.0674914122, -0.1208009943, -0.0909769461, -0.1107629687, -0.0567519180, -0.1477885395, 0.0235204063, -0.0833787099, 0.0329080969, -0.0016894809, 0.0675063059, -0.0240815878, 0.1153504252, 0.1351936311, 0.0090387166, -0.0729939714, -0.0678991377, -0.1144053265, -0.0517802089, 0.0182454735, 0.1489592195, -0.2525522113, -0.0369564593, -0.0323962159, 0.0209294632, -0.0721534342, -0.0052655041, 0.1169223711, -0.1267867982, 0.0571465492, -0.0587940626, 0.0537019372, -0.0784214363, -0.1194614321, 0.0421316400, 0.0384551026, 0.0633509979, 0.0868666619, -0.0784197673, -0.1147074997, 0.0143094212, 0.0230228733, -0.0036911070, -0.1142093465, -0.0605408661, 0.0694889352, 0.0306108035, -0.0744863600, -0.0630986392, 0.1035022140, -0.0035052393, -0.1145341694, 0.1139312014, -0.0543392189, 0.0970847160, -0.0264977664, 0.0953264311, -0.0626620352, -0.0888153613, 0.0727195665, 0.0250289440, -0.0017963111, 0.0605251342, -0.0472965650, -0.0637061447, 0.0079591721, -0.1186519563, 0.1061861813, -0.0814213157, 0.0800894201, 0.0519224592, -0.0320112482, 0.0714558363, -0.0366542339, 0.0109546781, -0.0658469722, 0.1718886644, 0.0441514887, 0.0305813868, 0.0640559569, 0.0987958759, -0.0066551268, -0.0987018943, -0.0894756317, 0.1906889528, 0.0096799713, -0.0490579605, -0.0100440132, -0.0883048400, -0.0036822835, 0.0320104808, -0.0779503584, 0.0752445087, 0.0770896003, 0.1000482962, -0.1168835610, 0.0542492867, -0.0144289695, -0.0665387586, 0.0279701836, -0.0623848401, 0.0315496027, -0.0570812374, 0.0143670700, -0.1236218736, -0.0713288411, -0.0118532246, 0.0456907526, -0.1206424981, 0.0076931296, -0.0450923890, -0.1138084829, -0.0132691860, 0.2052623332, 0.0276190490, 0.0469190218, -0.0190397669, 0.0057544047, -0.0775445998, 0.0860201120, 0.0656953678, -0.0167576671, 0.0575191081, 0.0646556020, 0.0723597109, -0.1151884124, 0.0710411668, -0.0742712319, 0.0607596301, 0.1032944322, -0.0664462373, 0.1171903461, 0.0770669803, -0.1012490317, 0.1542660743, -0.0353526473, -0.0673543811, 0.0954128802, -0.3459331393, 0.0902603343, 0.3151211143, 0.0755733550, 0.0824012756, -0.0304033123, -0.0310219172, -0.0956194103, 0.0526266992, 0.0226386767, 0.0515294336, -0.0786672309, 0.1714002192, 0.0457496643, 0.0482906140, 0.0655663088, -0.1081943512, 0.1098222211, -0.0330698229, -0.0263459887, -0.2817743123, 0.0033060794, 0.0155933667, 0.0426975749, -0.0446409620, -0.0656618774, -0.1854689419, 0.0751559287, 0.0277826730, 0.1298738718, -0.0273857042, 0.0325712077, -0.1395164579, 0.0236318558, -0.0857446194, 0.1746401191, 0.1423417777, -0.2086709142, -0.1243421584, -0.1160585135, -0.1531349421, 0.1075076684, 0.0776258633, 0.0206577089, -0.0172754657, 0.1869518012, -0.0341460332, 0.0667803064, 0.0624349900, -0.0068184561, 0.0503608771, 0.0789983422, 0.0883377790, -0.1032395661, -0.0984088778, 0.0164853502, -0.0087151313, 0.0227245651, 0.0380750559, -0.0936459452, 0.0493795127, -0.0921562314, 0.0071689701, 0.0829872638, 0.0279964600, -0.0376070440, 0.0020513928, -0.0306880884, 0.1657196879, -0.0703383163, -0.0054490976, -0.0313684419, 0.0658059120, -0.0301078130, -0.1041177735, -0.1557375342, -0.0460168384, -0.0455907583, 0.0960909724, -0.1026128083, -0.1064026728, -0.0780284405, 0.0922782347, -0.0640477240, -0.2459541559, -0.0781239271, -0.0798915997, 0.0712033361, -0.0773905665, -0.0728123635, -0.3098447025, -0.2995778322, -0.0210784376, -0.0146643817, 0.2154303342, -0.1048405468, -0.0344226211, 0.1853726953, -0.0214419942, 0.0011499888, -0.0975188389, 0.0070417556, 0.0095818574, 0.0929271132, -0.0496450886, -0.0419388339, -0.0657644570, 0.0287307799, -0.0874812379, -0.2622767985, -0.0855245292, -0.2087958306, -0.0492174253, 0.0453679971, -0.0157640222, -0.0822668821, 0.3430228233, 0.1090557426, 0.0654859543, -0.0417855158, 0.1307216734, 0.0523238182, -0.0043669874, 0.0727311894, -0.0320619233, -0.3456859887, 0.0175014790, 0.0343086012, -0.0717422292, 0.0858519450, -0.0082397154, 0.0412110053, -0.0065064272, 0.0239591356, 0.0289768074, -0.0642880574, 0.0417057239, -0.1196077913, -0.1918461621, -0.1445980221, -0.0778695121, -0.0557750091, 0.0186137687, -0.0588532090, -0.1581303775, 0.0072539337, 0.0140564786, -0.0455353856, 0.1057500616, 0.0525015779, 0.0794154257, 0.0984384865, 0.1405275762, -0.1180966273, 0.0757559761, 0.0008349998, 0.0974971503, -0.0582186356, 0.0858902484, 0.0158340298, -0.0568745136, -0.0551391840, 0.0049180416, -0.0578460470, -0.0271035396, -0.0469430164, 0.1643096954, 0.0160231981, 0.0002819122, -0.1498381346, -0.1596320421, -0.0951254368, 0.0295736827, -0.2109009624, -0.0443438105, 0.0226119328, -0.0675409660, 0.1104386449, -0.0501226485, -0.1024094000, 0.0467819870, 0.0199149195, -0.1863403171, -0.0940111354, -0.1148557812, 0.0227879696, -0.0502553657, -0.1805870086, -0.0644972995, -0.2064357698, 0.0812308043, 0.0469343476, 0.0668714345, 0.1150766313, 0.2480028421, -0.7684785724, -0.2108922750, -0.0041147419, -0.2047789544, 0.0447612070, -0.0200400949, -0.0183951445, -0.0435704626, -0.3236644864, 0.0684387907, 0.0456519946, -0.0607556626, 0.0105532026, 0.1089217588, 0.0819730312, 0.1793879718, 0.1411231905, -0.1436676383, 0.1449591964, -0.0468506217, -0.0507639274, -0.0404268354, -0.1018963754, 0.0153561570, -0.0157191008, 0.0539918765, 0.1192431822, -0.1213146150, 0.0712960586, -0.2808562815, -0.0146259284, -0.1232686639, 0.0480441190, 0.0625933930, 0.0467059016, -0.0288348552, -0.1204746813, -0.1018810943, 0.1054007486, -0.5267795920, -0.0746228024, 0.1593044698, -0.0537402257, 0.1027619839, -0.0001115602, 0.0128209963, 0.0372522622, 0.1710558981, -0.0194465183, 0.0381855220, 0.1898420155, -0.0022548803, -0.0537356734, -0.0542367101, 0.0075946706, -0.0325226784, 0.1243649349, 0.0751665756, 0.1283169389, 0.1002015397, 0.0433504283, -0.3975508213, 0.0703319907, 0.2750783265, 0.0712782666, -0.0299053434, -0.5636557341, -0.0057094134, 0.1135673746, -0.0941282362, -0.0959718525, 0.0393500365, -0.0248950366, -1.5705622435, -0.0688040331, 0.0031684127, -0.5657857656, -0.0160583612, 0.0514892265, 0.0293100569, -0.1311417818, -0.0725060180, 0.4730241597, -0.0637235865, 0.1881227046, -0.0128268842, -0.3020296991, 0.3571839035, -0.1412514895, -0.1730903536, -0.2855266333, -0.0178311821, -0.3076433241, 0.0007119303, 0.0732920766, -0.0428774692, -0.0611825027, -1.2180197239, 0.1331034005, -0.1500703394, -0.1006036475, -0.1539526135, -0.0035575673, 0.3144455850, 0.0824316740, -0.2373269498, -0.2101167142, -0.5531176925, -0.0127396770, 0.0010858057, -0.1014371663, -0.1143200174, -0.0528110154, 0.1578705460, -0.1301665157, 0.5907532573, -0.0619696379, -0.5971643329, 0.4025162756, 0.3799332380, -0.6112274528, 0.4052338898, -0.0035455171, -0.2258387059, -0.0055889771, -0.0135140978, -0.1073889062, -0.0051758587, 0.3386114836, 0.1662115455, -0.1117411554, -0.0144478558, -0.0182862431, 0.0437373035, -0.3616886437, -0.0817820802, 0.2234485000, -0.5506572723, -0.0721547082, 0.1096076071, 0.0204258114, -0.0506952889, -0.7046583891, 0.5738130212, -0.2552388608, -0.0604561120, -0.0747972205, -0.0082723303, 0.0008103078, -2.5660445690, 0.0840435922, -0.3027868569, 0.0215515327, -0.0206054654, -0.1349941939, -0.0277272388, -0.1167549416, -0.2795469761, 0.7336219549, 0.0664993897, 0.0181291178, -0.1135227010, -0.0016448247, 0.0377451368, -0.0614806600, -0.0075829760, -0.0640207231, 0.0007899760, -0.0384334102, -0.1794967502, -0.0976847038, -0.1080178916, 0.0780690685, 0.0941514522, -0.0405337214, 0.1159236878, 0.0098913191, 0.4083081782, -0.1927427500, -0.1210844815, -0.0107135186, 0.0703014657, -0.1156389639, 0.3125847280, 0.2397166938, -0.1444037259, -0.0357698537, -0.1906256378, -0.1421457529, -0.0203370173, 0.0726370960, 0.1844444871, 0.2535295486, 0.3632084727, -0.0421963297, 0.0774742588, -0.0627941787, -0.0716811121, -0.0571701638, -0.4718474746, -0.1459738612, -0.0917943195, -0.4176939726, 0.0821769461, 0.3762615919, 0.2623102665, 0.2174464315, -0.0459446497, 0.0067722155, -0.0026201366, -0.0478332750, 0.0006373906, -1.3305119276, -0.7251613736, 0.0247533564, 0.2305607200, -0.1378969848, 0.5946905613, 0.0612624213, 0.2261040360, -0.0169193000, 0.0749824196, 0.0423700847, 0.0877873674, -0.6697247624, -0.0807651058, 0.0071983901, 0.0018324491, 0.4562420845, -0.2068291456, -0.0416001640, -0.1063687205, -0.1160500273, -0.0572199523, -0.8308982849, -0.0658364743, -2.1569840908, -0.1900275797, -0.2445037812, -0.1197230443, 0.0952875391, -0.6934627891, -0.0438257754, -0.1140547022, 0.0352631658, -0.0198960695, -0.0044381930, -0.3245781362, -0.0169949122, 0.0705122203, -0.0029408440, -0.0367411487, 0.0855444968, -0.0133406520, 0.0029003392, 0.1499723196, -0.8471760154, -1.3361715078, 0.0146024572, 0.1035807654, -0.1713045090, -0.0874177590, -0.1563669145, 0.0820106640, -0.1818195879, -0.4548888803, 0.2196158767, -0.4428214729, -0.0094866166, -0.0793248862, 1.9878613949, 0.3916503489, 0.1492734104, 0.2036866546, -0.7851479650, -0.0852153897, -0.1806804240, -0.0908168033, -0.5034615993, -0.3517459035, -0.0344279073, -0.1886732131, 0.1792550832, 0.0624352805, 0.0329614468, -0.0204129051, -0.2966009974, 0.0508263931, 0.6276620030, 0.4604566991, -0.0333174355, -0.1017194539, -0.0352100469, -0.3587573171, -0.8201199174, -0.4387877584, 0.2892007232, 0.3521158695, -0.0115473829, 0.5536617041, -0.3282135725, -0.6786404848, -0.1082035974, -0.0180545207, 0.0236103330, -0.0177921299, -0.2237454802, -0.7997754216, -0.0490455590, 0.1764824986, -0.5273624659, -0.0621087141, -0.1878014356, 0.0707940236, 0.3915249407, -0.2365648597, 0.1737208813, -0.4618040621, 0.0390260108, -0.0835426152, 0.1117790565, -0.0099145751, -0.1233551800, -0.0109780356, -0.7184626460, 0.0698033348, -0.1005973220, -0.2530964613, -0.0772179067, -0.6172699332, 0.0288564265, 0.0150511479, 0.1790829301, -0.0381331742, 0.0020123774, -0.0606929660, -0.1216828972, -0.1019444317, 0.8482705951, -0.0303507466, -0.0116359731, -0.0047864877, 0.1661781371, -0.1565552652, -0.1329128444, 0.0495809540, 0.1441980004, -0.0017497243, -0.3739195466, -0.1112267971, -0.1038061604, -0.1940528601, -0.0924462900, 0.0015904936, -0.1734326482, -0.0281741377, -0.1287924945, -0.1506355703, -0.3782686889, 0.1762190908, -0.1551582813, 0.1088564396, 0.2655622065, -0.9005447626, 0.0300564878, 0.0493795760, 0.0393419974, -0.1145727634, -0.1356633753, 0.0351069197, 0.0586873442, 0.0660641044, -0.0081189023, 0.0967807770, -0.2320000380, 0.1669906378, -0.3764046431, -0.7810223103, 0.1015590727, 0.0586805344, -0.0003138826, 0.0633122623, -0.1649624109, -0.0122343823, 0.1865324378, -0.1366859972, -0.1310280710, 0.0117453774, -0.3492611647, 0.0474986807, 0.1075020283, -0.0895225555, 0.2476203740, 0.0034345947, 0.0070797796, -0.0049917148, -0.0825902596, -0.0505097657, 0.3694279790, -0.3475214839, -0.3622182310, -0.0967312828, 0.0280047897, -0.0769479126, -0.1647431999, 0.4618464708, 0.0677684471, 0.1070810184, 0.0735712275, 0.0334384516, -0.0943405405, -0.0253467020, -0.1082580760, -0.4045064151, -0.0283830743, -0.1820992082, -0.0362334214, 0.0726672038, -0.0432640202, -0.0793690607, 0.2571050525, -0.1912350208, -0.6013016105, -0.0038689722, -0.0848165378, -0.4323610365, -0.6450821161, -0.0316290781, -0.2063559741, -1.4405226707, -0.0087598460, -0.2427769303, -0.4032848477, -0.3563649654, -0.1327981502, -0.0339939259, -0.4452692568, -0.1154313013, -0.1533500254, 0.1908646822, -0.2648524940, -0.0087369895, -0.7446074486, -0.0106818788, 0.0756666809, -0.0111188069, -0.3197917044, -1.2313783169, 0.3151171803, 0.3054061532, 0.0237555914, -0.3718258440, 0.2265322804, -0.0371195748, 0.0441161506, 0.3329965472, -0.6164007783, 0.0020284774, 0.1718521863, 0.0873541757, -1.0065789223, -0.0913662985, 0.0814165771, -0.1791175157, -0.0763026103, -0.0172153488, 0.0172938332, 0.0560729913, 0.1284744740, -2.6745584011, -0.6095178127, -0.0339466408, -0.0910873488, -0.0161996912, -0.0429784544, -0.0556840822, 0.0398436226, 0.0119701289, 0.0079423431, 0.0401643626, 0.3852055073, -0.0484715737, -0.0738070831, 0.0278651919, 0.2310475558, -0.7697657943, 0.0137675237, -0.1565212309, 0.0513639078, -0.1432431489, -0.3112224340, -0.1670715660, -0.4447262287, -0.0148744760, 0.1319623590, -0.0020261332, 0.0873604119, -0.3913134634, 0.0479129367, -0.3357934654, -0.0706423745, -0.0886937603, -0.1335041225, -0.1779271513, -0.1245130077, 0.0377618894, 0.1195680276, -0.1018226147, 0.0277721286, -0.0682686642, -0.0753731951, 0.0695962906, -0.4625837803, -0.0511068143, -1.0121742487, 0.0024256895, 0.0143466089, -0.0630358905, -0.2609770298, -0.4705202579, -0.0382592566, -0.3481648564, -0.1515843868, 0.6153006554, -0.0806921422, -0.0349790454, -0.1382514536, -0.2125778794, 0.0918215588, -0.2799859047, -0.1117552817, -0.0404656865, 0.0786111504, -0.0324508250, -0.5559036732, -0.1568814367, -0.0654699430, 0.0165556874, -0.5990945697, 0.2795672119, 0.0538521260, -0.1244241297, 0.0666342527, 0.0039788182, 0.0609660856, -0.1236358136, -0.1078660414, -0.0921679139, -0.0634000301, -0.4953688085, -1.0048868656, 0.5914235115, 0.0153923882, 0.3256314993, -0.0885946602, -0.5240698457, 0.0613627695, -0.0707258433, 0.3083790839, -0.1303735524, -0.1179560125, -0.0736371949, -0.3893385530, -1.5420070887, 0.0244865976, -0.3472922146, 0.0550862588, 0.0319133662, 0.0640812293, 0.0486441962, -0.3476388156, -0.1212950870, 0.2671056092, -0.0045876801, 0.0876674652, -0.0923399031, 0.1119024754, 0.0419867933, -0.0881339610, -0.0602152944, 0.0818942487, -0.0596982539, 0.0080122948, -0.1025714576, -0.0213050246, 0.0762166381, 0.0850961208, -0.0387558639, -0.0869749486, 0.0106991529, 0.0529548526, -0.0601642132, 0.0329498947, 0.0897676945, -0.0987635851, 0.0341327786, 0.0637719333, -0.0827479661, 0.1167866588, -0.0248419344, 0.1040785313, -0.0049123466, 0.1123910248, 0.1097988188, 0.0485140383, 0.0238382816, 0.0866011679, -0.0968243182, -0.0794892311, -0.0180633962, -0.0717172325, -0.0252324343, 0.1226891875, -0.0933830440, -0.0324790180, 0.0650601387, -0.0105047226, -0.0903003514, 0.0851165652, -0.0611464381, -0.1116985679, -0.0913504958, -0.0353259146, 0.1034671664, 0.0502960384, -0.0230298936, 0.0456927717, -0.1121613681, 0.1046037078, 0.0791002214, -0.0936923623, -0.0010136962, -0.0824413598, -0.0093301535, 0.0875663161, -0.0316190422, 0.1227713823, 0.0876721144, -0.1003160775, -0.0351249278, 0.0886011124, 0.0609687865, -0.0116578043, -0.1174058020, -0.0430867374, -0.0930217803, 0.0866587162, -0.0120661259, -0.0242091417, 0.0295116603, -0.0892260671, 0.0141387880, 0.0852743983, 0.0608547330, 0.0469602048, -0.0490040183, -0.0175205469, 0.0003991127, -0.0172331631, 0.0635668337, 0.0469704866, 0.0815551281, -0.0906105042, -0.0270017982, -0.1004933119, 0.0921680033, 0.1195969284, 0.0124953985, 0.0776281953, -0.0552178323, -0.0010486543, -0.1183051765, 0.0555946827, 0.0323095918, -0.0616587400, -0.0626851320, -0.1131956577, 0.0916986167, 0.1183227599, 0.0771361291, 0.0872821212, 0.0701304376, 0.0048133731, 0.0016728938, 0.0484861434, 0.0271289051, -0.0666385591, 0.0687016547, -0.0224215984, -0.0094188452, 0.0748115778, 0.0155382454, -0.0855495334, 0.0094506741, 0.0190633833, 0.0271292925, 0.1204026043, -0.0657830238, 0.0580765605, -0.0224721432, -0.0915715396, -0.0132131875, 0.0562958121, 0.0108256340, -0.0814286172, -0.0274041891, -0.0521894693, -0.0174001753, -0.0790229738, 0.0878662765, 0.0497479141, -0.0236760378, -0.0239208043, 0.1163421273, -0.0370831192, 0.1130951047, -0.0498217642, 0.0747445524, 0.0696636438, 0.0149773657, 0.0847399235, 0.0661256313, 0.0474016666, -0.0030149519, 0.0540086925, -0.1246787906, 0.0713555515, -0.0189773142, -0.0429934859, -0.0921229422, -0.1052822769, 0.0569266379, 0.0900029838, 0.0498366654, 0.1063887179, 0.0931068063, 0.0151031613, -0.0659132898, -0.0891468227, 0.0354366004, 0.0586668551, 0.0629276633, 0.0666544437, -0.1072963774, 0.0033210218, -0.1146359742, -0.0798393190, -0.0582622588, 0.1108464897, 0.0556185842, -0.0726372898, -0.0273775756, -0.0696914792, 0.0690056682, 0.0027683973, 0.0088440776, -0.0508228838, -0.0701802969, 0.0959466696, -0.0031921566, 0.0634794235, -0.0766376853, -0.0127366185, 0.0432316065, 0.0491048396, -0.0760243237, -0.0003092289, 0.0632397234, 0.0088956654, -0.0417426527, 0.0255821645, -0.0977371633, -0.0834163725, -0.0787207484, 0.0352702737, -0.0786841512, -0.0906445682, 0.1211929619, 0.0814321339, 0.0907053053, 0.1172911823, -0.0982849598, 0.1090497375, -0.0472337008, -0.0001830459, -0.1057636142, 0.0695390403, 0.1238711774, -0.0204917192, 0.1167073548, 0.0505450368, -0.0408421159, -0.0362939239, -0.0997977853, -0.0323751271, -0.0915604830, -0.0509456694, 0.0737055242, 0.0473828614, 0.0671587288, 0.0994868875, 0.1075783372, -0.0698227584, -0.0714105368, 0.1026946306, -0.1110269129, 0.0634761751, 0.0393456221, 0.1081987023, -0.1224412620, -0.1021581590, 0.1114303172, -0.1065963805, -0.0482220650, -0.0684682131, -0.0429616570, -0.0366618931, 0.0280671716, 0.1116406620, 0.0485833287, -0.0407015681, 0.1061554551, 0.0314167738, 0.1126341522, 0.1078964174, 0.0499579906, 0.0096398294, -0.0914174318, 0.0137069225, -0.5033210516, -0.1410508901, -0.5388882756, 0.1314505637, -0.0700289607, 0.1204023138, 0.0050224639, 0.0474885814, -0.0981027260, -0.0978595763, 0.0007555037, -0.0075016432, -0.2003737539, 0.0569084845, -0.1069513559, -1.4257926941, -0.0675134286, -0.0420939438, -0.1421666443, -0.0626806095, 0.0086234640, -0.1056582630, 0.0083653554, -0.0514899530, 0.0170979872, -0.6462324858, -0.0566927418, -0.1017258763, -0.0651336759, 0.3361259997, -0.0425333008, -0.1007353142, -0.1321197599, 0.0079900073, -0.0453355461, 0.0320740938, 0.4596587121, 0.1063332036, -0.0065670167, -0.0652417615, -0.0247408412, -0.0367107168, 0.3978469372, -0.0233502574, -0.4962568581, -0.7119020224, -0.3835153878, -0.0842176080, -0.0147140361, -0.1865861863, -0.1245438829, -0.0861364827, 0.2038163543, -0.0071129077, 0.1244898364, 0.0524262488, -0.0946778059, -0.0908563286, -0.4804313183, 0.0085403873, -0.0474989004, -0.0600401685, -0.2524269223, -0.0381371602, 0.0053511499, 0.0060440004, 0.0040801028, -0.4434349835, -0.0492664501, 0.1301964074, 0.0908907801, -0.2601198852, 0.0301096793, -0.3017299473, -0.0407270454, -0.6228140593, -0.3906904459, 0.0076741520, -0.0211370196, -0.0585233644, -0.0068118866, -2.8860707283, -0.2202980518, 0.4771238863, 0.0028409697, -0.0801916867, -0.1326290816, -0.2136768848, -0.0759610906, -0.2781373262, -0.0111177452, -0.0173169672, -0.0758334994, 0.0606268048, -0.1983938664, -0.0727593675, -0.4128327668, 0.0314585380, -0.0683911890, -0.0155706778, -0.5277867317, -0.0339715965, -0.2387072146, -0.4222487211, -0.1159440354, 0.0452748165, 0.0043729353, -0.1177831218, -0.0083009899, -0.8655683398, 0.0435152724, 0.6413173079, -0.1583269686, -0.0465744212, -0.0534333885, 0.6680055857, -0.6247658134, -0.3846916556, 0.0851874053, -0.0536798388, 0.0869646072, -0.1242845207, -0.1548741460, 0.0445139892, 0.0761953145, -0.4766758680, -0.0028607578, 0.0236062892, 0.0595664233, 0.2321858406, -0.0008448912, 0.0216636658, 0.1611905694, -0.0416169241, 0.2614254057, -0.0066450541, -0.2152774185, -0.0812484249, -0.0419150628, -0.4338117242, -0.1087456644, 0.0488413088, -0.1350980401, -0.0571236908, -0.2368012667, 0.2837883234, -0.1653362066, 0.0992547199, -0.0732786730, -0.0751012415, -0.0266539678, -0.2077046931, -0.5138732791, -0.0087135918, 0.0627730861, -0.0262931995, 0.0238475092, 0.0578191876, 0.1665768027, -0.0763740540, -0.0805570483, 0.0978775322, 0.0297767185, -0.0592782423, 0.0566516854, -0.0107272863, -0.0215406232, -0.2714708745, -0.4676392376, -0.0095095634, -0.1894486547, 0.2548570037, -0.0118386410, 0.6159842014, 0.0748114288, -0.1202428713, 0.3097530007, -0.1571831852, 0.0340716951, -0.2826377451, -0.0847211331, -0.0582523346, -0.0202093832, -0.0804894790, -0.1377539486, -0.0863757581, 0.0048368894, -0.0242861602, -0.0056695379, 0.0132012693, -0.1184560806, 0.0346737020, -0.0120223220, -0.2917467356, -0.3097280264, -0.5849518180, -0.0915232375, 0.1014613584, -0.0170704313, -0.0873132274, 0.0547499657, -0.0892722979, 0.0235257130, -0.2190822512, -0.0262003168, 0.1439220756, -0.0634213611, 0.0150895389, -0.1092826054, 0.0475862697, -0.0146816950, 0.1871153861, 0.0097767906, -0.9229723215, 0.0453655794, 0.0169377774, 0.0689934865, 0.2002079934, 0.1480653286, 0.0504487753, -0.0898092240, 0.5487204790, 0.1597932130, -0.0679644048, 0.0763945132, -0.0365242548, -0.0085162567, 0.2537998557, -1.3693308830, 0.0865741447, 0.0909208059, -0.0872820392, -0.1323850304, -0.2990935743, -0.4496690333, 0.0363903344, -0.2827361822, -0.6123367548, 0.8893025517, -0.0182469431, -0.0246027764, -0.3383779228, 0.0853029564, -0.1931861490, 0.0604597330, 0.0228080750, -0.0870113298, -0.0973301902, -0.3568671048, -0.0328889862, -0.1302264929, 0.2711325586, 0.0461424738, -0.1246874556, -0.2002545297, 0.1498815268, 0.1610796303, 0.0322060883, 0.0171454940, -0.3388111591, 0.0685301870, 0.5130409002, -0.0089978073, -0.1687266082, -0.0433314219, 0.0724655911, -0.0985769108, -0.0988371670, -0.2297333777, -0.0660181567, -0.0570353083, -0.1697407961, 0.1035083309, 0.0065872883, -0.0266160388, -0.0350687727, -0.0946861282, 0.1562877446, -0.1136388779, 0.0208295714, -0.0246733576, -0.0506703109, -0.0943003371, -0.0021186073, 0.0252233651, -0.1696304083, -0.0602797158, -0.1308592707, -0.0807028785, -0.0015429399, 0.0357083715, 0.1458579600, 0.0396640711, -0.0419452786, -0.0543436930, -0.0065235598, 0.0097818514, -0.1123670414, 0.0304056089, -0.0182450023, -0.2439369559, -0.1999094337, 0.2615689337, -0.0121031925, -0.0657280833, -0.1033603698, -0.0097376201, 0.0227238927, 0.0121909678, -0.1619299203, 0.1351033896, -0.1526102424, 0.1836012453, 0.0403561927, -0.5781729817, 0.0479999073, 0.0296436567, -0.0480659604, 0.0077591436, -0.0198008027, -0.0247662980, -0.1493311077, -0.0307748411, -0.0661226660, -0.0439965017, -0.1001957729, 0.0266225450, 0.1425350308, 0.0693658069, -0.1893818080, -0.4475166202, -0.0751372278, -0.3513197303, -0.1384898424, 0.0771024153, 0.0017849198, -0.1606111526, 0.4087115824, 0.4062757492, -0.0475493707, 0.0172009412, -0.0576590411, -0.0245892070, 0.0983228758, -0.0032502378, -0.1164827049, 0.1702946424, -0.0372648761, 0.0541285761, -0.0647087917, -0.1337096840, -0.0066022072, 0.1682455838, -0.1604107171, -0.1339123994, -0.0096468516, -0.1574800462, 0.0023532030, 0.0013683944, -0.2083752602, -0.1829008013, -0.0545326211, 0.0244875867, 0.0983815417, 0.1173978373, 0.0892462730, -0.0987176523, 0.0652455464, -0.5199195147, 0.0266945418, 0.0283471420, 0.0266720559, 0.1419401318, -0.0062399684, -0.0793216825, -0.1221431866, 0.0750755593, -0.0506646149, 0.0392702110, 0.0397372916, 0.0504728258, -0.1260688901, -0.1253941208, -0.0739787519, 0.0357548222, -0.3473018706, 0.0825917497, -0.3253275156, -0.2066840529, 0.0546731427, -0.0137486905, 0.0629486442, -0.0439157449, 0.0345069468, 0.1368483454, -0.0218374170, -0.0097521879, 0.0114769451, -0.1797471344, -0.0470421910, -0.4161778390, -0.3379325271, -0.0475195870, 0.0144009963, 0.0026038375, -0.0332202390, 0.0531744584, 0.0019585316, -0.0820289925, -0.1781002879, 0.0117666256, 0.0159452278, 0.2418532372, -0.1041257977, -0.1065492705, 0.0386894941, 0.0449827798, -0.1469042599, -0.0151548395, -0.3530255556, 0.0458796807, 0.0544689037, -0.0304165501, -0.7162126303, 0.0497766808, 0.0871427804, 0.0818013847, 0.0492335558, 0.0535583422, 0.0167480055, -0.0451550037, -0.2272564620, -0.0344616957, -0.1237694696, -0.0926407799, 0.0922721103, -0.3316317499, -0.0211787149, -0.0868952051, -0.0126952613, 0.0187678002, -0.0875912085, -0.2975577116, 0.0669258311, 0.1122191027, 0.0161691010, -0.2045741826, -0.0650278777, -0.0477339253, 0.0434440859, -0.5700750947, -0.0293559767, -0.1066967174, -0.0130769433, -0.2698524594, -0.0465207621, -0.1258869767, 0.1181614697, 0.0468958355, -0.6973327398, -0.0685173795, 0.2882121205, 0.1366249770, -0.0789983794, 0.0200623106, -0.4360837638, 0.0570986047, -0.0223120078, 0.1782220304, -0.0400059335, -0.1467386186, -0.0167650040, -0.1208925024, -0.0712997839, -0.1746024787, 0.0320718288, 0.0092024766, 0.2315962315, -0.3104517460, -0.0160286184, -0.1172302365, -0.3394725919, 0.0297600329, -0.1637226045, 0.1764982492, -0.0266890321, 0.0471380763, 0.0597524606, -0.0077552036, 0.1199850515, 0.0206360389, 0.0736461356, 0.0176554359, -0.0639676303, -0.0327905081, 0.0853668079, -0.0841879025, -0.0416753553, 0.1206347495, 0.0739709884, -0.0823863596, -0.0525333658, -0.1088968515, -0.1481464803, -0.1626697332, -0.0408846810, 0.0233094450, -0.1864882708, 0.0156622902, -0.0949993357, -0.1668725461, -0.0930722952, 0.0356392711, -0.0081867874, 0.0708220899, 0.0973175466, -0.0080136359, -0.0447625816, 0.0017887355, -0.0637772977, 0.0957409069, -0.0932290778, -0.1053627729, 0.0011277497, -0.1183906496, -0.0623153150, 0.0516710170, 0.0688105151, -0.1151215807, 0.1180573553, -0.0323568434, 0.0010196269, 0.0031958555, 0.0375821292, 0.0053304075, -0.0363083482, 0.1123862490, -0.0442974381, 0.1193520129, 0.0278177559, -0.0341724455, -0.0354603939, -0.1095786095, -0.1057901680, 0.0493983328, -0.0661876202, -0.0635966063, 0.0236125253, 0.1302126944, -0.0319043398, -0.0244709551, 0.1014843956, 0.0872851238, 0.0784864426, 0.1001986563, 0.0284013022, 0.1006961167, -0.0983600318, -0.0596103668, 0.0509829372, -0.0723300055, 0.0510473959, 0.0329831243, 0.1106952652, -0.0967362300, -0.0948150828, -0.0331237018, 0.0800073445, 0.0134239970, 0.0501093790, -0.1218604147, 0.0798988268, -0.0934177935, -0.0861345530, -0.0497702397, 0.1283219159, 0.0868700966, 0.1050799787, 0.1093991101, -0.0936887041, -0.0877981186, 0.1216642559, 0.0889846385, -0.0985768735, -0.0543111265, 0.0262090284, 0.1060446799, -0.1129442453, 0.0728521422, 0.0190314353, -0.0028805137, 0.0623326525, 0.0499758124, 0.0607011802, -0.0880304873, 0.0214455724, -0.1135127246, 0.0120600164, 0.0455256104, 0.0737270564, -0.1109255552, 0.0156001700, -0.0850650966, 0.0530831516, 0.0987431407, -0.0236734152, -0.0183515251, -0.1191470325, 0.0680790320, 0.0073998868, 0.0375367291, -0.0087020025, 0.0122422576, -0.0138518093, 0.0810338780, -0.0667119846, 0.1050052419, -0.0181986094, 0.0490105450, 0.0695776343, 0.0723674074, -0.0422870629, 0.0227570236, 0.0604534782, 0.1177623868, -0.0515527129, 0.0605415553, -0.0749756470, -0.0896998048, -0.0312689282, 0.0326637030, -0.0569055527, -0.0024417639, 0.0532227755, 0.0457235463, 0.0933648050, 0.0382222645, 0.0304107070, 0.0838942751, 0.1298205256, -0.1125870273, -0.0009784102, 0.1228289306, 0.1191779599, -0.0726898909, -0.1038038507, -0.0582794249, -0.0045284391, -0.0298072062, -0.0015048385, -0.0861627758, -0.1107397154, 0.1045351401, 0.0014748242, 0.0623782277, 0.0573661812, 0.1211856902, 0.0405225866, 0.0097493827, -0.0157370567, 0.0804852620, -0.0861840844, 0.0659943148, -0.0016634166, 0.0489479899, 0.0953822434, -0.0741617084, 0.0287797749, 0.0916770473, 0.0235442817, 0.0993415788, -0.1123557016, -0.0823246539, 0.0817995965, -0.1174619198, 0.1071101427, -0.0705534890, 0.0965681672, -0.1045183614, 0.0911224931, 0.1112467051, 0.0947793052, 0.0244660638, -0.1121222079, 0.0091933357, 0.0782950222, 0.1152344942, -0.0763644055, -0.0807356015, 0.0214208364, 0.0341319442, 0.1133573130, -0.0468273759, -0.1100687161, 0.1100044623, -0.0262547228, 0.0112200081, 0.0356207192, -0.0797332823, -0.0482249856, -0.1054366827, -0.1099116877, -0.0234909058, -0.0203334689, 0.0333389640, -0.0547401123, -0.0273838639, -0.0848359242, -0.0465394743, 0.1183083579, 0.0476100147, 0.0269684494, 0.0132427812, -0.0207522549, 0.0765229836, 0.0817818791, -0.0763365626, 0.1086228415, 0.0478952229, -0.0184635222, 0.0294839740, 0.0743806958, -0.0854319409, 0.0936479792, 0.0906949639, 0.0488981605, 0.1067115963, 0.0345644690, 0.0372291803, -0.0521085262, -0.0874753594, 0.0365065336, -0.0393310189, -0.1198797226, 0.0050775409, 0.0175660513, -0.1080818474, 0.0374454446, -0.0558101535, -0.0696972907, 0.1235976517, 0.1076329648, 0.0094885230, 0.1282442808, 0.0245378017, 0.1211209297, -0.0244499445, -0.0014925599, -0.1114946604, 0.0584648475, -0.0655108392, -0.1119153872, -0.1180659309, -0.0837406889, 0.0605298877, -0.0001869798, 0.0501852632, 0.0981641412, -0.0605418906, -0.1245776713, 0.0196929369, 0.0248039104, 0.0003789043, -0.0518817715, 0.0063455701, -0.1134332120, -0.0940697193, 0.0777843893, 0.0185922515, -0.0374552049, -0.0658340901, -0.0224328861, -0.0036063502, -0.0471712202, 0.0665223971, -0.0912281945, 0.0798857659, -0.0984259024, 0.1563297659, -0.1059708521, 0.0264560729, -0.1188242435, 0.0032226804, -0.0710804090, 0.0648766831, -0.0702931285, 0.0700192004, 0.0339958370, -0.1437192112, -0.0088555571, -0.0516445823, 0.0605191812, -0.0331019759, -0.0448311009, 0.0486928187, -0.0009997510, 0.0616269931, -0.0691500157, -0.0257092733, -0.1149756461, -0.0172664784, 0.0348364376, 0.0903934389, -0.0445569046, -0.1294181198, -0.0484642349, 0.0512005836, 0.0865185633, 0.0911687240, -0.0271543711, 0.0309252460, 0.1342251152, -0.0060866177, 0.1075724289, -0.0876528919, -0.0541560501, -0.0166827124, 0.1246487796, -0.0955718830, -0.0241406541, -0.0476686917, 0.0602188110, 0.0404977873, 0.5145181417, 0.0922936052, 0.0807019249, 0.0195271354, 0.0806771144, 0.0766443014, -0.0832446590, -0.0166909508, -0.1060467884, 0.0773655325, -0.0730267763, 0.0514286943, 0.0493109263, 0.1163381264, -0.0959891379, -0.0005289766, -0.0345794782, 0.0832479596, -0.0571488589, 0.1406756341, -0.1165110245, -0.0610634200, 0.0657169223, -0.1021773443, -0.1447833627, 0.0867128745, 0.0527423993, 0.1003793925, 0.0251753330, 0.0587803461, -0.0137725556, -0.0326429904, 0.0065502282, 0.2078949511, 0.0930536091, 0.0757422745, -0.0331476219, -0.0033098147, -0.0462277830, 0.0948189273, -0.0397626311, 0.0669611916, -0.0916464254, 0.0304525252, -0.0286022052, -0.0084610945, -0.1976346076, 0.0012790476, -0.0235534459, 0.0240118671, -0.0627451837, -0.0756546333, 0.0374720432, 0.0594260693, 0.0954513401, 0.0789946243, -0.0662825480, 0.0615166090, 0.0784888789, -0.0526184738, -0.0802303702, -0.1118761748, 0.0417687967, -0.1198688447, -0.0870295465, 0.0958170444, -0.0733292103, -0.0757175311, 0.1708898544, -0.1102503911, 0.0636293367, -0.0414769128, 0.0104984939, 0.0897464827, -0.0109805055, 0.0487741232, 0.0205903482, 0.0330846347, -0.0690820664, 0.0227604788, -0.0158976018, -0.0306796823, -0.0918876231, -0.0005088769, 0.0246643815, -0.0169163104, -0.0054020970, -0.1534613520, -0.0068802917, -0.1042969823, -0.0954184458, 0.0126848314, -0.0722744539, 0.0127202542, 0.1055031568, 0.0696292371, 0.0908664241, 0.0528720170, 0.0493660383, -0.0118890377, -0.1244410872, 0.1547476053, -0.0941393897, -0.1649130136, -0.0233838670, 0.0483245850, 0.0434379876, 0.0328755528, -0.0407890826, 0.0685003623, 0.0702496693, 0.0501579344, -0.2755021751, 0.0448440164, 0.0835936591, 0.1436202228, -0.0134264817, 0.0318251625, -0.0033391488, -0.0060599637, -0.1060970724, -0.0653319955, 0.1260751486, -0.0536328480, -0.0457854532, 0.0189024117, 0.1014670804, -0.0646541417, 0.0890616104, -0.0317622423, -0.0462100655, 0.0184852686, -0.0301138647, 0.0492631271, 0.0266202465, -0.0231663939, -0.1068244278, -0.0546898544, -0.0203648377, 0.0186541472, 0.0317998677, 0.0853563100, 0.0350793973, 0.1065567881, -0.1096297726, -0.1262119561, -0.0765630454, -0.0516959429, -0.1192239597, 0.0838745087, 0.0847318321, -0.0260214508, -0.0770599172, -0.0801285282, -0.0334143974, 0.0267596822, 0.0635713860, 0.0635340661, -0.0626222640, -0.0908434093, 0.0130854771, -0.0053842743, -0.1965227574, 0.0561270192, -0.1412266791, -0.0004787363, 0.0456075147, 0.1077920347, -0.0459563285, 0.1082898155, -0.0319239125, -0.0126122395, 0.0916958302, -0.0221335255, 0.0735881627, 0.0219603907, 0.0804556832, 0.0265024416, 0.0677876920, -0.0872724205, -0.0529894382, -0.2712954581, -0.0400019772, 0.0798287988, 0.0790093765, -0.0304614250, -0.0566339046, 0.1119945049, 0.0083600190, -0.1309591383, 0.0955657139, 0.1384320706, -0.0326086357, 0.0026471061, 0.0911973715, -0.0450571291, 0.0476731099, 0.0032124557, 0.2213652432, 0.0241104271, -0.0298250653, -0.1795077771, 0.0885559246, 0.3021232188, -0.0468424000, -0.1213619635, 0.1144025177, -0.0164784212, 0.1003469601, -0.0254779067, -0.0972126946, -0.1103074402, 0.0605997480, -0.0642939284, -0.0139974952, -0.0998896211, 0.2376788408, -0.2439778149, 0.0297601223, -0.0486579090, -0.1476729959, 0.0210309364, 0.4218706489, 0.1313690096, 0.5002856851, 0.0008679516, -0.0269124024, -0.0986807570, -0.1084309444, 0.0119091207, 0.0736110136, -2.8177664280, -0.1265268326, -0.0409516990, -0.4265384376, -0.0258392021, -0.1725283116, -0.1834277660, 0.4415636957, -0.1852543801, -0.0003029660, -0.0991749167, -0.1428291202, -2.0639479160, 0.0027451369, -0.3736858964, 0.1727970243, -0.0442140847, -0.0397836342, -0.0703362450, -0.1650325805, -0.0568640828, -0.5489420295, 0.5505984426, 0.0347746834, -1.1258729696, -0.0718314201, -0.0264662560, -0.2992531657, 0.2660163939, -0.8979872465, -0.1227580905, 0.0261469278, -0.5283687115, -0.1218981519, -0.1058835387, 0.0287450068, -0.0083655873, 0.1696010679, -0.0385545939, -0.0024907198, -0.1657303721, -0.7793917656, 0.1134429574, -1.7116757631, -0.0514953695, 0.0805765614, -1.1083197594, -0.1534316838, -0.1335842907, -0.0176552217, -0.0830497742, -0.1288596988, -1.1653567553, -0.0450946391, -0.2423531562, -0.1027388126, -0.1330327988, -0.0559315830, 0.1900299042, 0.0398916602, -0.4618763030, -0.0039367024, -0.2756842673, -0.0580037609, -0.1489970237, -0.1187598184, -0.2616961598, -1.9663633108, -0.0265823882, -0.0130576072, -0.3545213640, 0.0692524090, -0.1440578252, 0.1743244082, -0.0783663616, -1.2392939329, -0.0045608906, -0.0026403551, -0.2935304046, 0.7221396565, -0.0262230709, -0.1459133029, 0.4480611086, -0.0440307669, -0.0389291309, -0.2134288549, -0.9909749627, 0.0473062284, -0.0433852337, -0.0556491949, -1.4438228607, 0.0554396510, -0.2923733890, -0.0938204750, 0.0060933046, -0.6508024931, -0.2079817057, 0.0183813665, -0.0168294329, -0.1174051911, 0.6957411766, -0.3899160028, 0.0474290885, -0.0829676315, -0.3999269605, 0.3857331872, 0.0016837198, -0.0360666439, -1.9432145357, -0.1474227756, -0.0934145451, -0.0938948467, 0.0560436174, -0.1824104786, -2.0877475739, -0.0481105708, -0.2859140038, -0.0759555325, 0.0294358525, 0.0250494797, -0.0979212746, 0.2791413367, 0.1246375814, 0.1402296722, -0.1295389384, 0.0869153813, -0.1838094741, -0.1136185825, 0.3880605102, -0.0048379283, 0.0341449603, -0.0017002225, -0.2898014486, -0.2367363870, -0.0346827619, -0.1621714085, 0.0103057157, 0.2438883036, -0.0912146047, 0.0191039313, -0.1397937983, -0.2144947052, -0.0550651923, -0.2059104145, -1.0699623823, 0.0035533318, -0.1352273673, -0.1082928181, 0.0735334754, 0.1999212056, -0.4259344339, -0.0393924639, 0.1165401414, -0.0290955026, -0.1256333590, -0.0273934882, -0.0802057609, -0.1378132552, 0.6375073791, -0.0062932963, -0.0911524892, -0.0724938810, 0.0020839202, 0.0256185792, -0.4816829562, -0.1228321344, 0.0820384622, -0.1522554904, 0.2769767940, -0.0006449902, -0.0058254502, 0.0010321713, -0.0989315435, 0.0992097184, -0.3513754010, -0.9293513894, -1.0613204241, -0.0732263178, 0.0248549785, 0.0230603889, 0.2389526069, -0.0499950349, -0.2035583407, 0.4913236201, -0.0811518207, 0.0156604070, -0.0581203662, -0.3193427622, 0.0604098849, -0.0556059256, -0.2054919451, 0.0196488183, -0.3063338697, 0.0281771496, -0.0138528021, -0.2025368512, 0.0546403192, -0.0717913881, -0.5429134369, -0.0064095198, -0.0992598757, -0.1870304793, -0.1229762658, 0.2455301732, -0.0735808983, -0.0246720780, 0.3477255702, 0.1739196926, -0.0034539418, -0.0158302709, -0.5624440908, 0.2103417814, 0.1399947405, -0.1054904014, -0.1030614302, -0.1208543107, 0.4378628433, -0.1394428760, 0.1035994813, -0.5613163114, -0.1049169153, -0.0875753537, -0.0575675741, -0.1933308691, 0.4420520663, 0.5398244858, -0.0229517147, -0.0291530173, -0.2148715258, 0.1611359715, -0.0231564306, 0.0720864981, -0.1879794002, -0.1647129208, -0.0666514486, -0.1077817753, -0.1993230283, -0.1170810610, 0.1585638374, -0.0406448282, -0.1231163740, -0.0333310962, -0.0877336115, 0.0633549541, -0.0318237469, 0.0398784913, -0.0912321880, 0.0136568947, 0.0124001065, 0.1257185340, -0.1185718849, 0.0206433982, -0.0866802707, -0.0812932402, -0.1316146106, 0.0348679200, 0.0059737139, -0.0572338402, -0.0194722638, 0.1045289934, -0.0977293774, -0.0618676469, 0.0057800268, -0.1829807907, 0.0569343306, 0.0022815154, 0.0382963344, -0.1171781346, -0.0930866599, 0.0280790161, -0.0716141090, -0.1349647194, -0.0031708502, -0.0319603011, 0.0701536983, -0.1769835502, -0.0518653356, -0.1493110210, -0.0919398144, -0.0015085287, 0.0324349850, -0.0476067401, 0.0115555031, -0.0456229001, 0.0446027145, -0.0866890997, 0.0558005236, -0.1142195910, 0.0855868533, 0.1253841668, -0.0815079212, 0.0912208259, 0.2496360242, 0.0328055397, -0.0552054122, 0.1157506257, -0.0181299932, 0.0323334970, -0.0029629171, 0.1058871150, 0.0972665846, -0.1284793913, 0.0181875359, -0.0570345223, 0.0717596933, -0.1204822585, 0.0190830529, -0.0200843215, -0.0226044375, 0.2086364329, -0.0033446739, 0.0925207809, -0.0745793283, -0.0404364951, -0.0985433012, -0.0108930403, 0.0645017028, -0.0902168527, 0.0319146551, 0.0634798706, 0.0338330269, 0.0220666528, 0.0717386603, 0.0313854776, 0.0368432924, 0.0491776764, -0.1610988230, -0.1566874981, -0.1203634888, -0.0816373900, -0.1261045486, 0.1206907630, -0.0612066984, 0.1071380749, -0.1026580259, -0.1335049570, -0.0857649893, -0.2715013921, -0.1722457409, -0.0945582986, -0.1043361351, 0.0139164375, -0.0859657750, -0.0237785522, 0.0684963018, -0.0549623482, -0.0020300387, -0.0974421203, -0.1188294291, -0.0490974858, -0.0748622492, -0.1042471305, 0.0579602011, -0.0999283418, 0.0970862880, -0.0592877083, 0.0492864549, 0.0387512706, 0.0085499007, 0.0409879982, 0.0063220654, -0.0223273635, -0.1034624279, -0.0115212956, -0.0743285567, -0.0644781291, 0.0278712325, 0.2941435575, 0.0380462855, 0.0375428461, -0.1294925511, -0.0270594470, 0.0659325123, -0.0003553826, -0.0966046602, -0.1209584177, 0.0332314186, -0.0390371643, -0.1466829926, 0.0808003470, 0.0255878773, -0.0970637724, -0.0611897670, -0.0314437002, -0.1387999803, 0.0085464064, 0.1139209867, -0.0799462870, -0.1001371667, -0.1034577638, 0.0008408599, -0.0505110063, -0.0128293475, -0.2600112259, -0.1048181206, -0.0178651325, 0.0723369718, 0.1032807529, -0.0311342683, 0.2555246055, 0.0376025997, -0.0822462514, -0.0032865673, -0.1239456758, 0.0419384576, 0.0938663557, -0.1163056418, 0.1004817188, 0.0613834485, -0.0196652468, -0.1315966696, 0.1067133769, 0.0113049373, 0.0340003408, 0.0217890423, -0.0939027220, 0.0940176547, -0.0985100865, -0.0978283882, 0.1380370557, -0.0372296385, -0.0951937661, -0.0183518305, 0.0718841404, 0.0571801513, -0.0473841578, 0.0320523083, -0.0959920064, 0.0393929072, 0.0738188401, -0.1007242426, -0.1098652259, -0.0281408951, 0.0045957677, 0.1130713448, 0.0289590154, -0.0866834149, 0.0361516923, 0.0025540583, 0.1379446536, -0.0853325799, 0.0353369750, -0.3030939698, 0.0610332415, 0.0097102430, 0.0468606725, 0.0911468342, -0.1357066631, 0.0746319294, 0.0714394152, 0.0134321926, -0.1101840362, -0.0385970362, -0.0176051166, 0.0722276568, -0.0787600279, -0.0351706594, -0.0176798403, 0.0567396134, 0.0313828699, -0.1531443000, -0.0625753328, 0.0012926536, -0.0968276560, -0.2013152242, 0.0662997961, -0.0169191230, -0.0636067390, 0.1192452013, -0.0821759254, 0.0001568514, 0.0048389295, 0.0551330298, 0.0798498169, -0.1463043392, 0.0456744395, -0.0518958829, 0.0404758640, -0.1097480282, -0.1352586299, -0.2147755623, -0.0494968779, -0.0181127004, 0.0007608944, -0.0438889153, -0.1010653079, -0.1263495535, 0.0038878960, 0.0357421786, 0.0621950477, 0.0204249416, -0.0253215395, 0.0278185066, 0.0534413271, 0.1213581935, -0.0891103372, 0.0950317308, 0.0089296186, 0.1093031690, 0.1359639764, -0.0599047877, -0.0034213511, -0.0001315442, 0.0521394908, 0.0503867567, 0.0457417704, 0.1229213998, 0.1093289331, -0.0889054909, 0.1087742075, -0.1161480844, 0.0609574802, 0.1189563721, -0.0711604655, 0.0137638617, 0.0139110256, -0.1000733674, -0.0517662130, 0.1091052741, 0.0161837656, 0.0669610128, 0.0710138008, -0.0785450414, 0.0758836865, -0.0391649678, -0.0686059892, 0.0719478577, -0.1033579856, 0.0868482292, 0.1387437582, 0.0928232819, 0.0577542819, -0.0392063782, -0.0309611913, 0.0849105641, -0.1150046512, 0.1772566587, -0.1384064555, -0.0119228298, -0.0230992921, 0.1137913316, -0.0217526108, -0.0777969211, -0.1035773233, -0.1087300032, -0.0877128392, 0.0507926196, -0.1112856567, -0.0239374489, 0.0488199666, -0.0672771484, -0.0342927799, -0.0833458006, 0.0971650034, -0.1120546758, 0.0075888042, -0.0230080187, 0.0463939346, 0.0809173137, 0.1500833631, -0.0335258469, -0.0556180999, -0.0782191753, -0.0300343018, -0.0508402474, -0.3517185152, 0.1051150411, -0.0838283896, -0.1147680283, 0.0613204911, -0.1007275507, -0.0118155908, -0.0510564558, -0.0452602133, 0.1182458177, -0.0099141002, 0.0984483063, -0.0073358119, -0.0247870255, -0.0951180235, 0.0810684413, 0.0419295244, -0.0542669855, -0.0818517208, -0.0898990631, 0.0076809796, 0.0080569740, 0.0036040382, -0.0924673751, -0.0607201271, -0.0454326905, 0.0650412887, 0.1244021356, -0.1300380230, -0.0096897120, 0.0231041908, 0.1280875206, -0.0373975188, -0.0857610703, -0.0315754600, -0.0641335919, 0.0770996511, -0.0589820147, -0.1443294585, 0.0743973330, 0.2434277534, 0.0891523063, -0.0689680129, -0.0574263558, 0.0880761072, 0.0261894371, -0.1158305779, -0.0510361567, 0.1302860677, 0.1069855392, -0.0945614651, -0.0982727036, -0.0767295733, -0.0529383793, 0.0366319381, 0.0575307682, -0.1121137589, 0.0374711230, 0.1052692458, 0.1417684853, 0.1346994936, 0.0037915127, 0.0961603150, -0.0737190172, -0.1129877418, 0.1022345200, -0.0372640938, 0.0609183908, 0.0385898873, -0.2214780748, -0.1220309734, -0.1228601709, 0.0433455668, 0.0991585776, -0.0611518025, 0.0903710574, -0.1218790114, -0.1493823826, 0.0324611180, -0.1032646820, 0.0292664245, 0.0628636032, -0.0148844775, -0.0127518540, -0.2566074431, 0.0352868773, -0.0549584143, 0.1008575186, -0.0402667932, 0.0244297162, -0.1111981124, -0.0014700397, 0.0188307539, 0.0280036405, -0.0477897227, 0.0261967350, 0.0771563500, 0.1724541932, 0.0769942477, 0.0744691044, -0.0420765765, 0.0737174153, -0.0683937967, -0.1486788392, 0.0018925088, -0.0757259130, 0.0216529258, -0.0139910448, 0.1028338373, -0.0840604901, -0.0123707950, -0.0004606164, -0.0788220093, 0.0789270923, 0.0560538396, -0.0737400204, -0.0495651551, 0.1158996522, 0.0846172497, -0.0424840674, 0.0495211557, -0.0698327944, 0.0318275467, 0.0016150927, 0.0344237275, -0.0554805174, 0.0392750539, 0.1555249393, 0.2000417262, 0.0309392735, -0.0198572725, -0.0860077143, 0.0126461443, 0.0676630437, 0.0751869977, 0.0749111325, -0.1004526615, -0.0513605252, -0.0273380335, -0.0637171865, -0.1183512062, 0.0924802646, 0.0519777201, -0.0254567936, -0.1151853204, 0.0136089204, -0.0156030357, 0.0813772604, -0.1515579969, -0.1315442175, 0.1129241064, 0.0803980306, 0.0673268363, 0.0261806473, -0.0572545417, 0.0251998398, 0.0355929695, -0.0212760326, 0.0058708419, -0.1067219824, 0.1104552671, -0.0457035229, -0.0821873993, 0.0189306587, -0.0259018298, 0.0801690966, 0.0665229559, -0.0822054818, 0.1526084840, 0.0303284507, 0.0032687425, -0.1012488082, -0.0420401655, -0.1283579469, -0.0645741820, -0.1617830992, -0.0630601048, -0.0896593183, 0.0628913268, 0.0558100864, 0.0499167703, 0.0324800387, -0.0826210752, -0.0529873222, 0.1191450208, -0.0236386191, -0.0127762556, -0.0917964280, 0.0256299414, 0.0693400353, 0.1197944507, 0.0017661263, -0.1153539717, 0.0830425695, -0.1335540414, -0.1207967773, 0.0446128063, 0.0167321302, 0.0104409978, 0.0150126247, -0.1339365393, -0.0171750356, -0.0247980915, 0.0800230280, 0.0218255315, -0.1122527942, -0.0725089163, 0.1075666398, -0.0406661555, -0.0700963289, -0.0798282847, -0.0509491414, 0.1002776995, 0.0666719601, 0.0130243879, -0.1137030199, -0.1180219501, 0.1070262715, -0.0230317414, 0.1109188795, 0.0923428461, 0.0597766452, 0.0906137526, 0.1069310680, -0.1093242243, -0.0538000576, 0.0290149916, -0.1680531949, -0.0929061323, 0.0489099212, -0.0724931434, 0.1260796636, -0.1151139587, 0.0258207079, 0.0029823850, 0.1094793379, -0.0660744682, -0.1168357432, 0.0624530725, -0.0070480970, 0.1775711030, 0.0008267353, 0.1230643094, -0.0662396103, 0.1077729762, -0.1214329600, -0.0009098714, -0.0419369936, 0.0858279169, -0.0681724846, 0.0504760481, 0.0631050169, 0.0720594525, -0.0318338946, 0.0439174697, 0.1011260301, -0.0427899100, -0.0828346685, 0.0015128793, -0.0203011334, -0.0092532719, -0.2823664546, -0.1059856266, 0.0623780303, -0.0169724133, 0.0848701149, 0.0319731012, 0.0672217533, -0.1366273463, -0.1064265519, -0.1148204803, 0.0213885885, 0.0102904430, 0.0045671761, -0.0560672991, -0.1065934747, -0.0707249939, -0.0010490983, -0.0847760215, 0.0352580845, 0.0700093880, -0.0676433146, 0.0543756075, 0.1080520451, 0.0275772512, -0.0807657465, 0.0606764555, 0.0418999866, -0.0785942227, 0.0119797885, 0.1516798735, 0.0312866569, 0.0486028902, 0.0251115337, -0.0682940856, 0.0822584033, -0.1119311824, 0.0764307305, -0.0769474283, 0.1077732518, -0.0477895811, 0.0306472890, 0.0548187606, -0.1062528640, 0.0719892010, -0.0149770072, -0.0742274895, -0.1328069419, 0.0342931673, -0.0465606675, 0.0428659804, 0.0476402789, 0.0471380241, -0.0926986486, -0.1123594269, 0.1329682767, -0.1186186746, 0.0705161840, -0.0039878101, -0.0557402857, 0.0015898261, 0.0798093379, -0.0550720096, -0.0383308157, -0.0609679781, 0.0097317658, -0.0388934352, 0.0706121176, -0.1464681774, 0.0469821841, 0.0638365299, 0.0548198819, 0.0423080474, -0.0388117433, 0.0062659942, -0.0725287721, -0.0311121177, -0.0857484713, 0.0184286349, -0.0275283325, 0.0304145142, -0.0709264800, 0.0002448105, -0.0424217917, -0.0824170634, 0.0586561151, -0.0139698666, 0.0845145062, 0.0269025974, 0.0649159923, 0.0677126572, 0.0351425707, -0.0531627163, -0.1596072316, -0.1065068170, 0.0990088508, 0.0977314934, -0.0439210832, 0.0187577140, -0.0895475298, 0.0202499852, 0.0832763240, -0.0362523794, -0.0776355416, -0.0726229250, -0.0335007608, -0.0082165124, -0.0175923090, 0.0407464132, 0.0334287323, -0.0379721113, 0.0646106824, -0.0694868416, -0.0685854852, -0.0094440375, 0.0611166321, -0.0316303968, 0.0353808738, 0.1445866078, 0.0889074579, 0.0260515604, 0.0911892951, 0.0482453480, -0.1547796279, 0.0965598375, -0.1616863012, 0.0182166807, -0.0933628082, -0.0006066492, 0.1100626141, 0.0426546112, -0.0662966743, -0.0118058324, -0.0359888226, 0.1138770580, -0.0787989423, -0.1131104082, -0.0716908649, 0.1077246815, -0.0722430944, 0.0450070649, 0.0445656106, -0.0462968349, 0.0758407414, 0.0754658058, 0.0202116296, 0.1035989523, 0.1067175269, -0.0310063269, -0.3172970116, 0.1115473285, 0.0664040968, 0.1066528559, -0.0907199383, 0.0960624740, -0.2708115578, -0.0638445392, -0.0493358374, -0.1060408577, -0.0748360753, -0.0860455558, -0.0280857477, -0.0248771552, -0.0693655014, -0.0590009615, -0.2052865326, 0.0410914496, -0.0080010621, -0.0162185878, -0.0592668615, 0.1571427584, 0.0027709266, -0.0149620781, 0.0492562205, 0.0567447320, 0.0088798590, 0.0475962237, -0.0083771870, 0.1211911216, 0.0175330359, 0.0615333430, -0.1237723902, -0.0145504186, -0.0478701927, -0.0583454557, -0.0192610398, 0.0711559355, 0.0420196690, -0.0398741588, -0.0821930692, 0.1157618463, 0.0490965210, 0.0692896694, 0.0166615937, 0.0406874679, 0.0273697749, -0.0974844098, -0.0800771639, -0.0517460257, 0.0281752162, -0.0261897966, -0.0965978578, -0.0755676702, 0.0726483315, -0.0286949389, 0.0696665570, -0.0559689999, 0.1065156385, 0.1040449142, -0.0691165328, 0.0209238324, 0.0315118656, 0.1089870408, -0.0613598861, 0.0594322495, -0.1308504939, -0.0774025023, 0.0529957265, 0.0322093889, 0.0723158494, 0.1097505167, 0.0478340723, 0.0971317440, -0.1065503731, 0.0453964248, 0.0662040189, 0.0780393630, 0.1013707966, 0.0390633903, -0.0902659148, 0.0905678570, 0.0041013807, -0.0240954813, 0.0802812353, -0.0713194683, 0.0517435446, -0.0837261155, -0.1003977358, 0.0197640788, 0.0093389181, 0.0600155890, 0.0409187898, -0.0154461125, 0.0681551918, 0.1040989384, -0.1085442677, -0.1335886568, -0.0287162084, -0.0328158736, -0.1233832464, 0.0019577944, 0.1028632894, -0.1319781542, -0.0605828203, -0.0711064041, 0.0569997989, -0.0317058042, 0.0101636099, -0.0968573987, 0.0413207114, -0.0508565344, -0.0462514497, -0.1299387366, 0.0465685949, 0.0030664478, 0.1159244999, 0.0375581048, -0.1013328135, -0.0651574880, 0.0129831620, -0.2385379076, -0.0433543809, 0.0972917005, -0.0551929548, -0.0421765819, -0.0643120706, -0.0192922000, 0.0302441306, 0.1746109128, 0.0529009178, 0.0218185186, 0.0156032201, -0.1451169103, -0.0569536947, 0.0043929508, 0.1035935804, -0.0527374744, -0.1270792782, 0.1145994812, 0.0004359297, 0.0836802274, -0.0409974828, -0.0552501082, -0.1113986820, -0.0061252853, 0.0199440736, -0.0036828103, -0.1008432359, -0.0593187436, -0.0546593107, 0.1098009199, -0.0754614100, -0.0306842774, 0.0159259085, 0.0890962556, -0.0912599340, -0.1027035415, -0.0098250611, -0.0854038000, 0.1107346639, 0.0517404415, -0.0326386802, -0.0709897131, 0.1134741306, -0.0004698789, -0.1225651428, -0.0920724645, -0.0565965325, 0.0570796803, 0.0419255421, -0.0753829032, -0.0918982401, 0.0135803688, 0.0902742371, -0.0654997751, 0.0591484308, -0.0491236076, 0.0408519916, 0.0444168374, -0.0717076957, -0.0888164341, -0.0900274813, 0.0972123966, -0.0929698274, 0.1066984236, 0.1069647595, -0.0879997313, -0.0208534077, -0.0838822871, 0.0526666231, 0.0100286081, 0.0227816124, 0.0076869428, -0.0366629548, 0.0722610950, 0.0144732781, 0.0069302702, -0.0841708481, -0.0760604590, 0.0768234208, 0.0840783194, 0.0418465063, 0.0965830609, -0.0207501426, 0.1039229631, -0.1758114696, 0.1173719019, 0.0224950891, 0.0847705007, -0.1159255430, -0.1381751448, 0.0880995169, -0.0416127816, 0.0978516266, -0.0685468689, -0.0503882393, 0.1851445287, 0.0676378608, -0.1089788899, -0.0982771441, -0.0152978040, -0.0723177120, 0.0282758307, -0.1177093610, -0.0800251067, 0.0291398969, -0.0896759629, 0.0734346211, -0.0326571241, 0.0976171568, -0.0180690121, 0.0485357866, -0.0844788700, -0.1330889016, 0.0484346896, 0.0500326976, -0.0071322345, 0.0416480564, 0.0781803876, 0.0414815284, 0.0218686592, 0.0207656343, 0.1414558738, -0.0185425375, 0.0384805463, 0.0681900680, 0.0425972454, -0.1567927301, -0.1273126602, -0.1052425429, -0.1005587727, -0.0247195903, 0.0395982377, 0.1436293274, -0.0250716377, 0.0440627337, -0.0352080688, -0.0429540612, -0.0512215346, 0.0653495789, 0.0234623980, -0.0939518511, 0.0956893340, 0.0490617193, 0.0985002443, -0.0578927994, 0.0712692514, -0.0944222808, -0.0331529118, 0.0084337564, -0.0340965204, 0.0653082058, -0.0730803087, -0.0573827773, -0.1893977970, -0.0492328107, -0.0460068174, -0.0049669570, 0.0532345474, 0.0766472816, -0.0180129707, 0.0167515203, -0.0944727361, -0.0913835093, -0.1077719256, -0.0836270675, -0.0915040895, 0.0708658397, 0.0546638072, -0.0139501058, 0.0663349926, 0.1140429825, 0.1330991089, -0.0085028484, -0.0311801434, 0.0642841235, 0.0565806031, -0.0266220216, 0.0393839665, 0.0610225201, -0.0245463904, -0.0680024847, 0.0083898073, -0.0206070244, 0.0917979479, -0.1542118937, 0.0213652495, 0.0954945683, -0.0277154446, -0.0058085565, -0.0446544476, -0.0033496537, 0.0165835880, -0.0914372504, 0.0794147253, -0.0211152621, -0.0076137311, -0.0168542657, 0.0636770204, -0.1274284273, -0.0149428556, 0.1246365011, 0.0028326183, 0.0700881109, 0.0853546858, 0.0497273318, -0.0689220428, -0.0372974947, -0.0684603602, 0.0061289072, -0.0192446113, 0.0401318409, 0.0426650569, -0.0998964012, -0.0195891652, 0.0472419374, -0.0080978191, 0.0090505918, 0.0415260270, -0.0092440816, 0.1213900447, 0.0563630611, -0.0167958252, 0.0861932561, -0.0580147989, 0.0938200280, -0.1013563350, -0.0100994408, -0.0786698535, -0.0981933475, 0.0662398115, 0.0371554345, 0.0583743565, -0.0956713855, -0.0873597637, 0.0512508452, -0.0389871374, 0.0756704509, 0.0740385354, 0.0728710219, -0.0403191298, -0.0888804793, -0.0804797411, 0.0067832172, -0.0026699391, 0.1213800982, 0.1019245684, -0.0146728735, -0.0373635590, -0.0128235342, -0.0250266902, 0.0458866209, -0.0979963541, 0.1108667031, -0.0633193851, -0.0494828969, 0.0225076843, 0.0438844897, -0.0562139899, -0.0877588838, 0.0938822329, 0.0409470685, -0.0439538658, -0.0132103562, 0.1122466996, -0.0698667169, 0.0761897936, -0.0700030327, 0.0135671198, -0.0263649784, -0.0880246907, -0.1014147401, -0.0982751548, -0.1118818521, -0.0168951731, -0.0602144599, 0.0769229531, 0.0448051617, 0.0489020944, 0.0093523366, -0.0670685172, -0.0614743084, 0.1202542856, -0.0836002976, 0.1051392332, -0.0430298112, -0.0045698811, -0.0660234392, 0.0424401797, 0.0478280224, -0.0624351837, 0.1199663728, -0.0706551969, 0.0062023224, 0.0935279578, -0.0373031162, 0.0861558616, -0.0563421920, -0.0593450814, 0.1125129163, -0.1093709916, -0.0920414850, 0.0308510363, -0.0834142491, 0.0673248768, 0.0849863142, -0.0521400422, -0.0955387056, 0.0021279326, 0.0380915739, -0.1135401428, -0.0988413990, 0.0498478450, 0.0066739572, 0.0579954609, -0.1015624106, 0.0729912594, 0.1031829715, -0.1062093899, 0.0349523835, -0.0414571464, 0.0424203761, 0.0614867583, 0.1049318686, -0.0138500249, 0.0347993858, 0.1089750528, -0.0900810063, -0.0351135731, 0.0253267176, 0.0227826517, 0.0114725837, -0.0214837193, 0.1160778105, 0.0653144270, 0.0844158530, 0.0516495593, -0.0174040627, -0.0132027855, 0.0923928618, -0.0146625340, 0.0033806860, 0.0387675166, 0.0290892720, 0.0052340999, -0.0642891526, -0.0699071884, -0.0443021059, 0.0629834980, 0.0649564266, -0.0401702560, 0.0766689330, 0.0490436740, 0.0980528593, 0.0394138396, -0.0582844913, 0.0789108947, -0.1157305390, -0.1052782461, 0.0155371893, -0.0570371859, 0.0976992324, 0.0059950650, -0.0556911156, -0.1076490879, 0.0618228056, -0.0622068718, -0.0248346813, 0.1036180034, 0.0506710708, -0.0869779587, -0.1012774110, 0.1141441539, -0.0941307470, 0.0697902143, 0.0410238244, 0.0737751350, -0.0356369913, -0.1049431562, -0.0724790022, 0.1374894977, 0.1264324933, -0.0235474873, -0.0116713643, -0.0532515049, 0.0438580811, 0.1195486635, 0.0100527732, 0.0926574171, -0.0815110207, -0.0611480027, -0.0179069340, 0.0933181494, -0.0454866365, 0.0547120236, -0.0446951836, 0.0456721373, -0.0197355151, -0.0254035257, -0.0032586157, 0.0653173551, 0.0938872099, 0.1025410593, 0.0158193763, -0.1136642098, -0.0839351118, 0.0629737973, -0.0239972435, -0.0908984244, 0.0878630579, 0.0267966986, -0.1500641853, -0.1318759620, 0.2044903487, -0.0036078799, 0.0553529337, 0.2159637958, -0.0181524307, -0.1105692163, 0.0329806954, 0.0497223437, -0.2517313063, 0.0684925169, -0.1566094458, 0.0136139253, 0.0040410515, 0.2105545104, 0.0142841265, -0.0290574357, 0.0369297601, -0.0009699287, -0.0117506236, -0.0146421259, -0.4440849721, 0.1352885365, -0.0104381824, 0.1350108832, 0.0465019941, -0.0569603071, 0.0756146014, -0.3372476697, 0.8156668544, 0.0406819321, -0.1133791581, -0.3214869201, 0.0220027640, -0.1869029254, 0.0486990251, -0.0082948841, -0.0905193835, -0.0752196163, -0.0355460495, 0.0181210227, -2.4880354404, -0.1096862257, -0.2127822489, -0.1400175095, -0.2469649464, 0.0016652652, 0.0025485386, 0.0473063849, -0.0473150015, -0.6343274117, 0.3175292313, -0.2260941416, -0.1748442054, -0.1731736511, -0.7910007834, -1.0194957256, -0.0202480555, 0.1091749370, -0.1946681291, 0.0333082229, -0.1745289415, 0.1441190839, 0.0854214728, -0.1911805868, -0.0029063958, -0.0187022146, -0.0381815210, -0.0942663178, 0.0323003381, 0.7105023265, -0.0970492586, -0.6895786524, -0.2022477537, 0.0821571201, -0.4356476367, -0.0401281789, -0.1944714785, 0.0761391670, -0.1464959830, -0.2677912116, 0.1657069623, 0.1796373725, -0.0075067235, 0.1322647035, -0.2023096979, 0.0663584918, -0.2329605371, -0.0848840922, 0.0916671157, -0.0093125505, 0.0531764962, 0.0382955894, -0.0356299058, -0.1188649088, -0.1741633862, -0.0377142765, -0.0596301220, 0.0076237428, -0.4712569714, 0.0255938452, -0.1558325887, -0.0306491498, 0.0082494710, -0.5228619576, -0.0055164909, 0.0527036004, -0.4929799139, -0.5770257711, 0.0085794507, -0.0459126681, -0.0215609521, 0.0433987975, -0.5216554403, 0.4338296354, -0.0534863807, 0.1261541843, 0.0432837568, 0.1205620766, -0.4130434692, -0.0806424990, 0.3534629643, -0.0754160360, 0.1377196163, 0.4962563515, -0.1058052555, -0.1487264037, 0.0223362185, -0.1693686694, -1.7094314098, -1.2176406384, -0.1058149487, 0.0008681277, 0.2218713164, -0.0624122880, -0.0219356678, 0.0112585714, -0.6292777658, -0.2723478973, -0.1130864397, 0.1270402670, -0.0336710252, -0.1423305571, -0.1592956930, -0.3486307859, -0.0878337845, -0.0786530450, 0.0076695643, -0.1737082154, -0.0412608907, 0.2959766090, 0.0818331316, -1.3801292181, -0.0867412463, -0.0451807752, 0.0336222835, -0.1848289073, -0.3242236674, -0.0198107939, -0.0674812272, -0.0970012471, -0.2208999991, 0.0171130057, 0.0703133270, -0.1199549660, 0.0130849881, -0.2884546518, 0.3676748276, 0.0004694538, 0.0313115120, -0.0307481457, -0.0038825013, -0.2279689610, -1.1858928204, 0.3895879686, 0.1416862756, 0.0099140219, 0.0544707626, -0.7037110925, -0.6606246829, 0.0014258784, 0.2454564422, -0.0178197231, -0.1224314272, -0.1202166378, -0.2754056156, -0.0548298918, 0.7467139959, -0.0934016779, -0.0975529701, -0.1283386946, -0.1539286524, -0.1850326359, 0.2949343622, -0.0194840785, -2.0049300194, 0.0313758515, 0.1297689974, 0.0786404684, 0.0361782610, -0.2303066850, 0.1336629540, -0.4032993019, 0.0490598418, -0.1761161685, -1.1473298073, -0.0855374783, -0.0347594991, 0.4225924313, 0.1182265580, 0.0569384992, -0.1708137244, -0.5920758247, 0.0063961074, -0.4906657636, 0.0394827873, -1.2046486139, -0.3206406534, 0.0182984918, -0.0650349259, 0.5882781744, 0.6599203944, -0.0025193160, -0.0855998620, 0.0208738651, -0.0553743280, -0.1779229939, 0.5890240669, -0.0082245022, 0.0102642626, -0.1931394637, -0.2971943021, 0.3668759167, 0.0447676592, -0.2351529151, 0.0643515736, 0.0566112809, -0.2128618658, 0.3339489400, -0.0919800475, 0.2031905651, -0.7566480041, 0.0826163441, -0.0574161224, -0.0254540015, 0.7650388479, -0.1768051088, -0.1953754723, -0.2072867602, 0.0152341183, -0.5397542715, -0.1468945295, -0.4000391066, -0.3182069361, -0.3259067237, 0.0303724799, 0.0777297914, -0.1296567768, 0.2152149826, 0.0105939331, 0.1303965449, -0.0607520677, 0.0379542485, -0.0754842833, -0.0039122999, 0.0426981896, -0.0038635372, -0.0854209363, -0.0558632873, 0.0153724896, 0.0279362556, 0.0406365953, -0.0584227331, 0.0324729756, -0.0955858678, -0.2430957109, 0.2486675084, -0.0801738203, -0.2604684532, -0.1531666815, 0.0244264565, -0.0265682563, 0.0796246529, -0.1292012632, -0.3373497725, 0.0064049247, 0.0012507392, 0.0364899226, -0.0895801485, -0.0336755365, 0.0872905850, -0.0926859900, -0.1947368234, -0.1545799971, 0.0666666478, -0.0536605939, -0.0471398234, -0.1489246786, 0.0375548750, 0.0286396407, 0.1313031912, -0.0883343369, 0.0141844572, -0.1077221408, 0.0246152673, -0.1553743482, -0.0581457280, 0.0894549191, -0.0539664142, 0.0404826440, 0.0177539326, 0.0888068080, 0.0069428477, 0.1357108206, -0.0316323042, 0.1683369130, -0.1496482193, 0.0389418229, 0.0095019005, 0.0324981399, -0.0450180769, 0.0783037171, -0.0949815810, 0.0774144307, 0.0240253992, -0.0127936816, -0.2221954912, 0.0967412889, -0.0678154528, -0.2570793927, 0.0037103649, -0.2165196985, -0.0317271352, 0.0207932927, 0.0348444022, 0.0766181797, 0.0516641885, 0.0554608516, -0.4226931930, 0.1795699000, -0.0889454931, 0.0310247280, -0.1309386343, -0.2923052013, 0.0271298643, -0.0363466367, 0.0259142555, -0.2816570103, 0.0014249980, 0.1014946252, 0.0461780913, -0.0885057077, 0.0655648783, 0.0909507871, 0.0766536742, 0.0772598982, -0.0106327012, 0.1013447717, -0.0249823872, -0.0833292678, -0.0265176054, 0.0766665414, -0.0247083697, 0.0600694753, -0.1368333548, -0.0950650573, 0.0092960587, -0.2638540268, 0.0035698179, -0.2269176394, -0.0252365712, -0.1202238947, -0.1014174819, 0.0567688942, -0.1485314071, -0.1694761813, -0.0741620362, 0.0044056517, 0.1224559695, 0.0179893840, -0.0563805439, -0.1128568351, -0.0161630381, -0.0548099093, 0.0236638915, 0.1202837527, 0.0782910809, -0.4245615304, 0.1409334093, -0.1360096931, 0.0134719433, -0.0884324536, 0.1256507337, -0.2527714968, -0.1340489686, -0.0588078834, -0.0262171365, -0.0727100596, 0.0679730028, 0.1022571251, 0.0745163336, -0.1065586805, 0.0204521138, -0.0049430723, -0.0354380906, 0.0979276374, 0.0353013612, -0.2461750209, -0.0305862650, -0.1498658210, -0.0207987875, -0.1249355599, -0.0170162357, -0.1047687531, 0.1121426895, 0.0922572613, -0.1125862747, -0.1110608354, -0.0009341897, -0.0088465177, -0.0727656931, -0.0392482728, -0.0374832302, 0.0783947557, -0.0906421244, 0.1077855229, -0.1346421093, 0.0518016517, -0.0649284869, 0.0707431659, -0.0378918387, -0.0937204659, 0.2433040738, -0.0984438583, 0.0609997213, -0.0094181336, 0.0679252818, -0.0389387868, 0.0778224692, -0.1396801025, -0.1317165792, -0.1137907133, 0.1296720952, 0.1043119803, 0.0132948766, -0.0282784514, 0.0616297424, 0.0741924047, 0.0463272259, -0.1826602519, -0.0200500581, -0.0672883987, -0.0691618770, 0.1688387990, -0.0111677945, 0.0641154200, 0.0365488268, -0.0159943271, -0.1632579714, -0.0612745881, -0.0229765587, -0.0167149398, 0.0993383825, 0.0974890739, 0.0172673110, 0.1062615290, 0.0225539319, -0.1287136674, -0.0592854135, 0.0928629637, -0.0444442183, 0.1719847172, 0.1947116107, -0.0235755090, -0.0507846363, -0.0947103277, -0.0292710997, -0.1574653238, -0.0287774578, 0.0517815091, 0.0347646698, 0.0551120192, 0.1061809734, -0.0867927745, -0.0826232731, -0.0463975817, -0.0849917978, 0.0951309726, 0.0875758380, 0.2834513783, -0.0577255674, 0.0551812574, -0.1619235575, -0.2339017987, -0.1290652901, -0.0862941965, 0.1259324402, -0.4309149384, 0.0569795668, -0.0444764495, -0.0498686247, 0.1566009223, 0.0572863966, -0.1198958531, -0.1024980396, 0.0741928369, 0.0654176399, 0.1041576862, 0.0340102687, 0.1455771178, -0.1188860610, 0.0204268564, -0.0633496419, -0.1270527989, -0.0255417731, -0.0493085161, -0.0780273378, -0.0593406148, 0.1577131003, 0.0121255368, 0.0714523271, 0.0021211547, -0.0222959500, -0.0350460112, -0.0237572864, 0.1084503829, -0.0250582099, -0.1325580329, -0.0993949398, 0.0890001431, 0.0466322564, -0.0576159135, 0.0313144550, -0.1026358977, 0.0043343846, 0.0390363932, -0.0078088236, -0.0832632110, -0.0844783336, -0.0980610251, 0.0898329616, 0.0765820518, -0.0989550799, -0.0569725409, -0.0403036624, -0.0571450293, -0.0955247208, -0.0484573916, -0.0668677464, 0.0086909086, -0.0464812890, -0.0321998782, 0.0663523749, -0.0035305559, -0.0268101115, -0.0892275572, -0.0950236395, 0.0024272853, 0.0223363992, -0.0787607953, -0.0070734010, -0.0163179915, 0.0621039085, -0.0453910008, -0.0503165536, 0.0576314107, 0.0221573841, 0.0785564482, 0.0330412351, -0.0004423530, 0.0469558053, -0.0308408290, 0.0909923762, 0.0603083745, 0.0718038380, -0.0202872232, 0.0649140030, -0.0368484072, -0.0757292658, -0.0452152751, 0.0765089840, 0.0255530272, -0.0728300661, 0.0095438175, -0.0506078154, -0.1660207063, -0.0333761983, 0.0748195052, -0.1470435709, 0.0808660164, -0.0470856130, -0.0242194887, -0.0572699867, 0.0770843551, -0.0877377018, 0.0199513193, -0.1032638773, 0.0278745778, -0.0854558572, -0.0129627055, 0.0172692668, -0.0744482428, 0.0640516430, 0.0580471307, -0.0529600307, -0.0303258169, -0.1256515831, -0.0460155010, 0.0338467881, -0.1477649063, -0.1023798212, -0.0338889472, -0.1778266877, 0.1033113524, 0.0888632014, 0.0194492135, 0.0044467864, 0.1021342576, 0.0501110703, -0.0092695402, -0.0035763136, 0.0080929799, -0.0806585401, -0.0719363317, -0.0878675804, -0.1038389429, 0.0569602102, -0.0396134034, -0.0480035506, -0.1319608837, 0.0813743919, -0.0347502567, 0.0467187725, 0.1267397553, 0.2239731699, 0.0935152471, -0.1347030997, 0.0684816018, 0.0520994700, -0.0834883600, -0.0076833586, -0.0360135287, -0.0443135165, 0.0741593465, -0.0785038844, -0.0300543252, -0.0207757633, -0.0594680756, -0.0202945340, 0.1028948650, 0.1310064495, -0.0692293569, -0.1316218674, -0.0063923206, 0.1100433543, 0.0417846777, 0.0718768984, -0.0630107671, -0.0272972193, 0.0190695636, -0.0064686872, -0.1201484129, -0.0526576340, 0.1367141306, 0.1137766689, 0.0771516412, -0.0598081537, -0.0867085308, -0.0620998181, 0.0455515124, 0.0177436192, 0.0354464129, 0.0094420845, -0.1286392957, 0.0750585496, 0.0003340628, 0.0364682935, 0.1606706530, -0.1227883995, -0.0137339588, 0.1034063548, -0.0084387213, -0.0774746016, 0.1173895076, -0.1543877274, 0.0466375127, 0.0291139502, -0.0397652127, 0.0219303444, -0.0490354747, -0.0406570137, 0.0269197542, -0.0294879209, -0.0332144760, 0.0316277109, -0.0385855809, -0.0060200971, -0.0647467673, 0.1002659649, -0.0818184093, 0.0086420421, -0.1435384303, -0.0109901801, -0.0089045987, -0.0166693553, 0.0239900071, -0.0604968630, -0.0629892796, -0.0067808987, -0.0723910332, 0.0405062996, -0.0491322987, -0.1089748591, 0.0336201154, 0.0837385878, 0.0642547458, -0.0670108125, 0.0027733413, 0.1083229333, -0.0905332416, -0.0029911117, 0.0288833454, 0.0995280817, 0.1106119528, -0.0802843943, -0.0235742219, 0.0758621693, 0.1185603812, -0.1370139271, 0.0823690966, 0.0294282492, -0.0232376978, -0.0368416794, -0.0019882906, -0.0739275962, 0.0245444551, 0.1030118614, -0.0876227319, 0.0166107044, -0.1321622878, 0.0530950315, 0.0388606600, -0.0936142802, -0.1037533283, 0.0686231852, -0.0194629747, -0.0136673180, 0.0053666267, 0.0164886303, 0.1237943023, 0.1360168904, -0.1336846650, -0.0596083775, -0.0042885267, -0.0335579254, 0.0772602111, -0.0701121166, 0.0230627693, -0.0841213465, 0.2181085944, -0.0059881564, -0.0596960112, 0.0799768493, 0.1229562238, -0.0224256031, 0.0177305248, 0.0813535377, 0.1024963334, -0.1207008362, -0.4502153695, -0.0693857819, 0.0724572912, -0.4171881378, 0.1598119289, 0.0299449675, -0.0181315169, -0.1868143678, -0.1180284247, 0.0148433885, -0.3566848934, -0.1215502024, -0.0623689666, -1.2575136423, -0.2928734124, -0.0611116886, 0.0217826907, 0.0520058349, -0.0059572104, -0.7596921921, -0.0377610698, 0.0146862939, -0.0448602140, 0.3633911610, -0.0366318449, 0.0248087049, -0.0063611129, -0.5847523212, -0.2023558766, -0.6049807668, -0.1188055724, -0.4281980991, -0.0647025481, -0.2082661837, -0.8193477392, 0.3324664831, -0.0378328338, 0.0025953783, 0.0051920726, -0.0254087206, 0.1923621148, -0.1602963060, -0.3249813914, -2.6893253326, -1.0711040497, 0.0815769061, 0.0296131689, -0.1465994120, -0.0800923705, -0.1458925605, -0.4221507311, -0.0978296101, 0.1364029348, 0.0133208502, -0.2069514096, -0.9606832862, -0.0863959268, -1.2926558256, -0.0519868433, 0.0900719091, -0.3003691137, 0.0983460322, -0.0032353520, 0.0105376393, -0.0723197460, 0.1507324427, -0.0605787188, -0.0377090350, -0.0281673316, 0.3347433805, 0.0123201674, -0.2410682291, -0.0300077405, -1.1718218327, -0.5389764905, 0.0726434141, -0.0906944424, -0.2064772695, -0.0879047439, -1.1127287149, -0.3026639521, -1.7140567303, -0.1023048386, 0.0049342103, 0.0606764965, -0.1889397204, 0.8892306685, -0.0005106075, -0.2732622921, -0.1560809463, -0.1304314584, -0.0700661242, -0.0244769603, -0.1055512503, -0.1352178752, -0.0150009692, -0.0739606768, -0.0106315529, -0.3760871291, -0.1581990570, -0.1202855185, 0.5411800146, 0.0180997811, -0.0845292881, 0.0068334611, -0.0957153738, -0.4424063563, 0.4733501971, -0.0128498990, 0.1785960495, -1.4551800489, 0.0539571978, 0.0135175344, 0.3390729129, -0.3435764611, 0.0222767666, 0.0298922956, 0.0258496143, -0.0831288248, -0.0402737744, -3.0034582615, 0.4821522534, -0.0508583039, -0.8507149220, -0.0886902437, -0.0326073095, -0.0577823669, -0.1021499783, -1.5229872465, 0.1236419901, 0.1758816540, -0.0035978181, 0.5405150056, -0.1342808008, -0.0433768481, -0.0654692128, -0.3297191262, -0.3450575471, -0.0786146671, -0.6126938462, -0.1024968103, 0.9962921739, 0.0984071419, -0.4069037139, -0.1056517810, -0.1143502966, -0.0651794076, -0.1226622686, 0.0733073577, -0.0643573850, 0.0323390402, -2.1540088654, -0.1442949772, -0.1309826821, -0.6543782949, 0.0697162375, -1.3741617203, -0.0255788565, 0.0089854794, -0.0146740619, 0.0096909944, -0.1270000190, 0.0661928803, 0.0136336572, -0.1486649960, -0.1604193747, -1.9687023163, -0.0627911240, -0.0921394750, 0.3658627868, 0.1478364766, 0.5796007514, 0.0728614107, -0.6605432630, -0.0212298352, -0.0063319020, -0.0598375238, -3.0014395714, 0.0549355894, 0.0195299834, -0.7604295611, -0.2238721997, 0.0799740329, -0.0456943698, -0.1390013099, 0.0110343155, 0.0897384658, -0.1291777790, -0.1694644243, -0.0297208671, -0.0877022594, -0.2128252685, -0.3694375455, 0.4275494516, -0.6957617402, -0.0481050164, -0.5173375607, 0.0809072107, 0.0612601340, -0.0449770093, 0.2856912315, 0.3125731647, -0.5070833564, -0.1432519555, 0.3211068511, -0.0632242635, -0.0339633971, -0.0067050247, -0.0567761287, -0.0000723850, 0.0979034156, 0.0234270860, 0.0362869203, -0.4632690549, 0.0717487931, 0.0546193607, -0.3791563809, -0.0197643582, 0.0858069137, -0.7822187543, -1.9821512699, -0.0551569201, -0.0103721395, 0.0561257415, -0.0938520730, 0.1413793117, -0.1388350427, -0.0469715819, -0.0608323999, 0.0242915098, -0.2576937973, 0.5978043079, -0.4822796285, -0.1288336962, 0.0990044698, -0.0907860994, 0.2714512050, 0.0224351734, -0.5155041218, 0.0874192491, -0.0595240556, 0.0118572013, 0.0367501415, -0.0609026998, -1.7457278967, 0.1076726019, -0.4811023176, -0.0243107453, -0.0923218280, 0.1576661021, -0.0147122974, -0.0456255339, 0.2590259314, 0.3909189999, 0.1746336222, -0.2025960237, -0.2669537365, 0.0343480036, -0.1350422502, -0.0764341876, -0.0021536546, -0.0111490227, -0.0828537196, 0.0645099208, -0.1499038637, -0.0103317806, 0.1145598590, -0.0481909774, -0.0081822881, -0.4137105346, -0.6653017998, 0.0033133291, -0.1347150952, -0.2030334324, 0.0296850223, 0.6366187334, -0.8890991807, -0.3824732304, -0.0081196139, -1.0005846024, -0.2268565744, -0.0650524050, -0.0408961400, -0.3474264741, 0.2544100881, -0.2639938295, 0.0329435505, -0.3093114495, 0.0022655220, -0.2411632836, 0.1626589745, 0.3816192150, -0.1245261803, -0.0703625381, -0.0831380486, -0.0365771018, -0.0338204466, -0.1455027759, 0.1156309098, -0.7658668160, -0.1679243743, 0.0257948749, -0.0143008921, 0.0153759429, -0.1085789502, -0.2722925246, -0.4888715148, -0.1351082623, -0.4299617708, 0.0150679247, 0.0642786399, 0.1396459788, -0.5569908023, 0.1494512707, 0.1657898873, -0.0994339958, 0.1588054895, 0.0143832359, 0.0024028956, -0.0992377028, -0.0122386375, -0.4651317596, -0.1173857599, -0.0854119211, -0.0275598913, -0.0637863129, 0.0026134485, 0.4944111705, -0.1832291782, -0.0939218253, -0.4326689243, 0.0005700833, -0.2144523561, -0.0087664695, -0.0361265019, 0.4014997482, 0.4294864535, -0.1172550991, -0.0946692824, -0.1001152024, -0.0592043959, 0.0434462763, 0.2474583089, -0.1124341339, -0.1827927530, 0.0002398655, -0.3051851392, 0.0641501918, -0.1008783355, -0.0078280671, 0.1134405658, -0.5692598224, -0.0410573632, -0.0079555903, -0.2514001131, 0.0210240837, -0.0464895815, 0.0052001793, 0.0278621521, -0.1186343953, -0.0011785527, -0.0190294553, 0.0286859181, 0.2238866687, -0.0765178874, 0.0574956760, -0.4680938125, 0.0218030438, -0.3131015599, -0.3462740779, 0.2883362472, -0.0312062018, -0.0960069671, 0.8038824201, -1.1849900484, 0.0255706515, 0.0282932352, 0.1956546456, -0.0255025011, 0.4384410977, -0.0224417187, -0.1313309371, -0.0567596667, -0.1643368155, 0.2607283890, 0.2162560970, 0.7022622824, -0.1190242171, 0.2889216542, -0.6515143514, 0.0042392327, -0.0136931529, -0.7417187691, -0.0237256810, -0.0691042617, 0.0331311151, -0.1272420436, 0.1157551035, -0.7453308702, -0.2412510663, -0.1371283233, -0.0141077535, 0.0101539688, 0.0143209724, -0.1450858861, -1.1158120632, -0.4583933949, -0.2354352474, -0.6223690510, -0.0107341288, 0.3897697926, -0.0556990989, -0.7258470654, 0.0078691831, -0.0394763276, -0.0857245103, -0.0951537713, 0.3432010412, -0.0002572964, 0.0411841124, 0.0069554923, -0.9319810271, -0.2955203652, -0.1203416735, -0.2275164127, -0.4908387065, 0.0135488687, -0.4650033414, -0.4056971967, -1.3700485229, -0.0548215024, 0.0743584409, -0.0509931669, -0.3363212943, 0.0733521730, -0.0120560369, 0.2035047412, -0.0339669809, 0.0355686657, 0.0515177920, -0.0277744494, -0.0147906784, 0.4005475938, -0.1569292545, -0.0459175557, -0.0890630409, -0.1458386630, 0.1077463999, -0.9798225164, 0.0233952645, 0.3485661447, -0.0258317180, 0.0595169589, -0.0138233732, -0.0861464143, 0.3304825723, 0.0550088137, -0.1446404010, -0.2964355350, -0.6230853796, -0.5937345624, -0.0572560132, -0.0373518616, -0.0286084004, 0.2267885953, -0.1260712445, -0.1871118098, 0.0597853325, -0.0301732440, -0.6298506260, 0.0262697041, -0.2197267264, -0.1199817508, -0.0083447807, -0.2101326287, -0.0149056381, -0.1782227457, 0.0248373635, -0.0371986516, -0.5607025027, 0.0409480147, 0.5331155658, 0.6171085835, 0.0474363081, -0.0847666040, 0.0186263733, -0.1161634400, -0.0853610113, 0.1835975200, -0.2624993324, -0.2620937228, -0.0343656056, 0.2243806422, 0.1316157281, -0.2199435979, 0.1152334809, -0.4803183675, -0.1357316673, -0.0542871431, -0.0775263906, -0.0356867611, -0.1308721155, 0.3394389749, -0.7389560938, 0.0224564523, 0.0319085233, -0.0960736349, -0.1270258576, 0.2796821892, -0.3383348286, -0.0549466908, -0.0867913142, -0.0480810031, -0.0788175687, -0.0178987905, 0.0728196576, -0.0333108790, -0.1428031921, -0.1052749231, 0.1148260012, -0.0734036192, -0.0712383986, 0.1470276564, -0.0390804298, -0.0619999841, -0.0934744105, -0.1544798613, 0.1139129773, 0.0208903067, 0.0556280948, -0.1968872100, 0.1007157043, 0.0526627600, 0.0965767652, 0.0701533854, 0.0362698883, -0.1332643926, -0.0918305889, 0.0258471407, -0.0529939346, -0.0306500010, 0.0445969999, -0.1032078266, 0.0946403593, -0.0746737644, -0.0332713239, 0.0635425672, 0.0787824541, 0.0044590896, -0.0473845750, -0.0469604954, -0.0258439444, 0.0675588921, -0.0654286519, 0.0124909850, -0.0995090529, 0.1508839726, -0.0113362055, -0.0648542643, 0.0061783278, 0.1035767868, -0.0453729071, 0.0709188730, 0.0693581402, -0.1646060646, 0.0088801049, -0.0220283922, -0.0209206585, -0.1718026698, -0.2126866430, 0.1114201546, -0.1143657565, 0.0714141726, 0.0847438946, 0.0136171179, -0.0158801526, 0.0562193394, -0.2763123214, 0.0933285058, 0.0365818590, 0.0180587210, 0.0188298449, -0.0634555817, 0.0252230782, -0.2226068228, -0.2184437960, 0.1388917416, 0.0342607163, -0.0635339245, 0.0059457398, -0.1476269811, -0.0406472012, -0.0220179055, 0.0156901553, 0.1532204002, 0.1469081193, -0.0824929327, 0.0991545469, -0.0129068615, 0.0354121216, 0.0750247240, -0.0293853730, -0.0668548420, 0.0760066211, -0.0348323397, 0.0110448990, 0.0365803167, -0.1083664969, 0.0036930046, 0.0426467955, 0.1316766143, -0.1339890212, -0.0064309519, -0.0123123843, 0.0574578233, -0.0494991839, 0.0982572809, -0.1007325575, -0.0459785908, 0.0090033123, -0.0086059840, -0.0626343563, -0.3446872532, -0.0633534715, -0.1950152069, -0.0037521615, 0.0171003938, 0.0423699096, 0.0607057996, 0.0511837155, 0.1987093985, -0.1258577853, 0.1443172991, -0.1738136411, 0.0122896461, -0.0241433699, -0.0295136552, -0.0006944273, -0.0862199366, -0.1031424254, 0.0830318779, 0.0042362390, 0.1036150977, -0.0050381459, 0.0379662961, 0.0042981687, -0.0994471386, -0.1068724468, 0.1264488250, -0.0044548749, 0.0903799534, -0.0885725990, 0.1209139228, -0.1223594546, 0.0607598387, -0.1146240681, 0.0630804747, -0.1605592072, -0.0791757777, 0.0107411910, -0.0461240262, 0.1001558676, -0.0853561908, 0.0425586589, 0.0927523747, -0.1050878093, 0.1545459628, 0.0254083928, -0.1272691339, 0.0433571823, -0.0386517681, 0.1102853343, 0.0516454652, 0.0711389184, 0.0468268692, -0.0759812444, -0.0458921343, -0.7736882567, -0.0342998169, 0.0681471527, -0.1698959321, 0.1850484610, 0.0704337284, 0.1619682163, -0.0984427407, -0.1082663685, -0.0727776363, -0.1060662866, -0.1114998981, 0.0367623828, 0.0655554682, -0.0789965689, 0.1260522455, 0.0105924495, -0.0010522169, 0.0421645977, -0.1843864173, 0.0563498214, 0.1031817272, 0.1077191234, -0.0128116542, -0.0375260264, -0.0683136880, 0.0823430195, 0.2909887433, -0.0787813067, -0.0087621044, -0.1279324591, -0.1638517380, 0.0832482427, -0.0425304435, -0.0586997606, 0.0183699224, -0.3195970058, -0.0244628023, -0.0759636909, -0.1777681857, -0.0712165087, 0.0661601648, -0.0909519643, -0.0252905563, -0.0078604976, -0.0051451242, -0.0724490732, -0.0681033283, -0.0265270080, -0.0981537104, -0.0156359058, 0.1213120893, -0.1671115458, -0.0626398772, -0.0552153513, -0.0624722131, -0.0344532505, 0.0585586801, -0.0185414087, -0.0641463995, 0.0357977264, -0.1486410499, -0.1367126554, -0.0590196475, -0.0425624773, -0.2202040404, 0.2149987519, 0.0885348916, -0.0507155135, -0.1276634336, -0.0430104695, 0.0750747025, 0.0023995626, 0.0187172592, 0.0261506997, 0.0712087303, -0.0716587976, -0.0914966464, -0.0060905116, -0.0312316734, -0.1617369652, -0.1717813164, -0.0596955493, 0.0031927195, 0.0032840823, 0.0714389086, -0.0578786954, -0.0660957024, -0.1001236141, -0.0725352913, 0.0150663843, 0.0583092235, -0.0504350290, 0.0716241151, -0.1071964800, -0.0068007382, 0.0727218688, -0.0868301764, 0.0577556938, 0.0155683486, -0.0431663655, 0.0854468271, 0.1209470928, 0.0530032590, 0.1331785172, 0.0413089097, 0.2014353871, 0.0082303667, 0.0631116033, -0.1490852386, -0.1149374098, -0.0661158264, 0.0425099134, -0.1610854268, 0.0539748035, 0.1300728172, 0.1226931512, 0.0050663054, -0.0335526094, 0.0570570156, -0.0525453985, 0.0029441991, 0.0585379265, -0.1304815561, -0.0230529252, -0.0321858786, -0.0873653218, 0.1283042729, 0.1140698269, 0.0905737728, 0.0616056621, -0.0358512700, -0.0020701110, -0.0998748094, -0.0237508100, -0.0318404436, 0.1284804940, 0.1133473217, 0.0257250741, -0.1157684252, 0.1694858819, -0.0530040972, -0.0548533387, -0.0232318938, -0.2423382849, -0.0892851502, 0.0233643744, -0.1611873806, 0.0351398215, 0.0550155155, 0.1013945937, -0.0252111610, 0.0500065237, 0.0437676609, 0.0216696858, -0.0487196967, -0.1330364197, -0.0935901254, -0.1630207747, 0.0486232117, -0.0290480480, 0.0981778502, 0.1185517013, 0.0473060906, -0.0368516557, 0.0797108710, -0.0349752903, 0.0361227319, 0.0719785243, 0.0877632797, -0.0419494025, -0.0718752369, 0.0165473428, 0.1053230837, 0.0177762564, 0.0818610191, -0.0720600486, -0.0173724294, 0.0597647950, 0.0773707628, 0.1111770198, 0.0434427969, -0.0946308672, -0.0682467222, 0.1226417720, -0.0161201581, 0.0347730517, -0.1585192531, -0.0751692131, 0.1091057956, 0.0330109261, -0.0238314401, 0.0915099606, -0.0120819388, -0.0686121583, 0.0591615029, 0.0345854461, 0.0265726727, -0.0770323128, 0.0186188221, 0.0497664325, -0.0934439301, 0.0607165694, 0.1549287289, 0.0354209319, -0.0066549480, 0.0480579697, -0.0887574553, -0.0306852795, 0.0501323603, 0.0657391846, 0.0284596588, -0.0310624782, -0.0735185742, -0.0260851663, -0.0388608873, -0.0642309189, 0.0412524082, -0.0807693452, -0.1363876313, 0.0247336682, -0.0504446626, 0.0110868290, -0.0785801262, -0.0273171738, 0.0160462148, -0.0691188276, 0.0217745043, -0.1551190317, 0.0136485966, 0.0092715919, 0.1446961462, 0.0009128163, 0.0053293314, 0.0648573339, 0.0844994858, -0.0936750919, -0.1021307856, 0.0305570066, -0.0746188834, 0.0730202198, -0.1246433556, 0.1163327470, -0.0372533016, 0.1148704886, -0.0579297654, 0.0803950727, -0.1711853445, 0.0756637007, -0.0814016461, 0.1131920666, -0.0143872378, 0.0406877138, 0.1255445033, 0.0185669996, -0.0935386494, 0.0450412929, -0.1136710569, -0.0147096841, -0.1284324974, 0.0829917118, 0.0998535752, 0.0789994970, -0.1124963090, 0.0262817480, 0.1045746580, -0.0899523422, -0.0993070304, -0.0846322626, -0.0874524042, -0.0417156070, 0.0629701614, 0.0710499138, 0.0923794210, 0.0061854422, 0.0476419032, -0.1242142767, 0.0594217107, 0.0199050456, 0.0200375319, 0.1061921418, -0.0150464177, -0.0801434889, 0.1205530390, -0.0419537872, 0.1520528793, 0.0204140525, -0.1502590775, 0.0370830595, -0.0193900168, -0.0398273990, 0.0303905122, -0.1166152582, -0.1364135742, 0.0819574520, -0.0957692415, -0.0378814936, 0.0804798454, 0.0070295334, -0.0988943577, -0.1476427615, 0.0158599354, -0.1513076723, 0.0297877789, -0.0496538654, 0.0505843014, -0.1661383659, -0.0056771976, -0.0892643332, -0.0348269120, -0.0965989828, 0.1074379906, -0.0652218610, 0.0241543241, 0.0761343688, 0.0176518764, -0.0044108192, -0.1240080148, 0.0416362882, -0.1150210202, -0.0096619530, 0.0905468538, 0.1046669185, -0.0819499716, 0.0162171796, 0.0423447117, 0.0757659301, -0.1522718966, -0.0032308330, 0.1644443274, -0.0997301117, -0.0705414042, -0.0926355422, 0.0377064534, -0.0107348133, 0.0228533298, -0.0108958036, -0.0363482535, 0.0313060433, -0.1116484851, 0.1352712810, 0.1100777760, 0.0266953111, 0.0417380966, 0.0282334741, -0.0668763146, -0.1295820326, -0.0515610501, -0.1116611660, -0.1171084866, 0.0478530452, 0.1171969771, -0.0190732777, -0.0442988575, 0.0481153317, -0.0517919026, -0.0291640572, -0.0960655808, -0.0299801528, 0.1068697721, -0.0300750937, 0.0544579923, -0.0782775283, 0.0494984351, -0.0419819243, -0.0707190782, 0.0680995360, 0.0100458777, -0.0378683358, 0.0260427166, 0.0105654504, -0.0945194438, 0.0525297821, -0.0388593748, -0.1004492640, 0.0257284660, 0.0284989811, 0.1216951311, -0.0943570882, -0.0104954699, -0.0186983105, -0.0076498664, -0.0340987630, 0.0864025205, 0.0398754999, -0.0697309226, 0.0945378616, 0.0311434492, -0.1265900731, 0.1187478974, 0.0929089785, -0.0555666499, -0.0277621578, -0.0643162057, -0.0894641057, -0.0497393794, -0.1490794420, -0.0839274973, 0.1026318148, -0.0246326327, 0.0848086029, -0.0981429368, -0.0204412546, 0.0799435303, 0.0445846133, 0.0715953261, -0.0253273416, 0.0356721468, -0.0212810412, 0.0184181295, -0.1237257123, 0.0859865695, -0.0260521192, 0.0904143825, 0.0233966876, 0.0689994246, 0.1215612888, 0.0648012757, -0.0402796865, 0.0339051783, 0.0771567374, 0.0760953575, 0.0990081429, 0.0015920103, 0.1049910188, 0.0536937118, -0.1207383871, 0.0020262608, 0.0400184691, -0.1209938079, 0.1052240357, 0.1109020710, -0.0603327565, -0.0366259739, -0.0495160595, -0.0977640599, 0.1108834743, 0.0972492769, 0.0245169103, -0.0496476106, 0.1087196767, -0.0025906700, -0.1060236096, 0.0132838646, -0.0973444283, -0.0448799878, -0.0187838916, -0.0467630178, -0.0468763113, -0.0709611624, 0.1341373324, -0.1275358796, 0.0687538832, 0.0382034816, -0.0559972711, 0.0313077569, -0.0120818317, 0.0235471185, -0.0164595544, -0.1246449128, -0.1090446413, 0.0201703869, -0.1706396788, 0.0873313248, -0.0251336340, 0.0246508960, 0.0770287812, 0.0790348426, -0.0691906214, -0.0057910993, 0.0859882087, -0.1154197082, -0.0056725899, -0.1250702292, 0.0868980363, -0.0733957291, -0.0215881746, 0.0388765521, 0.0279284474, -0.0379269496, -0.0909324065, -0.1016903967, -0.0930748656, 0.0259410553, 0.0631717145, -0.0561137050, -0.0344744027, -0.0742115155, 0.1032626405, 0.0243643336, -0.0190505106, 0.0546046197, 0.0066470504, -0.0651713461, 0.1125611961, -0.0286448319, 0.0754186958, 0.0517596677, 0.0281848442, -0.1178496778, 0.0527937338, 0.0069209696, -0.0032026118, -0.0402525589, 0.0827968866, 0.1093446016, -0.0685777962, 0.0870655030, -0.0163759720, -0.0192008298, -0.1037747860, 0.0803947151, 0.1300598681, 0.0467311665, -0.0449134596, -0.1588332355, 0.1022527143, -0.0197400954, -0.1225234270, -0.0353427827, 0.0469327793, 0.0040908158, 0.0319491886, 0.0303929746, 0.0918334946, -0.0836029947, -0.0765358061, 0.0089698471, -0.1061386764, -0.1068983078, 0.0135364970, 0.0182747841, 0.0876704529, 0.0421569049, -0.0957760736, -0.0030702353, -0.0328518450, -0.0621154904, -0.0611664653, 0.1738453358, 0.0592221208, -0.0119386846, 0.1494508088, -0.0738349482, 0.0595902018, 0.1102804244, -0.0828957036, -0.1017009318, 0.0436901525, 0.0072107604, 0.1259272397, 0.1110221446, 0.0706095323, -0.0414065570, -0.0866490602, -0.1327138394, 0.0876581222, 0.0445910208, -0.0327528343, -0.1010225117, -0.0392346941, 0.0576527379, -0.1124639660, -0.0796403363, -0.1043019295, 0.0414988622, 0.1025591791, -0.1211716831, -0.1040432900, 0.1046959087, 0.0985053107, -0.0258470178, 0.0132113555, 0.0399512649, 0.1056253016, -0.1147144735, -0.1967905462, 0.0928054154, 0.0096474579, -0.1362125278, 0.1652706563, 0.0586195961, -0.0510381535, -0.0325093530, 0.0022277485, 0.1231877655, 0.0302260797, -0.0895348787, 0.0237671621, -0.0011986569, 0.0561311655, -0.0734560415, -0.0329521000, -0.1440458894, -0.0638114288, -0.0472874455, -0.0594745316, 0.0921011418, -0.0266875029, 0.0935982987, -0.0571562052, 0.0840197355, 0.0392709263, -0.3024815619, -0.3162645996, -0.1253776103, -0.8673780560, -0.0569754913, -0.1550243199, -0.0281853378, -0.0863161758, 0.1941107810, 0.2129907459, 0.0414495990, 0.0772939026, 0.0229188204, -0.8132501841, -0.1477463692, -0.0511708781, 0.0795340687, 0.0431315266, -0.1458928436, -0.8665723205, 0.3505250812, -0.5237560272, 0.0187272411, -0.8245553970, 0.0227402691, 0.0331908092, 0.0262715742, 0.1186093092, 0.2230146974, -0.1393121928, -0.0293601081, -0.3352941573, 0.0753666610, -0.0478621721, 0.9365794063, -0.7030342221, -0.1058686301, 0.0133891422, -0.0467469357, -0.1137248874, -0.6491795778, 0.0624001175, -0.0008698639, 0.1292169392, -0.0240256097, -0.0052429759, 0.0102476049, -0.0838789865, 0.0777135789, -0.2199058533, 0.5805031657, 0.0069564721, -1.1027690172, -0.2771161199, -0.6650155783, -0.0343494080, 0.7078180313, -1.3022345304, -0.0938879773, -0.0193555951, -0.2462212592, 0.1867112666, 0.0196342021, -0.1413098276, 0.0313504785, -0.7583161592, -0.0577994138, 0.1829391271, 0.1259906143, 0.0967989862, 0.0344929621, 0.0312948339, -0.0741162747, -0.3236205578, -0.8953225613, -0.0208927523, -0.0029073358, 0.0607412308, 0.0810823888, -0.2528984845, -0.3441582024, 0.3191761374, 0.0520198382, 0.0374445170, 0.0279986747, -0.3212814927, 0.6118352413, -0.1540500671, -0.5292735696, -0.0245687850, -0.0904503912, 0.0142819760, -0.2258955985, -0.0133420229, -1.0225673914, -0.5091716051, 0.0153818615, -0.0053587169, -0.0949041769, 0.1198606864, -0.2202608436, -0.3619175851, 0.0371365137, 0.3292405605, -0.0221422333, -0.0429389626, -0.1437067389, -0.2504349053, -0.0582093112, 0.3673329651, -0.3833495975, -0.0898551643, 0.0454253294, 1.2660857439, 0.4039354026, -0.1568050385, -0.0344915055, 0.2868621945, -0.1087122113, -0.1283563375, -0.4791608453, -0.1485562027, -0.0331501067, 0.5657497048, 0.1797680259, -0.0218388420, 0.1114381701, 0.0056336527, 0.1840484887, -0.1247322485, -0.1517691016, 0.0867956728, 0.1064741239, -0.0133616375, -0.0782119110, -0.1087025255, 0.3758423030, 0.2962686419, 0.0662672892, -1.1751033068, 0.0685186461, 0.1470829993, -0.3178619444, -0.1018539146, -0.1561430395, -0.0805556774, 0.0230631679, -0.0344673507, -0.1299504936, 0.6408746839, -0.5768310428, -0.4562792778, -0.2675814331, 0.0845358297, -0.1362370402, 0.0595919192, -0.1581626385, -0.0169165377, -0.0109685361, -0.1034894735, -0.0274574813, 0.0155465333, 0.1201933995, -0.0771516040, 0.0622298531, -1.0779887438, -0.5573999882, 0.0856887326, -0.0541466288, 0.0853431076, -0.1116116121, 0.1645682007, -0.7345264554, -1.4721270800, -0.0004496773, 0.0953395665, 0.0479508080, -0.9346109033, -1.1193698645, -0.1856299043, 0.9378684163, 0.0311167277, 0.0228452533, 0.0573767908, -0.0250381622, 0.0837733969, 0.1888706535, 0.1448234916, -0.1396591961, 0.0245681405, 0.0558250211, -0.4629268050, 0.4556634426, -0.7570859790, -0.2031401545, -0.1126578972, 1.2359874249, -0.0478700101, -0.0173843727, -0.1934100538, -0.0421760418, -0.9135009646, -0.4042556882, -0.2460819632, 0.1631837040, 0.0657283291, -0.0156179871, 0.1855928004, 0.8664086461, 0.0180923603, 0.0078204433, 1.4166983366, 0.0615546219, -0.1651975662, 0.1122698486, 0.0355216339, 0.0019879076, -0.1740739495, 0.0414629765, -0.2948333919, 0.6163622141, -0.0610245615, -0.0044014496, 0.4558746815, 0.0523081422, -0.1286999583, -0.4953622818, -0.1202539802, 0.0474702120, -0.0948524028, -0.1225311235, -0.4533711672, -0.2498885542, 0.0112832924, -0.6720186472, 0.1429947913, 0.0716829076, -0.0172059815, 0.2514202595, -0.0610645898, -0.2790161073, -0.1030966714, -0.0893310532, 0.0133895231, -0.2987227738, -0.0079371417, -0.4900825620, -0.0292006806, -0.0419437289, -0.7915362120, 0.0591378585, -0.4234053195, -0.6634076238, -0.4119471014, 0.0130033987, -0.3862092197, -0.0935934260, -0.2459222525, -0.1067554802, 0.5177004933, 0.2304641008, 0.4406960607, -0.0041279839, -0.0007464798, -0.0812151805, 0.0952545255, -0.0162927639, -0.0053894818, 0.0128382854, -0.8825491071, 0.2409117073, 0.0168734360, -0.0213887002, 0.0320052691, -0.0932033807, -0.2917527556, 0.3719115555, -0.0709248185, -0.0046713995, 0.0742299184, -0.2258693427, -0.0457445718, 0.0039151944, 0.2471861541, -0.9693413973, 0.3834085763, -0.0035597922, -1.2114559412, -0.1454561353, -0.1946906149, 0.1422286630, -0.1812916845, -0.0189466048, -0.0064461953, 0.0510298796, -0.1783695221, 0.2207764834, -0.2074772120, 0.1304722726, -0.0968892276, -0.1606276780, 0.0360569507, -0.0017795543, -0.0265806057, -0.0744802207, -0.8436746597, -0.9440820217, 0.0608809777, -0.4267148077, -0.2947219312, -0.2346125096, -0.4502398074, 0.1695405543, -0.0721336827, -0.1288998872, -0.0689841583, 0.0962340385, 0.2054854482, -0.0282895230, -0.0668247268, -0.0092549184, -0.1948367059, -0.0915904418, -0.0323280804, 0.0804489926, -0.7879795432, -0.0127139715, -0.6352769732, -0.0065538143, -0.3626912832, 0.5639101267, -0.0445459858, 0.0926895365, -0.0471802689, -0.0172247086, -0.6470538378, 0.5607950091, 0.4642998576, 0.0507512875, -0.2776158452, -0.0264051501, -0.0797059536, -0.1143917441, -0.0725671053, 0.4222422242, -0.1202092618, -0.3757435083, -0.0612296462, 0.0123992078, -0.0817783251, -0.9696470499, -0.1040385962, 0.1915646642, -0.0022045532, 0.2806044817, -0.4009867311, -0.0421641208, 0.2114424407, -0.1105149314, 0.3374212384, -0.0199357197, -0.0836114809, 0.1486954242, -0.7845183015, 0.0161324106, 0.4372825325, 0.0845174864, 0.0238884017, 0.0088115809, 0.0243820753, -0.1191794127, -0.0620346218, -0.1411109120, -0.1183433756, -1.8639354706, -0.1139855385, 0.8007096052, -0.6436020732, -0.0838198513, 0.5071922541, -0.4548080564, 0.0491481274, 0.0587569959, 0.0636717901, 0.3911649585, -0.5340525508, 0.0987131149, 0.0863844305, -2.1160805225, -1.5203264952, -0.0609763265, -0.0512938723, -1.6853996515, -0.3456694186, -0.0549675524, -0.6092825532, 0.2404939234, -0.8361111879, -0.0809566155, -0.1303866804, -0.1086062938, -0.0654082373, -0.2198973149, 0.0752789080, -0.0058925576, -0.7666882873, -1.4981744289, 0.4441189468, -0.5040715337, -0.1666669101, 0.0157756303, -0.0203184467, -1.0793319941, 0.0115082255, 0.0577158779, -0.0113384789, -0.4688935280, -0.0301277656, -0.0213152319, 0.0202220194, -0.1357031763, 0.0204165578, 0.5363025665, -0.0645542666, 0.0095845908, -0.4307442605, -0.0224848352, -1.0764911175, -0.6732899547, 0.3258392513, -0.0796974823, 0.0154853212, 0.0676053837, 0.6077367067, 0.2946458161, 0.0107497256, -0.1633290648, -0.0153335370, 0.0482930578, -0.0546469390, -0.0528842956, -0.0448024198, 0.0355252922, -0.1074552462, -0.0799037889, -0.0509269275, -0.0636920854, 0.3415736258, -1.9879685640, 0.2974421680, -0.1412540525, 0.1525828689, 0.0459356643, -0.0871102735, -0.0810888782, 0.0261717364, -1.0558182001, -1.1316474676, -0.7826511264, -0.8674901128, 0.5365203023, -0.0898125246, -0.0896395221, 0.0735650435, -0.0437770821, -0.2014044672, -0.0520178601, -1.0083520412, -0.1487582326, -0.1265259981, -0.0439298525, -0.4011814892, -0.2151222080, -0.0155613814, 0.0402502045, -0.1068869904, 0.3454223871, 0.0390783995, -0.1467430592, -0.4104072452, -0.1354501545, -0.2147865593, 0.1308965981, -0.0172587372, 0.0869235843, 0.0690155625, -0.2333488315, 0.1590258628, 0.0607066266, -0.2756714821, -0.4578993320, -0.4236936867, 0.0310413204, -0.0429501459, 0.3972284496, 0.2624287903, 0.0856160969, -0.0452610999, 0.0391274020, -0.0963943750, -0.0923970789, 0.0412305929, -0.5255568624, 0.5256743431, 0.0750273690, -0.4787405133, -0.0315402336, -0.1234990284, 0.1685901880, -4.0500373840, 0.0840025470, -0.1611475945, -0.2471031398, -0.0298259892, -0.1138850451, -0.1717314720, 0.0040290803, 0.1420792043, 0.0071173632, -0.0675200373, 0.0335474163, 0.0396266170, -0.1016210616, 0.0152458884, -0.0999218300, 0.0224451702, -0.1211939529, 0.1183066815, -0.0268431436, -0.2078412771, 0.0285707172, 0.1109809801, -0.0316207074, 0.2020683885, -0.0447393917, 0.1175150201, -0.0464396290, -0.0134219956, -0.0952307582, -0.0654345080, 0.0707986280, 0.0870629475, -0.0700151324, 0.0664782599, -0.0732567087, 0.0475828946, -0.1861088872, -0.0934096500, -0.0440031253, -0.0763943568, 0.0583674759, 0.0128978956, -0.0032525272, 0.0557979606, -0.0574592985, -0.0900546461, 0.4767001271, -0.0351774208, 0.0196102355, -0.0405875966, 0.0547361970, 0.0247067697, 0.1182027236, -0.0309467409, 0.0942706764, -0.0178097598, -0.0498912893, 0.0113560529, 0.0319787897, -0.0046385298, 0.2414989024, -0.1046445370, -0.0361050405, -0.0208816621, -0.0056611542, -0.1064211354, 0.0775539130, -0.1584059447, 0.1632530987, -0.1204112992, -0.0652186051, -0.0096905883, 0.0976634622, 0.0664785579, -0.0751899555, -0.0039536059, -0.0616699383, -0.0241793208, -0.0389602892, 0.0788416341, 0.0712990612, 0.0470331162, -0.0376612097, -0.1514200270, -0.1447839588, -0.1000305042, -0.1060054302, -0.0960585028, -0.0497080758, -0.0343775749, 0.0354691669, 0.0069249040, -0.0599628352, -0.1345712990, -0.0516186617, -0.0406731516, -0.0483998097, -0.0762746856, -0.0417995825, -0.0248879883, 0.0412174761, 0.0726639777, 0.0972039551, -0.0338329226, 0.1155452579, 0.0425481275, 0.0520446710, 0.1007408649, 0.0307124853, 0.0014298591, 0.1030928493, 0.1426581740, 0.1169102937, -0.0654437169, 0.0491182543, 0.0086583840, 0.0216742940, 0.0677407682, -0.0250804760, 0.0631712675, -0.0684573948, -0.0062443274, -0.0450597443, -0.2194149494, -0.0992156565, -0.3115410805, -0.0010190507, 0.0082870126, 0.0222003758, -0.0883796960, -0.0478299409, -0.0135088218, 0.0162319485, -0.1645195186, -0.1311711818, 0.0190120414, 0.0917755514, 0.1599794924, 0.0046450691, 0.0737716109, -0.0782838240, 0.0351730585, 0.0474036559, -0.0521612726, -0.1919164956, 0.0638109669, -0.1269539148, 0.0277012996, -0.1201696917, 0.0483929515, 0.0064927936, 0.0180057827, -0.0542744361, 0.0534087904, -0.1654885709, 0.0090523958, 0.1232962310, 0.0523346886, -0.1660777628, 0.0188702494, -0.0327703655, -0.0065762294, -0.0108326692, -0.2093810588, -0.1571921259, -0.0879122317, 0.0569514260, -0.0552268922, 0.0582571439, 0.0355995037, -0.0501093231, 0.2248820662, 0.0422669761, -0.1124091595, -0.0410462655, -0.0698572770, 0.0046147662, 0.2053546011, 0.0732340217, 0.1280925870, -0.0088419225, -0.0424825214, -0.0245310012, -0.1725719273, 0.0401663110, -0.0760903955, 0.0932215080, 0.0728775412, -0.0386858396, 0.0630956665, -0.0506632961, -0.0207854211, -0.0093547702, 0.0799157396, 0.0197347347, -0.0694058612, -0.0492554493, 0.0583359413, 0.1686366796, 0.0663573816, 0.1170554161, 0.0513149612, -0.0141310990, 0.0338064805, -0.0198204387, -0.1603642106, -0.1124928519, -0.1004625335, -0.0045400420, -0.0067417212, 0.0644573644, -0.0309448484, -0.0784228146, 0.0257064626, -0.0537889898, -0.1134899482, -0.0018688869, -0.0856499448, 0.0338879488, -0.0794633329, -0.1959077120, -0.0416859053, 0.0779420212, 0.0272590704, 0.0761154667, -0.0405077413, 0.0803267881, 0.1482558399, -0.0719948560, 0.1143743396, 0.0496979132, -0.0783907026, 0.0455710255, 0.0182122886, 0.1377359927, 0.0275204368, -0.2424930781, -0.0043231393, -0.0618635565, -0.0166994240, -0.1163692400, 0.1084003821, -0.0518116429, -0.0118594971, -0.0254167877, -0.0250139460, 0.0343491659, 0.0302972700, 0.4872058332, -0.0270995144, -0.1672155112, 0.0061452561, -0.0780757964, 0.0819904357, 0.1705774665, -0.0192555878, -0.0103390124, 0.0996563733, 0.0909866393, -0.0377525985, 0.0842115358, 0.0689645261, -0.0610577241, 0.0100438613, 0.0380394049, -0.1636656821, 0.0589055605, -0.1641157717, -0.0872537345, 0.0260469913, -0.0482683033, -0.1160638556, -0.0586589575, -0.0171530657, -0.0365447141, -0.0932451710, 0.0876593515, 0.0968806967, 0.0095352912, -0.0050296211, -0.0503463186, -0.0575006083, -0.0054620337, -0.0727875531, -0.0177500341, 0.0156161077, 0.1426843256, 0.0324316733, 0.1464623809, 0.1283912063, -0.0156987887, -0.0189401302, 0.0941476151, 0.0875621364, -0.0156863611, 0.0446534343, -0.0386537276, -0.1372479498, 0.1402212977, 0.0649888441, 0.1263510883, 0.1237470359, 0.0713958144, 0.1483193040, 0.0604519509, -0.0189115908, 0.1049511284, 0.0235642008, -0.0627266988, 0.0440694019, 0.1429428458, -0.0082572103, 0.0416393876, -0.1433958411, -0.1039336920, 0.1066923141, 0.0341892876, 0.0158288088, 0.0313774347, 0.1172910109, -0.0257567484, 0.0921405852, 0.1038219780, 0.0070295497, -0.0307705794, 0.0192700922, -0.0769038945, -0.0914212093, 0.0532897711, -0.0820941254, -0.0140495300, -0.1440217495, -0.0971676186, -0.0296407640, -0.1061179042, -0.0709479153, 0.0179631710, -0.1502516419, 0.0526782721, -0.0098614488, -0.1579835415, -0.0108005600, -0.0999179482, -0.0622622669, -0.0448641554, -0.0360682495, -0.0215764325, -0.1049762219, 0.0409227200, -0.0063568354, 0.1445912719, -0.1375283003, 0.0052232877, -0.0479388982, -0.0504350439, 0.0581130460, 0.0288896561, -0.0533935204, -0.0737863630, 0.0835253075, -0.0356047675, -0.0566696897, -0.0909774229, 0.0813469961, -0.0448589772, 0.0077792518, 0.0610130727, 0.1091393158, -0.0677974895, 0.0720561147, -0.0172338672, 0.0885364637, 0.0732017606, -0.0535413884, -0.0349096954, 0.0012430297, 0.0881824568, -0.0404948071, -0.0369204096, 0.0258546174, 0.0837835073, -0.0886996761, 0.0627823025, -0.0282195192, 0.0818651095, -0.0315202363, 0.1285679191, 0.1387448162, 0.1215000525, 0.0191137064, -0.0111257946, 0.0765893459, 0.0357191525, -0.1759596616, 0.0370530933, 0.0549501441, 0.0163791273, 0.1581368148, 0.1470683962, 0.0801997557, 0.0459839106, -0.1360989064, 0.0777813345, -0.0294958055, -0.0636616424, 0.0537484884, 0.0158165842, -0.0458219908, 0.0484736450, -0.1115706638, 0.0368898101, -0.0407074541, -0.0225750934, -0.1237552837, -0.0476616398, 0.0403906219, -0.0313764811, 0.0781030059, 0.0816654414, -0.0164624825, 0.1071253791, -0.0560793579, 0.1082972437, -0.1224227399, 0.0722456127, 0.0843823254, -0.0894773081, -0.0842963383, -0.0984480008, -0.1875310689, 0.0810040236, -0.0880391523, 0.0054939925, 0.0884899050, 0.0813996345, 0.0982257873, 0.1024363339, 0.0486317202, -0.0443777777, -0.0961427391, -0.1138040721, -0.0635018498, -0.0321415961, -0.0745074302, -0.0806261823, 0.0476457663, -0.0341756679, -0.0845516920, -0.0566317737, 0.0056290538, -0.0602021590, 0.0672314167, 0.0096414825, 0.0496290773, 0.1370603144, 0.0679891706, 0.1002477109, 0.0839514732, 0.0328982435, 0.0069391713, -0.0850447416, -0.0042122728, 0.0740801618, -0.0817111209, -0.0080626952, -0.0577331036, 0.0759764165, 0.0990313068, -0.0989715755, 0.1302684844, 0.0858032107, 0.0033689095, 0.0822181031, -0.1156666949, -0.1255783886, -0.0876254141, -0.1190959960, 0.0397438817, 0.1100632250, 0.0824700072, -0.0076487367, 0.0768642575, 0.0504816212, 0.0427323543, 0.0851503834, -0.0635142326, -0.0044744909, -0.1334268451, 0.0817263648, 0.1164700091, 0.1012670100, -0.0112287896, 0.0204823799, -0.0507273674, 0.1783886403, 0.0340752229, 0.0312941037, -0.0013931654, 0.1058073044, -0.0210597645, 0.1231940985, -0.1840422451, -0.0598564297, 0.1053482592, -0.0409369804, -0.0758629367, -0.0494197831, -0.1208516657, 0.1420071572, -0.1218695343, 0.0581900664, 0.0604898371, 0.2289277315, -0.0956830755, -0.3270271420, 0.0184887554, -0.1456243098, -0.2123978883, 0.0078973593, -0.0536262393, -0.0921727866, -0.1658044308, -0.1586699337, -0.1370062977, -1.1425932646, -0.1145373061, -0.0127733480, 0.6101061702, -0.1219055653, 0.0560186505, 0.0462310277, 0.1506938189, 0.0776305795, -0.1744178385, 0.0928220823, -0.1530625969, 0.0073148301, 0.0296681710, -0.0213353131, 0.0089219809, 0.0026868689, -0.2526084483, -0.0798723251, 0.1617368907, -0.0668424591, 0.0362600647, 0.0845253244, 0.1196134016, -0.1088806465, -0.3042846620, -0.1341782063, 0.0266617239, 0.0401973166, -0.2956866622, 0.2066845745, 0.0790298358, 0.2750007212, 0.1485183239, -0.7107194066, -0.1895248890, -0.0927323699, -0.0571455918, 0.1093218774, -0.0674290136, 0.1363989711, 0.0004499622, 0.4625712633, -0.0000662855, -2.2397131920, -0.5264011025, 0.1506211460, 0.1096916273, -0.3069975674, -0.0307402164, 0.0731033310, 0.2266952395, 0.0242884066, -0.1910487264, -0.0163583606, -0.6002750993, -0.0981833339, -0.0283612777, 0.1016317308, -0.1159106195, -0.1254936159, -0.5069628954, -0.7781577110, 0.1634109020, -0.6542042494, -0.1124739051, 0.0582068413, -0.0190693941, 0.0187834390, -0.5695381165, -0.1297513247, -0.2257479429, -0.1035118178, -0.0990348309, 0.0194749627, 0.1456731558, -0.4360295832, 0.1058044285, 0.3165532649, -0.0128257042, -0.1035184190, -0.1008566394, 0.0426413566, -0.1366945654, -0.2736199796, 0.0507735908, 0.0062002423, -0.0064706118, 0.1641406566, -0.0417033471, -0.0238837544, 0.6546365619, -0.0779318810, 0.7255523801, -0.0100102657, 0.1054430231, -0.1612173766, 0.2877928317, -0.0719567537, 0.1416489035, -0.3550955057, -0.1665573269, -0.0019351395, 0.0591500029, -0.7078229785, -0.2644849420, -0.0692322850, -0.5621029139, 0.0734514967, -0.0752467811, 0.7579569817, -0.2512170076, 0.0568466112, -0.9495851398, -0.1218074039, 0.1509359628, 0.0039747744, -0.1868912131, 0.1160050705, 0.1815999746, 0.3609946072, -0.1415000558, 0.4443740547, 0.1960252970, -0.1018229052, -0.1538470238, -0.3378380835, -0.1556278467, -0.0834758356, -0.3854096532, -0.0033138213, 0.0909018740, -0.5366771817, -0.3127549589, 0.0109650083, 0.0070695528, 0.0088450452, -0.1590416133, 0.0303525347, 0.1727172136, -0.2889657617, 0.2264250964, -0.7109140754, 0.0007043970, 0.3980389237, -0.1597925425, -0.5056520104, -0.0051275077, 0.0175084267, -0.0253342260, 0.3343922198, -0.7091610432, -0.0821625739, 0.0793787763, -0.0275175460, -1.4164942503, 0.1609852463, -0.0463195965, -0.0244307630, 0.0179825854, 0.0658612773, 0.0119538745, 0.3514128327, -0.0095907599, -0.1601254940, 0.0566693135, 0.0247995351, 0.2956820130, -1.1342753172, -0.0597843565, 0.4858756959, -0.0034150172, 0.0470036529, 0.0797401741, -0.0627892390, -0.0084275566, 0.3869178593, -0.1808051765, -0.0003013455, -0.0261953492, -0.0871129036, 0.6106407642, 0.0321383923, -0.9630519748, -1.3008430004, 0.1193303317, -0.2494829148, -0.1071149707, -0.1007335782, 0.2506200075, -0.4780368507, -0.5969462991, 0.1011418700, 0.8353897333, -0.4462105632, 0.0186100826, -0.0528726615, -0.1554690897, 0.2286075652, -0.1241473928, -0.0567094944, -0.3063538969, -0.0256939307, 0.2740347385, -0.0403771251, 0.3682306707, 0.2518512905, -0.0878035799, -0.1374406219, -0.5974411964, 0.1902450323, 0.0435282402, -0.0852691010, -0.8419504166, -0.0985023528, -0.0616343468, 0.1685605794, -0.0456145257, -0.1230705157, -0.0067220707, -0.1141649559, 0.7257781029, -0.7310980558, 0.0673904270, -0.1019956768, 0.1305638254, -0.2374792248, 0.3701868057, -0.8774666190, 0.1719357371, -0.4483495653, -0.0149640879, -0.0104998872, 0.0323104374, 0.4437688291, -0.0588831417, -0.1667619646, -0.1970330179, 0.0072546145, -0.4192145467, -0.0551329069, 0.0573746078, 0.3659800589, 0.0565547757, -0.0798893049, -0.2378929704, -1.6694136858, 0.0281237960, -0.1073762998, -0.0115183191, 0.0777833760, -0.2232394665, 0.1176222563, 0.0734404624, 0.2629663944, 0.0778042674, -0.1941210777, -0.1217297912, 0.0873424411, -0.5196602941, -0.1047664434, 0.0746341795, 0.0713117421, 0.0599723384, 0.0025375909, -0.1357018948, 0.0111813797, -0.2265678942, -0.0640096143, -0.3871436417, 0.0238416493, 0.0468870066, -0.1254776865, -0.1638143510, 0.0420824811, -0.0040740771, -0.0099012265, -0.0513049215, 0.0811075568, -0.0585378148, -0.0495361723, -0.7881951928, -0.0215303358, -0.1143128350, -0.0471464507, -0.0233561564, 0.2123340666, -0.0441009998, 0.0239195358, 0.2427791804, -0.0280710254, -0.0757152066, 0.1529460698, 0.0535786152, 0.0237865970, -0.0974105895, -1.0574204922, -0.0113834152, 0.0959172547, -0.1033376232, -0.1595262438, -0.1601429284, -0.2097784877, 0.1201376617, 0.0751797408, 0.1321064085, -0.1012735814, -0.0606656894, -0.2169925272, 0.0932231694, 0.0319992788, 0.0710766986, -0.0193490740, 0.0120483451, 0.1433913857, -0.0346697867, 0.0764976442, -0.1131684706, -0.0323696844, -1.7191545963, -0.2351045758, 0.0620963499, -0.1070940793, -0.1110286191, -0.1193870604, -0.1338938773, -0.1686707735, -0.9954686165, -0.1031542569, -0.0345666148, -0.0101400316, -0.0892626494, -0.1704772711, -0.0747579932, 0.1898241043, 0.0299816951, -0.0302144289, -0.1055251360, 0.1121772751, -0.0323253572, 0.0072131334, -0.1863387972, 0.0168242566, 0.0087081753, 0.0892827511, -0.2879427969, -0.1050227806, 0.0540653132, -0.0071895900, -0.2334125340, -0.0166554432, -0.0604483522, -0.0755760148, 0.0909837708, -0.0509734154, -0.4629728198, -0.1538990289, -0.0873246491, 0.0455994755, 1.4646799564, 0.1307902038, 0.0761097595, -0.0432527363, -0.0635956600, -0.1670023054, -0.0998367071, -0.1903313398, -0.0220068414, 0.1203851178, -0.3117305338, 0.0938767642, -0.0706685707, -0.0424591899, 0.0315698534, -0.1058783978, -0.0029829482, 0.1124104634, -0.0934293792, 0.0441061333, 0.0477435775, 0.2830500007, -0.1858996153, 0.0019857301, 0.0552119315, -0.0662725866, -0.3105124533, -0.2263488322, -0.1797972620, -0.1173004583, -0.0422376208, -0.1119397804, 0.0938198566, -0.0138325114, -0.1201083362, 0.0445640460, 0.1023279428, -0.4757772386, 0.0810246766, -0.0080340737, -0.0082558552, -0.1415399462, -0.0033814269, 0.0238324590, 0.0021825493, -0.1207040846, 0.0033752606, 0.0154138440, 0.1817876846, -0.0980583727, 0.0970228910, 0.0270956047, -0.8980034590, -0.2107971013, -0.1287082583, 0.1341373026, 0.0032525803, 0.1082132086, 0.1125015169, 0.1229872108, -0.0402728617, 0.0676690117, -0.1390588433, 0.0691671073, 0.2934357226, -0.3860086799, 0.2325474024, 0.3002617955, -0.1927633435, 0.1063154861, 0.1243478954, 0.0545045100, -0.1426972002, -0.3225181401, -0.0325830802, 0.0070172525, -0.1181711555, 0.0978823304, -0.2282006145, -0.1384923905, -0.6750777364, 0.1790255755, -0.1236407086, 0.4747478962, 0.0631737188, 0.0481408834, -0.3842301965, 0.2481611222, 0.0940946415, -0.0421386734, -0.0787591860, -0.0168950036, 0.0024447134, 0.0133169275, 0.0704337656, -0.8339400291, -0.0735257939, -0.2049804777, -0.7681811452, 0.0769236982, -0.1428259313, -0.0449844934, 0.0216697007, 0.0742683485, -0.1126577854, 0.0254256185, 0.2271065563, -0.0749476105, 0.0649739131, -0.0113908388, -0.1559815407, 0.0987632647, -0.0678387508, -0.0192357134, 0.1215420663, -0.0306419432, 0.2009094059, -0.1298817843, -0.6616339087, -0.0564349294, 0.0517208986, 0.1451041996, -0.0576621629, -0.5528452992, -0.1488964260, -0.0209667925, 0.2416057736, 0.3770784140, -0.0872467607, -0.1163795963, 0.0997599363, 0.0224414989, 0.0894944668, 0.2069235891, 0.2531130016, 0.0892783105, 0.4313962162, 0.3289654851, -0.1360811293, -0.6664784551, -0.0456339195, -0.3293112516, 0.0343125463, 0.0062898095, 0.0247215368, 0.0135939969, 0.5766043067, 0.0047754948, -0.1153870523, -0.0448855683, -0.1761129797, -0.2299829423, -0.0554271787, -0.2642952502, -0.1452427655, 0.0094565852, -0.0082931276, -0.5559713244, 0.0242266674, -0.1144622415, 0.0834906399, -0.0046030455, 0.5447383523, -0.2110870481, -0.5541700721, -0.0055516814, 0.1659723222, 0.1212588251, -0.1839237064, 0.0223853104, 0.3552415371, -1.6500394344, -0.1533636749, -0.0893068761, 0.0565285385, -0.0777125806, -0.0510956869, 0.2647027373, -0.2753082216, -0.0460104682, -0.0660783425, -0.1775999069, 0.0045839949, 0.0707053691, 0.0369490720, -0.1479197890, 0.1826010942, -0.1875118166, -0.0950012133, -0.0670802370, 0.0015171574, 0.0188693777, 0.4408325553, -0.1288422048, -0.0220442899, 0.5051638484, 0.0335666761, -0.3596186638, -0.7647441626, -0.1100305095, -1.3565819263, 0.5786772966, 0.0918071195, -0.2280247062, -0.0936239213, -0.0137506304, -0.1951686591, -0.0143441400, 0.0080008944, 0.1015998721, 0.1316560954, -0.0324913897, 0.0799015388, -0.1497267485, 0.1889923215, -0.0605734065, 0.5449781418, 0.4085877538, -0.1286974698, -0.0596243665, -0.0879358351, 0.0197858270, -0.7241372466, -0.3462986946, 0.0780590624, -0.1157835498, -0.0914936811, -0.1295142174, 0.0777148604, -0.7086783051, -0.0042047668, -0.3107138574, 0.0137766693, -0.1344709694, -0.1172710359, -0.0780172125, -0.1321106851, 0.4322892725, -1.1203482151, 0.0292505827, -0.0112449173, -0.1278072447, 0.0111574493, -0.0929398611, 0.3698786795, -0.1487202644, -0.0329765379, -0.0016777841, -0.0203482434, 0.1168327779, -0.2963083982, -0.0127421720, -0.0563191995, -1.0534955263, -0.1408748627, -0.2082204670, 0.0491942316, -0.7281381488, -0.1381617039, -0.0045505730, -0.2509558499, -0.4683484435, -0.0921233520, 0.4429927170, 0.0336716920, -0.1446046531, 1.1925292015, 0.0273341779, -0.0342329405, 0.1078460068, -0.0441591255, -0.2219807506, 0.6590962410, -0.0424415916, -0.0092906058, -0.0636211187, -0.2757488489, -0.0717306510, 0.0132584618, 0.5065654516, -0.0195830446, -0.0833152607, -0.2226242274, 0.0251205228, -0.3972185850, -0.6790125966, 0.2370821834, 0.0474918261, -0.1735473573, -0.0125045255, 0.0189894903, -0.0873652920, 0.0404166393, 0.1108434945, -0.0702282041, 0.0438955985, -0.0681998581, -2.0147407055, 0.0600104704, -0.7054386735, 0.0018328825, -0.1364992708, -0.0246091299, -0.1906632930, -0.1736027300, -0.0341229625, 0.0604946390, 0.0235602856, 0.3534815013, -0.2619202435, -0.0818189383, -0.1191152036, -0.1757440120, 0.0428268276, -0.2144468129, -0.5214033723, -0.0538883992, -0.0750815272, 0.0052931472, 0.0633189380, 0.2586137950, 0.1787817031, 0.0336455181, -0.3731994629, -0.0348754264, -0.0586835891, -0.1367991269, -0.1065537184, -0.1219659448, -0.8577897549, -0.1917168945, -0.0196302850, -0.0388263799, -0.1073732376, 0.3648607135, 0.5495615005, -0.0082954708, -0.3800864816, 0.0525609665, 0.7477589250, 0.0872317925, -0.0099782031, -0.1822716892, 0.0516794585, -1.3041043282, 0.1054897010, -0.1745478809, 0.1655402780, -0.1036972553, -0.0244456474, -0.3030748367, -0.2421745360, -0.1005075797, 0.2305344045, -0.1361447722, -0.1053843275, 0.2737724483, 0.0178916436, 0.4230305254, 0.1199310198, -0.0548279472, -0.0413289629, 0.0473390892, -0.1816939414, 0.0218314938, -0.0900470167, -0.5396435261, -0.1479197592, 0.0322204120, -0.5107545853, -0.1660560220, 0.0679618791, -0.0224055555, 0.0160154365, -1.7090979815, 0.0294677932, 0.0172548853, -0.0989794284, 0.0142527074, 0.2224954516, -0.1947908252, 0.2004029751, 0.1200715601, -0.9653301239, 0.1106561348, -0.0749236271, -0.0260295179, -0.0194178857, 0.0597677231, -0.0940710604, 0.1477773041, -0.0109769255, 0.0465471856, -0.0065696808, -0.1861718595, -0.3032784760, -0.4581438601, 0.1394044757, 0.1345906854, -0.1558675021, -0.0772619098, -0.1255298853, -0.1118893474, -0.0497439913, -0.2244856060, -0.0717305169, -0.0041965898, 0.0248515233, -0.1483269036, -0.1313035786, -0.0717851147, -0.1687647402, -0.1320357174, -0.0508695841, 0.0333355740, -0.1219335645, -0.1637945026, -0.1287293583, -0.8907694817, -2.7636969090, 0.3715583682, 0.0036226015, 0.3224950433, -0.1162696108, 0.0346431173, 0.0042016939, -0.0469802134, -0.4488921463, 0.0803590268, -0.1701180935, 0.1677616984, 0.0087830024, -0.0879397467, -0.8632524610, 0.2681161761, -0.0194490142, -0.0598473288, 0.0034952832, -0.2121637017, 0.2242635041, -0.1471504122, -0.0623784028, -0.0766871199, -0.3851554394, -0.0495590344, -0.2221822292, 0.0057407338, -0.1266081780, -0.4315189719, 0.1983197182, -0.1940991133, 0.4169915915, 0.1304101050, -0.1528160125, 0.9993975163, -0.4454872012, -1.6561089754, 0.3065066636, -0.1797019690, -0.0238659922, 0.0140397595, -0.0600586273, -0.0296710059, -0.0073559564, -0.3609258831, 0.0498936065, -0.0188187174, -0.0647332370, -0.7787135839, -0.0929564610, -0.8913199902, -0.2286221683, 0.1825994700, 0.4223083258, -0.0921613201, -0.0876907855, -0.0909974873, -0.1214566380, -0.3684274554, 0.5332715511, 0.3327893913, -0.0634118915, 0.0647361353, -0.0684143603, -0.0786674917, -0.7721715569, -0.0846980587, 0.2466664165, -0.0058525498, 0.0391808338, 0.0498033650, -0.0002388562, 0.0745552182, -0.5231912732, -1.0120553970, -0.0814627856, -0.0109827137, 0.2513420880, 0.0316608027, 0.0079391859, -0.1382403523, -0.0850602239, 0.2297416776, 0.0045061857, 0.0417566672, -0.2520766258, 0.1619783491, -0.0771469772, -0.1582669914, 0.9236937165, -0.0643659383, -0.2026938349, 0.1347505599, 0.5136774778, -0.1403019279, -0.0068109590, -0.0216418467, 0.3376641870, -0.0066050887, 0.4217271805, 0.3571191728, -0.0016707216, -0.8146514297, -0.1175270081, -0.0933661312, -0.0288035795, -0.1815823168, -0.6820648909, 0.4608806968, -0.0590726286, -0.0870530903, -0.7852078676, 0.5651098490, -0.0790277272, -0.0665576383, -1.1913496256, 0.5712119341, 0.0138440216, -2.9131975174, 0.1291825324, -1.3929826021, 0.8293478489, -0.1745967418, -0.0992233157, -0.0610186458, 0.0010638371, 0.0166237839, -0.0727303773, -0.3551322222, -0.1208939180, -0.0315720476, -0.3236581683, 0.0368772633, -0.7864567637, -0.0110444482, -0.6892768741, 0.0003295287, -0.0889231265, -0.1287062466, 0.0729837790, -1.0391670465, -0.0390050858, 0.0745432302, -0.0006339427, -1.4415421486, -0.1792623401, -0.0096081113, -0.2282610089, -0.0420714840, 0.0202748030, 0.0871596262, -0.3832754493, -0.4319975078, -0.1773895770, -0.1173664331, 0.0491646603, 0.5449122190, -0.4797392488, -0.1851254702, -0.3841322660, 0.0082031535, -0.0609806068, -0.0385866761, -0.1314287782, 0.0216307119, -0.2563566864, -0.0515501760, -0.1674522758, 0.0854301825, 0.0698336884, 0.0790798143, -1.0273392200, -0.1431519091, -1.4942381382, -0.4791681468, -0.3502547145, -0.1242790967, -0.0031064262, -0.0536471270, -0.6164427996, -0.2132464200, 0.0431784689, -1.0083765984, 0.8124059439, 0.0696850643, -0.0658318549, -0.7696313262, 0.0724485219, 0.0173580982, -0.1950084269, 0.2440884560, -0.0021704407, 0.2676225305, 0.0083233556, -0.3622769117, -0.4236315191, -0.0055696191, -0.0158872008, -0.7051286697, -0.8363851309, 0.0212124083, -0.0989277959, -0.0271812379, -0.1374590993, -0.1083639711, -0.1940494627, -0.0498659834, -0.0648623481, -0.0804028958, -0.2640583217, -0.0517767705, -0.3544059992, -0.0699946955, 0.0169708077, 0.1493107527, -0.2534208000, -0.2541433573, -0.4151226580, 0.1919296384, -0.6092911959, -0.0973767415, 0.0006893387, -0.1638596356, 0.3817138970, 0.0730102509, 0.1787092239, -0.5284800529, -0.0517583229, -0.0930720046, -0.0541876368, -0.2814646065, -0.2529647946, -1.0665290356, -0.0336358771, 0.0330845788, -0.1225640923, -0.0806415007, -0.0571964756, -0.0853380114, 0.0166072622, -0.0162020270, 0.1021150872, -0.1126803830, -0.0179750267, -0.0110622160, 0.0577919260, -0.1524139494, -0.0400723964, -0.0846358985, -0.0460345522, -0.0254068282, 0.0479500629, -0.0619950108, 0.1048926637, -0.1348526627, 0.1445907950, 0.1044109836, -0.0133852018, 0.0079591954, 0.0902808383, 0.0613361448, -0.0406507663, 0.0471090637, -0.0160278901, 0.0689017698, 0.1142388061, -0.0489059500, -0.0385565013, 0.0816316083, -0.1149854138, -0.1200620905, 0.1001773626, 0.0510443375, -0.0104569914, 0.0176812690, -0.0307465680, -0.1184870973, -0.0571191944, 0.1327999383, -0.1312241852, 0.1094619259, -0.0835822076, -0.0765411630, 0.1203030944, 0.0160850566, -0.0204025507, 0.0305475220, -0.0491996184, 0.0899101496, -0.0913191587, -0.0678028613, 0.1213923246, -0.0698568448, -0.1064011008, 0.1152219772, 0.0910770595, 0.0441881306, 0.0180993062, 0.0363255553, 0.0757065713, 0.0444038399, 0.0055508381, -0.0533169955, -0.0324734710, -0.0566909127, -0.0529329106, 0.1062866077, 0.1048865914, -0.0869417861, 0.0007226736, -0.0556053706, 0.0613269210, -0.0709654465, 0.0822950602, 0.0546923392, 0.0756247416, 0.0956953317, -0.0608055964, 0.0645176694, 0.0000508521, 0.0031613479, 0.1264854968, -0.0249232035, 0.0276644994, 0.0554052629, -0.0531690978, -0.0775731802, 0.0107192323, -0.0596167780, -0.1022194475, -0.0987173319, 0.0316576511, -0.1275238991, -0.0360561758, -0.0089209015, -0.0415898375, 0.1537297517, 0.0166497491, 0.0581071116, -0.0263430551, -0.0928028300, 0.0090072611, -0.0880433917, 0.1018437445, -0.0563046299, -0.1618051529, -0.0119993091, -0.0465488546, -0.0201421436, 0.0734700188, 0.0350128710, -0.1368958652, -0.0812220126, -0.1008286923, -0.1303003579, 0.0108468933, -0.0301211458, 0.0055410638, 0.0367842279, -0.0725337118, 0.0530403964, 0.1250023097, 0.0599039569, 0.0372041352, -0.0523220450, 0.0566624627, -0.0697878972, 0.0313576385, 0.0006140821, -0.0579626337, -0.0624652393, -0.0897581354, -0.0132092247, -0.0346795656, 0.0391493924, 0.0170735475, -0.0121199824, 0.0850285441, 0.0672817156, -0.0299154595, -0.0899916589, 0.0499217436, 0.0131597947, -0.0951458216, 0.0294648074, -0.0044873101, -0.0430847891, 0.0497890823, -0.1001167893, 0.0142807327, -0.1017930508, -0.0718983486, 0.1489565670, -0.1158325374, -0.0790842324, 0.0720087960, -0.1478907764, 0.0713826343, 0.0293314140, 0.1184897944, 0.0196339618, -0.0192387477, 0.1108978689, 0.0220792051, -0.0719211772, 0.0565879829, -0.0966008306, -0.1025725678, -0.1517841369, 0.0040334836, 0.0791103095, -0.1076280028, 0.1383318752, -0.1003360599, 0.0355154611, 0.0428284742, 0.0835237280, -0.0767240301, -0.0302808769, -0.0178806111, 0.0371649042, -0.0854258612, 0.0927595571, 0.1183680892, -0.0804676488, 0.0938272625, 0.1076968461, 0.0393460765, -0.0455061570, 0.0815600604, -0.0119223986, -0.0914810076, -0.1146424040, -0.1080172956, -0.0175700728, 0.0303655360, -0.0107332002, 0.0451775976, 0.0459593050, 0.0488971174, -0.0297875572, 0.0105375210, -0.0984655991, 0.0815381035, -0.0373455212, -0.0911490992, 0.1158982143, 0.1021836922, -0.1196095645, 0.0211248901, 0.0620162040, 0.0145560158, -0.1304145753, -0.0989614651, 0.1011676565, 0.0139411865, 0.0035895526, -0.0777755827, 0.0528850891, 0.0949208662, -0.0857405141, 0.0191936363, -0.0748490691, 0.0864193663, -0.0765043572, 0.0335674137, 0.0538626388, 0.0196861960, -0.0103459395, -0.0313048176, -0.1110440642, 0.0367566235, 0.0074910121, 0.0285936967, 0.0404322594, 0.1047453135, -0.0360241681, 0.0751471743, -0.1243462265, 0.0824314356, -0.0136360358, -0.2746467590, 0.0053832699, 0.0535312034, -0.1092132255, 0.0061775260, 0.0931089222, -0.0961526856, -0.0968883783, -0.3760839701, -0.3250810206, -0.5370760560, 0.0049512982, -0.0084565748, -0.2599255145, -0.0068935938, -0.2963484824, -0.2039883882, -0.1125124097, 0.0639549941, 0.1262224168, 0.2635284364, -0.0895346999, -0.0902017355, 0.3909202218, -0.3592824936, -0.0325068720, -0.0193903241, -0.0710391924, -0.0511136167, -0.9377266765, -0.8001605868, -0.1315100640, 0.0097803408, -1.7413407564, -0.0966193452, -0.1125890613, 0.0655671731, 0.6475327611, 0.1111868024, -0.1017813534, -0.1264857054, 1.2964535952, -0.0642048642, -0.0280633904, -0.0512412302, -0.3111819327, 0.0306418464, -0.0875099674, 0.1321233809, -0.0748693720, -1.2310237885, -0.0072512482, -0.0046832920, -0.7989422679, 0.1838572025, -0.0930981785, -0.1804995090, -0.0898749307, 0.0947313383, -0.0255484655, -0.8537999392, 0.0359808765, -0.8332144618, -0.0080565689, -0.0452935137, 0.0941294208, -1.1940045357, -0.7362283468, -0.9200142026, 0.0658939332, -0.4790478051, -0.2076938301, 0.0124508077, -0.0389393419, -0.0166329630, -0.5135816932, -0.2351883501, 0.0373094976, -0.1157188565, -0.2278211713, -0.0640717074, -0.0755234584, -0.1138336137, -1.7421239614, 0.3327190876, -0.1387206763, -0.1182392240, -0.0799362734, -0.0080591291, -0.2700604498, 0.4606569409, -0.7105485201, 0.1046917513, -0.0428197421, 0.0790462866, 0.1263679713, -0.7699688673, -0.0190844238, 0.5984578133, -0.3170735538, -0.1085057259, -0.0649622306, -0.0898534358, 0.0700141191, -0.0484579988, 0.1542769670, -0.0145729501, 0.0213907585, -0.1337049752, -0.2528851330, -0.1132321060, -0.5360103250, -0.0182994269, 0.3930962086, 0.0025405362, -0.0681034252, -0.1228929460, -0.8204689026, 0.0696025491, -1.5973409414, 1.0404504538, 0.0192076229, 0.0468574055, -1.0925947428, -0.8302288055, 0.1274412721, -0.1527766585, 0.2233399153, -0.2692876458, -0.0851997137, -1.3296802044, -0.1837381870, -0.0780517757, -0.5675063729, 0.0439810082, 0.0503126867, -0.0508480631, -0.0889378637, -0.9576345086, -0.5207708478, 0.4630176723, 0.0552859120, -0.7623745203, 0.0502653681, -0.1758560240, -0.0404699109, -2.2563650608, -0.7382271886, -0.0670531094, 0.7453839183, -0.2893786132, 0.0104580084, -0.4368169308, 0.0034282750, -0.1100181788, 0.1209929064, -0.2379458845, 0.0647036210, -0.1730932146, -0.0067717573, -1.0173509121, -0.8904951215, 0.0562823527, 0.0416571647, -0.2470236272, -0.1775387973, 0.1204595491, -0.0011174931, 0.0416583791, -0.0678795576, -0.7601890564, -1.0569931269, 0.0570975691, -0.0764278919, 0.1218925640, 0.5255361795, -0.1510361880, -0.1037555337, -0.0538561083, -0.3352539837, -0.0584463477, 0.2850454450, -0.1724764854, -0.7949374914, 0.2699535787, -0.1330878884, -0.0227946304, 1.0681430101, -0.7083593011, -0.0502537377, -0.6204194427, 0.0356383696, -0.0843609795, 0.0425750278, -0.0274872556, 0.0528411865, -0.6107011437, -0.2632303238, 0.0617005490, -0.0095016025, -0.1745393872, 0.1061259583, 0.0599412099, -0.5171558857, -0.4282979369, -0.1269572228, -0.1466643810, -0.0569407679, -0.1214362010, -0.6235151291, -0.0374694690, 0.0554078110, -0.8995732665, -0.0072956746, -1.0355144739, -0.0557055511, -0.0487591103, -0.8820352554, -1.0900427103, 0.0831974596, 0.0440191589, -0.2359224707, -0.0191496816, -0.0279046278, 0.0467195213, -0.3343180120, 0.0177410915, -0.1159984842, 0.0790125281, 0.2795099020, 0.1229785234, -0.0103006167, -0.0588503107, 0.5271640420, 0.0701852739, -0.1622227579, -0.8197607398, -0.0850585699, -0.1038766354, 0.1082805991, -0.0574243963, -0.2812414765, -0.7865969539, 0.2418437451, 0.1662520915, -0.2053707987, -0.1689958572, -0.1429646164, -0.1816588640, 0.2422429919, -0.0453140065, -0.0500323959, 0.0130978990, -0.0116713466, -0.0655669793, -0.0324306525, 0.6802524924, 0.1385104060, -0.0070755002, -0.6808323264, 0.0623980835, -1.0995345116, -0.1851323694, -0.1501904577, -0.0128304232, 0.0412956364, -0.1590461880, -0.0681238323, -0.0911251605, -0.2839107513, 0.0644979104, 0.1935894638, 0.0581119843, -0.0729845166, -0.0021263510, 0.0999028385, -0.1204025596, -0.0430152602, 0.0295099504, 0.0792784467, 0.0358577482, 0.0502410866, 0.0554998592, -0.1536308527, -0.0213459264, -0.0100838253, -0.0826670006, -0.1410284489, -0.0720934868, -0.0207538176, 0.0461874194, -0.0513476171, -0.1359023452, 0.0759610310, 0.0946433768, 0.0273862556, 0.0676999316, -0.0709175915, -0.0008536038, -0.0870358124, -0.0170610603, -0.1345370710, -0.1539325267, 0.0614750944, 0.0290683229, 0.1735683829, 0.0293555167, -0.0066183922, -0.2460589558, 0.1776217818, -0.1042327434, -0.0889485702, -0.1207054183, 0.0960919559, 0.0339914896, 0.0032520548, 0.0331344977, -0.0871388465, 0.0149351573, -0.1040819213, -0.0075760405, 0.1448022872, 0.2150491029, -0.0077691660, -0.1263340861, 0.0397610404, -0.0744378418, -0.1335788071, -0.0764480978, -0.1263999939, 0.0544639528, -0.0177519657, -0.1105527729, 0.0182965044, 0.0827171057, -0.2433104664, -0.0402205884, -0.1128595099, 0.2081321925, 0.2435818464, -0.1554908752, -0.0969033688, -0.0410941504, -0.1103807539, -0.0497349650, 0.1187172383, -0.1298764944, 0.0118204076, -0.0137700513, 0.0970191658, -0.0637207553, -0.0443574302, 0.2314593047, 0.0663782060, 0.0672471300, 0.0537142046, -0.0380329750, 0.0826653242, 0.0076434743, -0.0113749709, 0.0920560211, -0.0544964522, -0.1490856111, 0.0780532360, 0.0882856324, -0.0552260056, -0.0141850412, 0.1715721935, 0.1056900918, 0.0910749286, 0.0544881262, 0.0885085613, -0.1347671449, -0.0191058051, -0.0348305963, 0.0311157610, 0.0064009377, -0.0796463341, -0.1444471627, -0.0627227053, -0.1111428961, 0.0932213515, -0.1220705658, -0.0009138184, 0.0251003504, -0.1066865250, 0.0700139552, -0.0472024605, -0.1436456591, -0.0455583520, -0.0596728884, -0.0187595002, 0.0378476009, -0.0105696237, 0.0875088945, -0.0302565452, -0.0693793967, 0.0728604347, -0.0893122107, -0.0168349855, 0.1108719260, 0.0466873907, 0.0108922739, 0.0784822553, 0.0296458993, -0.2247300595, -0.1354799718, -0.0189429335, -0.0487859175, -0.0536712892, 0.0470016822, -0.1335724443, 0.0363673531, -0.1221717671, -0.0500122011, 0.1234988496, -0.1494699270, -0.1394930482, -0.1190064624, 0.1311552525, 0.0564465374, 0.0529718362, -0.0117000937, 0.1037349477, 0.0080596618, 0.0015759557, 0.0252948962, -0.1139221862, 0.0676593930, -0.1229026914, -0.0258945674, 0.0089391572, -0.0284913555, 0.0186513998, 0.0556526594, -0.0143174333, -0.0800649822, -0.0862745568, -0.0678312257, -0.0664866269, 0.0177259538, 0.0319488160, 0.0136845298, -0.0726063550, -0.0100109261, -0.1326062977, -0.0410839394, -0.0250048488, 0.0148193454, -0.0385257639, 0.0251069255, -0.1235912368, -0.0135382134, -0.0138092050, 0.1069646403, -0.0793218613, -0.0208692215, 0.1104796380, 0.0673892871, 0.0950826779, 0.0278401449, 0.0876052827, 0.1536318362, 0.0110981073, -0.0490112640, -0.0873703882, -0.0202131551, 0.1426073015, 0.0239162929, 0.0390053093, -0.0816076174, 0.0190996304, -0.0664969236, 0.1691663861, 0.0327561498, -0.1124334410, -0.0201440658, -0.0278765038, 0.0786840990, -0.1045312881, 0.0021719646, -0.1689150780, 0.0544298068, 0.0034819308, 0.0759617239, 0.0739751384, 0.0618260317, -0.0269656628, 0.0104062585, 0.0513377413, 0.0112210559, 0.0569494590, -0.1719935238, -0.1093341261, 0.0025549424, 0.0752788782, 0.2301847786, 0.0382993110, 0.1490294486, -0.0514017269, -0.0167496987, 0.0369462222, 0.0806506574, 0.0152107701, -0.0203408338, -0.0013968471, 0.0465133861, 0.0672465488, 0.0078930603, -0.0435265675, -0.0105141187, 0.0353776775, 0.2528008819, 0.0313537717, 0.0538563989, 0.1001728401, -0.0809257105, -0.0659098998, 0.2690750062, -0.0348144732, -0.8122116327, -0.1082700565, 0.2017469704, -0.1549716741, -0.0981402174, 0.6805267930, -0.0057723909, -1.1000500917, 0.0221454967, -0.0545069128, -0.0504757650, -0.0335319452, -0.4314001799, -0.0546703190, 0.0180076864, 0.1916604191, -0.0583214201, -0.0098029645, -0.1016120091, 0.2733034194, -0.0244653486, -0.8140730262, -0.2902236879, -0.6384522319, -0.0124492822, 0.3786641061, -0.0895820260, 0.0063321665, -0.0552504808, -1.3168120384, -0.5005159974, -0.1412089169, -0.0071859281, -1.0210722685, -0.1003674865, 0.2205380946, 0.1352728754, -1.3957164288, 0.0030919886, -0.1128312796, -0.1221621335, 0.1215443909, -0.4878079593, -0.0962313414, -0.0841922462, 0.0263930894, 0.1224892214, -0.0264068916, -0.0293938052, -0.0422770865, -0.0751461685, -0.1189373881, -0.0252770595, -0.0344500355, 0.1542386562, -0.1948424578, -0.2076886892, -0.4992838204, 0.0978259146, 0.2403881252, -0.1116889045, -0.1741628200, -0.0126779713, -0.2630547285, 0.0337838754, -0.1404909790, 0.0202586371, 0.4025704265, -0.0674575269, -0.1586772949, -0.0831620991, -0.6170850992, -0.0300602242, -0.0369070172, -0.4339332283, 0.1472497135, -0.4013198018, 0.0317866355, 0.0489765033, -0.0988432243, 0.0039943182, 0.0036980142, 0.3399021029, 0.0516155362, -0.0418071635, -0.1482332647, -0.0951273963, -0.1304941922, -0.6150343418, -0.0826556981, -0.2771403491, -0.0426889285, -0.1707880795, -0.1074843779, -0.1336078197, -0.0388051048, 0.2056946456, -0.1921271086, 0.0965671614, -0.0558764115, -0.0559892282, -0.0206441507, -0.1391566694, -0.3744483292, -0.2150702477, 0.4673163295, 0.0249979608, -0.1786987036, -0.0960203335, 0.3340063989, -0.1484407336, 0.0353689604, -0.2130404711, -0.1117135510, -0.2992153168, -0.3346192241, 0.1120878011, -0.0913581997, 0.0476647839, -0.4621931016, 0.2126060128, -0.1782290936, -0.4314137995, 0.3163188398, -0.0455680080, -0.8559716940, -0.1560008228, -0.1112714708, -0.0440865085, 0.0981723368, -1.5999315977, -0.5166072249, -0.0462698005, 0.0057092849, -0.0800956190, 0.1230930761, -0.0083392560, -0.0531790219, -0.5262231827, 0.2043620050, -0.1450825632, 0.0883413702, -0.1014230922, -0.1152578369, -1.2545714378, -0.1342243403, -0.1043945774, 0.0383275822, -0.0125341462, 0.0813068002, -0.1017560214, -0.2582301795, 0.4111126959, -0.3528148830, 0.3569771051, -0.0729341581, -1.4208493233, -0.0673602819, -0.0212070942, 0.0145382937, 0.0015895367, -0.1202214211, -0.5930457711, -0.3991021812, -0.0457063094, 0.0721033663, -0.0221399199, -0.1162144244, 0.4009091556, 0.0227241479, 0.0319561511, -0.1314804405, -0.0505203307, -0.1167969108, -1.1058403254, -0.3238582909, -0.1658808142, -0.1018413976, 0.0563655272, 0.1895135939, 0.0897325128, -0.1234523430, 0.3656018674, -0.0453560837, -0.0987312421, -0.1498777419, -0.0727313384, -0.0772794485, -0.5618354082, 0.2251059413, -0.0339621007, -0.0854830146, 0.0369084179, -0.0427774377, 0.2666734755, 0.1608852446, 0.4119709432, -0.1571225822, -0.2656258941, -0.0939312950, -0.0260907821, -0.3224942684, -1.7073732615, -0.3690088093, -0.2653155923, 0.1910205781, -0.4247604012, -0.0730915964, 0.0404924601, 0.1565408111, 0.0808587670, -0.0986712202, -0.2280813754, -0.0721364915, 0.0013160801, 0.2121387720, 0.0778435394, -0.0130384360, -0.3354654014, 0.0733145773, -0.1409137249, -0.3162731826, -1.2420899868, 0.0124424677, -0.1673405170, -0.0019933020, 0.0548961908, -0.0377707034, 0.0712111145, -0.0563929677, -0.0766882971, -0.1097050756, 0.1851097047, -0.1087144539, -0.2003295422, 0.0734486431, 0.2609152794, 0.0639863983, 0.0941811651, 0.0071098977, 0.0248867050, 0.2718991935, -3.2727186680, 0.0296560414, 0.0408868007, -0.4096633494, -0.7565240264, -0.0898633525, -0.3498993218, 0.0376330838, -0.0686305612, -0.1033821702, -0.0475036316, 0.2988826334, -0.1083290577, 0.1712554395, -0.1620331705, -0.2114248872, 0.3035933077, -0.3404422402, -0.0712551847, -0.3700416684, -0.0090304809, -0.1314989775, 0.0109544620, -0.0107818060, 0.0059795086, 0.1313790679, 0.1549651474, -0.0910358801, 0.0015121186, 0.0581219345, -0.0544509776, 0.0885483846, 0.0455178767, -0.0869639963, 0.0598000996, -0.0623414703, -0.1142205521, 0.0093784342, -0.0501600392, 0.1311651021, 0.0636015758, 0.0846581981, 0.0455111638, -0.0901175812, -0.0167101286, -0.1569617689, -0.0212496407, -0.0333505124, -0.1249551699, -0.0334749706, 0.0872079656, -0.1635092348, -0.1128293276, -0.1087857187, -0.0536913350, 0.1810193360, -0.0934262276, 0.0081635313, -0.0121995863, 0.1924760342, 0.0107764946, -0.1449076682, -0.0974203870, 0.1081418097, -0.0870336965, -0.0902164727, 0.1352259070, 0.0478325039, -0.0455677472, -0.0307290703, -0.1264584213, -0.0529559851, 0.0813287199, 0.2094906718, -0.0970743001, -0.1638051122, 0.0113449236, -0.0551314801, 0.0232710335, 0.0352081545, 0.0680974349, 0.1231761351, -0.1042144075, 0.1575195491, 0.0273891520, -0.0738647208, -0.1439784020, -0.0374620184, -0.0763615221, -0.1947456896, -0.0266651064, 0.0663538426, -0.1316782534, 0.0277901758, -0.1056497544, -0.0166393109, 0.0020521113, 0.0243868027, -0.1844064891, -0.1206277162, -0.1017475575, -0.1469598264, -0.1629646271, -0.0459678993, 0.1293168068, -0.0141998995, -0.0102622779, -0.0226836782, -0.0383928306, -0.0116104186, 0.1535770595, 0.0368301496, 0.0066306475, 0.0396678299, -0.2205180228, 0.0027671580, 0.0252652280, -0.3604938686, -0.0174205489, -0.1860596687, 0.0044032023, -0.0309502538, 0.2479793578, 0.2491864860, -0.0198225416, -0.0872609168, -0.1699073315, -0.1002662107, 0.0538958572, -0.0553701892, -0.1350041032, 0.0567169823, -0.1435073316, 0.0561873727, 0.1287099719, 0.0066374280, -0.2448400259, -0.1499750912, -0.1161208972, 0.0018126966, -0.0267615914, -0.0881322548, 0.0895930231, 0.0440163575, -0.0476977676, 0.0768948495, 0.0121800341, -0.1317431927, 0.2787038088, 0.0876906812, -0.0256468356, 0.1212744191, 0.1021651849, 0.0307904463, 0.0137766236, 0.1561524421, 0.1841924191, 0.0897640362, 0.1140753925, 0.1374138892, -0.1145035103, -0.0365728028, -0.1610801816, -0.0697560683, 0.0989085510, 0.0882980600, 0.1139684618, 0.0225820504, 0.0863683447, -0.0087952744, 0.3808339536, 0.0590546653, 0.1091284379, 0.0654843375, 0.0252370089, -0.1287006587, 0.0088134324, 0.0717089400, -0.0877235159, -0.1349785477, 0.0505926162, -0.2507899106, -0.1843350679, 0.0297401771, -0.0925728083, 0.0920686200, 0.0324792825, 0.3433929682, -0.0569962449, 0.0626235455, -0.1162629277, -0.1237368509, -0.0249221344, -0.0179182030, 0.2354642004, 0.0102382880, 0.1416697502, 0.0140993157, 0.0072308835, 0.0584292226, -0.1009562686, -0.1660570949, -0.0219964273, -0.1580437571, -0.0948326960, 0.0497609712, 0.0840898082, -0.0615589507, -0.0753630698, -0.0542951599, 0.0710552335, 0.1030188575, -0.1163212955, -0.0553500913, -0.1033046991, -0.1700456142, 0.0020456687, 0.0505201332, 0.0115116583, 0.1290099919, -0.0084365746, -0.1112852693, 0.0291214194, 0.0339368097, -0.0251372233, -0.0542055108, -0.0483536646, 0.1082177907, 0.0262351166, 0.0449491255, -0.0651496872, 0.0162818227, -0.1109925136, -0.1283933818, -0.1242425740, 0.1437761635, -0.0177893844, 0.0757665858, 0.0972154066, -0.2947935462, -0.1320194453, 0.1647721380, -0.1154645905, -0.0131386966, -0.0381576866, 0.0403465033, -0.0643707737, -0.1119413972, -0.2162644267, 0.0454554707, -0.0065770685, 0.0152941309, -0.2016077489, 0.0118409907, -0.0604392104, 0.0798753202, -0.2523835301, 0.0233180244, 0.0417608209, 0.0264257733, 0.1012456864, -0.1481406689, 0.0054162429, 0.2134480029, 0.0383528322, -0.0843606889, 0.0318218097, -0.0490898862, -0.0613235123, -0.0107776215, -0.4371531606, -0.0740321055, -0.2891367674, -0.1371327341, -0.0708232075, -0.3005162179, 0.0016174051, 0.3783669472, 0.0891238451, 0.0089811813, -0.1655016094, 0.0021596549, -0.6555669308, 0.0366202481, -0.1300048679, -0.2030662149, 0.8579894900, -0.0138638038, -0.0934915543, -0.0847009644, -0.0987954736, 0.3681966364, -0.3630724549, 0.1101065725, -0.0053083771, 0.0472806804, -0.0370893441, -0.1540785730, 0.0991657972, -0.3905727565, -0.1803873479, -0.5742787719, 0.0475975648, 0.3325210512, -0.0316817351, -0.5353031158, -0.1218043417, 0.1183604151, -0.0496279784, 0.0838391706, -0.1070625633, -0.1662387103, -0.5756098032, 0.0215427373, 0.1011413559, 0.1331153959, 0.1504129171, -0.0922463164, 0.1040631756, 0.1283725053, -0.1158551872, -1.2165536880, -0.3294981122, 0.0325094610, -0.3017465472, -0.3037723303, 0.5367196202, -0.2051409185, 0.0001351231, 0.1400501728, -0.2235336006, -0.0828972235, -0.3492317498, 0.3036309183, 0.0318500958, -0.1233323142, 0.0022223771, -0.8531438708, -0.0602937229, -0.0553704649, 0.0813154876, -0.9405353069, -0.1099340096, -0.1723553836, -0.5410606265, -0.1100266650, 0.2782714665, -0.0493270010, -0.0935893729, -0.0659184828, -0.1037183776, -0.1352615952, 0.0235936847, 0.1066238657, -0.1975472569, -0.0610377342, -0.1082029492, -0.1532769352, -0.6658195853, 0.0244613513, -0.3138400018, -0.0032509842, -0.1590748429, 0.0387963951, -0.0277932268, -0.0888487324, -0.8143402338, -0.1347814798, -0.1343785822, 0.0103656594, -0.0220436174, 0.0640678853, -0.0264508054, 0.0296558067, 0.1015575752, -1.1143633127, -0.0131498165, -0.1009997353, 0.1563647091, 0.0271645337, -0.0583010130, -0.0679336414, 0.6955910325, -0.0675948709, 0.2156189978, -1.0797173977, 0.3149051070, 0.2405247688, -0.1318254918, -0.1936966479, 0.3112531006, -0.1534366161, 0.2808827162, -0.2034191787, -0.0356809013, -1.8604806662, -0.0117703397, -0.0530372933, -0.0020748742, -0.1740015447, 0.0745716095, -0.6805208921, -0.7967492342, -0.0968856439, -0.4978596568, 0.0134532191, -0.0496828966, -0.0063304007, -0.5902333260, 0.0376222059, -0.0569039583, 0.1025715396, -0.0326011144, -0.1474653333, 0.3808664083, -0.0889400095, -0.0358272754, -0.0231326129, 0.0112359328, -0.2208360732, -0.0670145303, 0.0006911031, -1.3203871250, 0.1910444051, -0.6436302066, 0.0965366364, -0.7810075283, -0.1086076573, -0.3042235076, -0.0251868386, 0.0022251089, -0.0915874466, 0.3040756881, 0.5191652179, 0.0401600935, -0.0389896221, -0.0041650012, 0.2184876204, 0.3271807432, -0.1091501266, -0.1167979464, -0.4160484970, 0.0829259008, -0.0663327426, -0.5113752484, -0.6483863592, -0.0036654931, -0.0869435146, -0.1302211732, -0.0000515907, 0.0590441078, -0.1434298754, 0.3503773510, -0.0241156928, -0.0840078220, -0.1268765926, -0.0604893155, -0.0169313438, -0.7581394315, 0.2270356566, -0.1030063406, -0.0525457002, -0.0943166167, 0.0175798666, 0.3568436801, -0.4895776212, 0.2783838511, 0.2687098682, 0.5409217477, -0.1220743954, 0.0969689637, 0.3589961231, -0.5708245039, 0.3729127049, 0.1474187076, 0.1080932841, 0.2462185025, 0.0117722088, -0.0280304048, -0.4854307175, 0.2135056555, 0.2289445549, -0.4044590890, -0.5619806647, -0.1371716112, 0.4931429327, 0.0171513613, -0.0935928002, 0.1135995537, -0.1482023299, 0.0631406531, 0.9572561979, 0.3536034226, -0.0042499090, 0.0446872674, -0.5525364876, 0.1017275527, -0.6554530859, 0.1782747507, -0.0307936557, 0.0870268643, -0.0863958299, -0.0729662850, -1.1620404720, 0.3004101515, -0.0108196819, 0.0096831182, 0.0535739139, -1.0132966042, -0.3268988431, -1.1256656647, 0.1211942881, -2.3385288715, -0.0941348374, -0.1019816920, -0.0746406019, -0.3100813925, -0.0071888887, 0.6736704707, -0.4276974201, -0.0473510623, -0.1531114429, -0.0697817877, -0.9266266823, 0.1711170375, 0.7768815756, -0.2858392596, 0.3456257880, -0.3342221677, 0.3420356810, 0.0332982540, -1.5389662981, 0.0100608515, -0.1654969901, -0.1643699110, -0.0552093200, -0.0454228334, -0.0337183885, -0.8044017553, 0.0658078492, -0.1724852622, -0.8850412369, -0.1902379841, -0.0450511351, -0.0627088323, -0.0945723653, -0.0022424029, -0.1065107062, -0.7294523120, -0.3704034686, -0.0186148621, -0.3930336833, -0.0726304650, -0.0654811785, 0.0456952229, 0.1168241501, 0.3506805301, -0.2394839227, 0.1511349082, 0.6943912506, -0.1114038303, 0.0741730779, 0.6170539260, -0.7267918587, 0.1528998315, -0.0602002554, -0.1697689891, 0.0641664565, 0.3640605211, 0.0967893973, 0.4540029764, -1.1345404387, -0.1147235408, -0.2105126232, -0.1119447872, 0.1005437300, 0.0430275500, -0.1184453815, 0.9056945443, -0.0525271185, 0.4247806370, -0.0574480407, -2.0834517479, -0.1560534090, 0.2873543501, -0.1143721342, -0.1557960510, 0.1027143970, -0.7423985600, -2.9821612835, 0.0134737650, -0.1176812649, 0.0047655841, -0.1626964062, -0.0698646531, 0.4446129501, 0.1543627232, -0.2242745757, 0.0676164925, -0.3053826690, -0.2168867439, -2.0063717365, -2.1953501701, -0.1555068493, -0.0757375360, -0.2512835264, 0.1178441644, -1.2265814543, -0.6408218741, 0.0959631726, -0.0608885996, -0.0538484901, 0.0196284652, 0.2836401761, -0.3407055140, -0.1714889854, -0.4007635415, -0.0346268378, 0.0061649960, 0.0443400145, -0.1709278673, 0.1213584840, -0.9592843652, -1.0880389214, -0.1362091005, 0.0489350371, -0.2395390123, -0.0731585473, -0.0943586081, -1.8629028797, -0.0495459624, 0.5665059686, -0.0095750876, -0.0079420675, 0.0629307777, 0.5662948489, -0.1263946891, -0.9306217432, -1.3388714790, 0.0723197609, -0.1980095208, -0.3622959554, -1.4634128809, 0.1512359679, -0.1519669443, -1.9602656364, -0.2080272287, 0.0605181754, 0.0905034095, 0.1802215576, -0.4071441591, -0.4044250250, -0.1193545088, -0.0681400970, -0.1064882502, -0.3245803714, -0.0320731029, 0.5653511882, -0.2488197833, -0.2611893117, -0.1457764804, -0.1706099212, -0.0808461159, 0.0164043400, -0.0864449590, -0.2559173107, -0.0048592747, 0.3877571225, -0.2595433891, -0.0268428084, -0.0496226251, -0.2291643173, -0.0850466415, -0.0441326126, -0.0005090935, -0.0857094601, 0.2019051611, 0.0095169358, -0.3783726692, -0.2067137212, -0.5092843175, -0.1640363783, -0.1144569069, 0.0445136614, -0.3445871770, -0.0328984037, 0.0017749667, -0.0754147172, 0.8423796892, -1.2316232920, 0.0922695324, 0.1074414551, -0.0186782517, 0.6566600800, -0.2100294232, 0.0268557016, -0.2247085273, 0.0652706474, 0.0957372114, -0.8695906997, -0.2388840467, 0.1090267971, -0.0201771762, -0.1163188741, 0.0326549001, -1.3849990368, -1.8441239595, -0.0182220228, -1.2416507006, 0.0662747622, 0.1248944700, -0.0742042586, 0.0852725506, -0.1167405248, -0.6885448098, -0.2165660709, -0.0671375096, -0.1023699567, 0.0206366796, -0.2797996104, -0.9435511827, -0.5237743258, -0.8019027114, -0.0640695766, 0.1457302421, -0.0184442066, -0.1242122054, -0.0015831455, -0.3476454914, 0.0252556577, 0.9772489667, 0.0936866179, -1.6069219112, -0.0037977677, -0.1131163463, 0.6898390651, -0.8891739249, -0.0227189790, -0.0119910566, 0.3857705295, -0.1123623550, -0.3999737501, -0.1563244164, -0.7400234342, 0.2957713306, -0.1237214431, -0.1086032540, 0.0994129553, 0.3823519051, -0.0563888773, -0.1869660467, -0.3312732279, -0.0085103204, -0.1821840405, 0.8007930517, 0.0942304954, -0.0391294211, -0.0077621872, -0.0458511412, -0.4275338352, -0.4457120597, -0.2321293056, 0.3161418438, 0.1392678916, -0.7989379764, -0.3669847250, -0.0693659410, -0.2534229755, 0.0184655674, 0.0243140124, -0.0765844956, -0.0090788286, 0.0066106203, -0.0454870574, 0.3263890445, -0.1924386472, -0.0787507519, -0.0517827421, -0.0868365243, -0.0575683154, -0.9799252152, -0.1562619507, -0.4127343595, 0.0617928021, 0.0723903403, -0.0582739748, -0.0433195531, -0.3117606044, -0.0141924592, -0.3813044429, -0.0306883212, 0.0903409645, -0.0057104607, 0.0271919444, 0.2231907398, -0.1056756899, 0.0005273011, -0.8447572589, -0.5951862931, 0.0137511659, 0.0331523344, -0.1035506725, -0.0383444466, 0.2548997402, 0.2737659216, -1.1729558706, -0.0010779389, 0.2070236653, -0.1219372377, -0.1427115500, 0.0536258109, -0.0489171147, -1.0716321468, -0.2843334675, 0.0162993483, 0.1660235226, -0.0049850028, -0.1361261606, -0.1205224097, -0.4198378325, -0.1063403860, -0.0884555131, -0.1382322460, -0.1068465263, -0.3494417667, 0.0467807464, -0.0547801591, 0.5876804590, -0.7285851240, -0.0352347307, -0.0631541684, -0.1966991872, 0.0271554869, -2.0746455193, -0.6832584143, -0.0501874126, 0.3898346424, 0.0118038571, -0.7756953835, -0.5343303680, 0.2750361562, -0.7296953797, 0.2103553414, 0.1190628335, 0.2920769751, -0.3828003407, -0.0255139172, -0.0256249905, -0.0156627931, 0.0966715515, 0.1332205385, 0.0776963383, -0.0355598256, 0.1984565407, 0.0266441610, -1.5421776772, -0.2549515069, -0.0796112493, -0.6848543286, -0.0522738248, -0.0329822265, 0.0569402464, -0.1129055992, -1.0954664946, -0.8791689873, -0.2570974231, -0.3866097927, 0.0212030634, -0.0889338702, -0.0478066765, -0.0785565749, 0.0187974721, -0.6299781799, 0.1132061407, 0.0437257513, -0.1181701869, -0.1162724048, -0.0838083625, 0.5000890493, 0.1568634659, 0.0426348671, 0.0373104624, -0.1241377667, 0.0781193823, 0.1019520685, 0.5852666497, 0.0281589814, -2.3507530689, -0.0354219079, -0.1096791103, -0.1765104830, 0.2193984836, 0.0663666055, 0.0822351575, -0.4234097898, -0.1078490242, -0.0532242581, -1.0202553272, -0.1734705716, -0.0745547712, -0.1056986302, 0.6853927374, 0.4451861680, -0.1506309509, -0.7084051371, 0.2741374373, -0.0300886817, 0.5803164244, -0.1954573244, 0.0313910432, -0.0543696396, 0.2153727412, -0.7543987036, 0.0131437303, -0.2853916287, 0.0417779535, 0.2208870947, 0.2808984816, 0.0387706570, -0.0158881564, -1.3552834988, 0.1719599366, -0.0037113144, 0.2338241339, 0.0030469780, -1.1062862873, 0.3552874327, -0.0598638654, 0.0937080681, 0.0704545006, 0.0378236845, 0.0068374854, -0.0007753056, -0.6888444424, -0.9486477971, -0.8492683172, -0.3053641915, 0.0979536697, -0.1219790578, 0.0529100038, -0.8826529384, 0.0072144587, -0.0313088596, 0.0471652523, 0.2803848982, -0.2361761928, -0.0153892059, 0.0086188884, 0.0311235711, 0.6933134794, -0.0704390779, 0.0376139358, 0.0967781395, -0.2785357833, -0.0111467261, -1.2307755947, 0.1686464399, 0.2713186741, 0.0507984124, -0.0282085016, 0.0794768408, -0.4441443384, 0.0938227326, 0.1228698790, 0.0841061175, -0.0430345647, 0.0288895089, -0.1317485422, 0.1464632303, 0.0954448506, -0.0338250026, -0.0945849866, -0.0694765523, 0.0260273516, -0.0444548875, 0.0154508092, 0.0689218491, -0.8854027390, 0.1995654702, -0.3011267185, -1.0437901020, -0.0583771579, 0.0387800224, 0.8635904193, -0.5146857500, -0.1778766960, -0.0319522321, -0.0130664585, -0.0875757560, -0.0904528871, -0.0306361150, -1.2138491869, -0.2099822611, 0.0361272581, 0.3234485686, -0.7844322920, 0.0147608323, -0.2829190195, -0.0259738453, -0.0517169870, -0.1914689392, -0.0795289502, 0.0513552837, -0.6171759367, 0.1908889562, 0.0508708581, -0.2107490003, 0.0938280448, -0.1233455464, 0.0031325405, -0.5381569266, 0.0593011118, -0.0178795010, -0.1614160687, -0.1989454031, 0.0839169770, -0.1688900739, -0.0636769980, -0.1657212526, -0.2660719752, -0.1594531983, 0.0324444510, -0.2552441359, 0.1046357453, 0.1079618782, -0.0551720783, 0.0263001565, -0.1430990547, -0.4613894820, 0.0505804159, -0.0004310486, -0.1485799402, 0.0454154611, 0.2282810509, -0.0223577321, 0.1857189536, -0.1171222180, 0.2389741093, 0.0877062157, 0.1181511730, -0.0678099915, -0.1690024734, -0.0643703640, -0.0244762450, -0.0752547383, 0.2204699516, -0.1175791249, 0.0956039354, 0.0569985472, -0.1754820496, -0.0303534158, -0.0007525820, -0.0009588872, -0.0465045236, 0.0637286901, -0.0223745238, -0.0470817946, -0.0516824685, 0.0138212359, -0.0032868877, -0.0545049831, 0.0830725580, -0.0270892214, 0.0205212981, 0.0575784817, 0.0007754733, -0.0551529638, -0.0257710125, -0.0353419334, -0.1148408279, 0.0278480295, 0.0027626271, 0.0250139143, 0.0297984090, -0.0446551889, 0.0050538685, -0.1306527853, 0.0066632614, -0.0772315487, 0.0774336234, 0.1179852858, 0.0613942146, -0.2162870616, 0.0167874191, -0.0095483493, -0.0950979590, -0.1281896830, 0.0558099709, 0.0356624760, 0.0273223333, -0.0220843162, -0.1387230456, -0.0289357807, -0.1686338633, 0.0031832969, -0.0136728063, 0.0707237571, -0.1072915867, 0.0939199105, 0.1214853302, -0.0367310904, 0.1346914172, 0.0369552374, -0.1174218357, 0.1464054286, -0.0429584011, -0.1043089256, 0.0289020222, -0.0206122287, -0.0163548626, 0.0636333525, -0.0071131242, -0.0220169276, 0.1465234607, 0.0226855334, -0.0521448776, 0.0918666050, -0.0360132754, 0.0828151703, -0.0735322908, -0.0917124450, 0.0582628362, 0.0454399325, -0.1092133448, -0.0961290151, 0.1190899611, -0.0037303404, -0.0209740102, 0.1355146170, 0.0801898763, 0.0473271534, 0.0849677473, 0.1153015867, 0.0595403463, 0.0197284538, -0.0692153275, -0.1082672402, 0.0790111199, -0.0971212536, -0.0796944797, 0.0286567807, -0.0630091652, -0.0100313490, -0.0625548959, 0.1131750420, -0.1226003468, -0.1372594535, -0.0754079446, 0.0306792501, 0.1180234626, -0.0845629945, -0.1190250814, -0.0778120682, -0.0007705823, -0.0158892218, -0.0958106071, -0.0107181408, 0.1116849780, -0.1162842065, 0.0419147722, -0.0784498304, -0.0911273733, 0.0504724868, 0.0074497964, 0.0725429133, 0.1003909931, 0.0543562919, -0.0033249557, -0.0581286252, 0.0107480129, -0.0361527540, -0.0216253884, -0.1158434823, -0.0026145107, 0.0357326344, -0.0262924731, -0.0404606275, 0.0931045860, 0.0384191610, 0.1530949771, 0.0010497535, 0.0629030690, -0.0005653393, 0.0067476518, -0.0624980964, -0.0526715703, -0.1055698246, -0.0920655876, -0.0241536181, -0.1238720417, -0.3102022707, -0.1003009304, 0.0595032573, -0.0252834242, 0.1781546772, 0.0474148914, 0.0866230950, -0.0308903884, -0.1042616367, 0.0329337455, 0.0190946888, 0.0300017372, 0.0696026981, 0.0337036103, -0.0342663899, 0.3183199167, -0.0048775310, -0.0127832964, 0.1148515195, 0.0875753984, -0.0922248960, -0.1204275042, 0.0789098591, 0.1160833910, 0.1038705707, -0.0858306512, -0.0257812068, 0.0470503196, -0.1418169737, -0.0601192527, -0.1024676040, -0.0396259949, -0.0529380701, -0.0319226012, 0.1654182822, 0.0282699857, 0.0029050314, -0.0785915554, 0.0019054421, 0.0378798246, 0.0661407411, -0.0772620961, 0.0600970387, -0.1367855221, -0.0496963412, 0.0018813426, -0.0312389862, -0.0055052270, -0.0197467059, -0.0532457232, 0.0724418685, -0.0664982498, 0.1420178115, 0.0613540746, 0.0454587229, -0.0101336306, 0.1048353910, 0.2361313850, -0.1384901255, 0.0179916825, 0.1244397461, 0.0661477745, -0.0911767557, 0.0290897526, 0.1088241190, -0.0992816538, 0.0763346180, -0.0429752059, -0.0136930654, -0.0278698411, -0.0200012848, -0.0103890039, 0.0923946127, 0.0796383917, -0.0177518055, 0.0784870163, 0.0011789541, -0.0096452339, 0.0003081232, -0.0499164425, 0.0903744400, -0.0501990579, -0.0268097930, -0.1321042627, -0.4280779958, -0.0170109831, 0.1197607890, 0.0541971028, -0.0025910384, -0.1096394062, -0.0518592075, -0.1200523823, -0.1512098312, 0.0523780212, 0.0453701541, -0.1149849519, 0.0183841009, -0.0209086165, -0.1149015427, 0.1070338637, 0.0316057838, -0.0541667193, -0.2263336778, -0.0551495589, -0.1047761366, 0.1764015108, 0.1171316504, 0.1091511846, -0.1242057234, -0.0381169952, -0.0602077916, -0.0231762584, -0.0238300692, -0.0322923213, 0.1174114272, 0.0216478556, -0.0503364764, -0.0581614673, -0.0524506308, 0.0070001944, 0.0276714191, -0.0984772891, -0.0031640122, 0.0369793959, 0.0651251152, -0.0064592101, 0.1059815735, 0.1922856271, 0.0360687636, -0.0399615131, -0.0583269969, -0.0623669066, -0.0165166482, -0.0085710064, -0.0113334833, -0.0566152558, 0.0136717604, 0.1766341925, 0.0564229265, -0.0164978169, 0.0061693634, 0.1506167799, 0.0838568062, -0.0652726442, -0.0228718631, -0.1094217747, -0.1095777526, 0.0695394725, -0.3547731042, 0.1155565009, -0.0449114069, -0.1185935736, 0.1101704389, 0.0920223072, -0.0132052461, 0.0159123037, -0.0098622525, 0.0828183964, -0.0319921412, -0.0168930460, 0.0807926729, -0.0844225436, 0.0988780037, -0.0394174494, 0.0890106633, -0.0609610602, -0.2185508609, -0.0074950266, -0.0372421108, 0.0460762382, 0.0375204124, 0.0423468351, 0.0650437549, 0.0323928520, 0.0157843400, 0.0629485995, 0.1079694927, 0.0330956839, -0.1307901144, -0.1176173016, 0.0993160531, 0.0190666001, 0.0670171976, 0.0425904430, -0.0246468186, 0.1243193448, 0.0318255164, 0.0792999715, 0.0761443377, -0.0770504326, -0.0934322178, -0.0813244730, -0.0071985307, -0.0300333146, 0.0674708411, -0.0253769029, -0.0734017715, 0.1021077037, 0.0360077135, 0.0713267922, 0.0048221922, -0.0095914314, -0.0114384787, -0.0896348730, 0.0345676765, -0.0440932252, 0.0303980298, -0.0177659784, -0.0771618336, -0.0882814974, -0.0179721434, -0.0514652543, -0.0564315319, -0.0463678166, 0.0293573942, 0.0030331369, 0.2469476312, 0.1024867296, -0.1216746420, 0.0683651641, 0.0501599982, 0.1181020141, 0.0364555717, 0.1163753122, -0.1290343702, 0.0443873033, -0.1158592403, -0.0193421543, 0.0013641994, -0.0895468444, 0.0561183169, 0.0564147197, -0.0959077179, 0.1535419226, 0.0464739949, -0.0770395249, 0.0275617726, 0.0316027068, -0.0265463851, 0.1042025164, -0.1635548174, 0.1080674231, 0.0527536198, 0.0200287718, -0.1310433447, 0.0544386879, -0.0317309164, 0.0459754057, 0.1268846691, 0.0402737632, -0.0531142205, 0.1075208187, 0.0142321307, -0.0070317178, 0.1208368242, -0.0999779403, -0.1045461148, 0.0330474488, 0.0078323288, -0.1416257173, -0.1677263081, 0.0432230122, -0.0033931220, -0.0837210566, 0.0192778707, 0.1145271957, 0.0099566961, 0.1252242923, -0.0586248077, 0.0269577857, 0.0267181266, -0.1161163449, -0.0454898253, -0.1413338929, 0.1348460168, -0.1032103598, 0.0334909894, 0.0690008253, -0.0733315200, -0.1069538966, 0.1066318303, -0.0855641291, 0.0249038208, 0.0159899835, -0.2353889495, -0.0073555987, 0.1298316121, 0.0547703393, 0.0836998001, -0.0032156657, 0.0720406771, -0.1151831150, 0.0655220747, 0.0058198106, -0.0873628259, 0.0814321637, -0.0257370472, 0.0951278284, 0.0458813868, 0.0453185104, -0.0182463229, -0.0120033585, 0.0320954919, 0.0538640097, -0.0857699215, 0.1044699922, -0.0962441862, 0.0630753040, 0.0677653253, 0.0757720396, 0.0796575099, 0.0565717220, -0.0357583053, -0.0586045831, 0.1066564023, 0.0623253994, -0.0929413587, -0.1177259982, 0.1156730056, -0.0066561932, -0.0791744962, -0.0500121564, -0.1866071224, -0.1083517000, 0.0932554901, 0.0879469067, 0.0984489545, 0.1242711246, -0.0166703537, 0.1318128109, 0.1218831912, 0.0095510026, -0.0321965814, -0.0580598414, -0.1287860274, -0.2627905607, -0.0388778113, -0.0513435081, -0.1455639154, 0.0255943481, -0.0471777357, 0.0943992287, -0.0097948629, -0.0868894160, 0.0126100061, -0.0947617367, 0.2164918780, -0.1144057438, -0.0335279256, -0.1547479182, -0.1941632032, 0.0475008301, 0.1189068854, -0.1212578192, -0.0058652558, 0.0058063702, -0.0377285704, -0.2961884141, 0.0029874188, 0.0484888181, -0.0029047204, -0.1275094599, 0.1107997820, 0.0703555495, -0.0138695948, -0.0028484247, 0.0371700898, 0.0031673471, 0.0374869406, -0.1214664653, 0.1002390906, -0.1520471871, -0.0808893889, 0.0355949253, -0.0101798726, -0.1999806911, 0.1028646678, -0.0122618610, 0.0353920460, -0.1487905681, 0.0253958404, -0.0545222051, 0.0329954065, 0.1129741073, 0.0893573985, 0.0304847360, -0.1237744540, 0.0664897710, 0.1220966130, 0.0111090448, -0.1232936382, 0.0946469307, 0.0827550888, -0.0181118827, -0.0409388132, 0.1065606922, 0.0203760415, -0.0647378936, -0.1395817399, -0.0038535353, 0.0450700745, 0.0099022938, 0.1425760984, 0.0864021778, 0.0749416202, -0.0912672356, -0.1128486693, 0.1276538670, -0.0851069912, 0.0172476228, 0.0020386558, 0.0896736830, -0.1611204445, 0.0457709767, 0.0190924685, 0.1622527540, 0.0500630029, 0.0323660411, -0.0146521991, -0.0976574942, -0.0036831985, 0.0489499979, -0.0000126272, 0.0678578243, -0.0394247882, 0.0241751093, -0.0141912336, -0.1289177388, 0.0268943533, -0.0055294558, -0.0685055926, 0.0578410216, -0.0130140148, 0.0212039053, -0.2720155418, -0.2405090630, -0.0410416313, -0.1343384832, -0.0699889511, -0.0290907826, -0.0855887830, -0.0516035855, 0.0765440091, 0.1768609732, -0.0222379621, -0.0065487460, -0.0778981447, 0.1246865764, -0.1519415528, -0.0703008473, 0.3044507504, -0.1296129376, -0.0331810862, 0.0330114253, 0.0082330285, -0.1169264242, -0.0070575923, -0.0033656259, -0.0422376096, 0.0402277820, 0.1631051153, -0.0891534984, -0.1084546968, -0.0583318770, -0.1427534074, 0.0367258303, 0.0079603968, 0.0952583030, -0.0528266691, -0.1599158794, -0.0000544466, -0.0087042879, -0.1608490944, -0.1088612005, -0.1787713766, -0.0124197137, -0.3950415850, 0.0481773950, -0.0178476870, 0.0321860723, 0.0332473107, 0.0518178381, 0.0591439791, 0.0452552401, 0.0552925952, 0.0735414848, 0.1326493025, 0.0268021729, 0.0202239361, -0.0664410368, -0.1745322645, -0.0605604164, 0.0229455307, 0.0797405392, -0.0704719946, -0.0768134519, 0.0292724799, -0.0140822800, -0.1334501505, -0.2002158463, 0.0396950878, 0.0560168438, 0.0089464942, -0.1092945561, -0.2279706448, 0.0514793284, 0.1010828540, -0.0886987895, -0.0245676711, -0.0584142879, 0.0018901350, -0.1217000186, -0.0510540493, -0.1377867460, -0.2129814178, -0.1108233035, 0.0879049227, -0.0845617354, 0.0853728876, -0.0029691646, 0.0504177883, -0.1042887419, -0.2142333686, 0.0225546844, -0.0922239572, 0.1042120829, -0.0928556174, -0.3495209515, 0.0159184374, 0.0766563341, -0.1145171821, -0.1338858455, -0.0858983919, 0.0858797058, -0.0381262489, -0.1087646037, 0.0678261071, -0.0914136767, 0.1026443243, 0.0631122515, 0.1069800556, -0.0149717648, 0.0462341942, -0.0825053975, -0.0470742807, -0.0626920685, 0.0510002747, -0.1320403367, 0.1753001958, -0.0693040863, -0.0030208149, 0.0450194962, -0.0736688897, -0.0119720949, 0.0184665751, -0.0389204808, -0.0849949718, -0.0358251669, 0.0224044882, 0.0720118880, -0.1094179377, -0.0686042011, -0.0556141697, 0.2343220860, -0.0813957974, 0.1028567925, -0.0584357567, 0.0695593432, 0.0298731737, 0.1781694889, -0.1854791343, 0.0766839534, 0.0018541116, 0.0332326218, 0.0706180409, 0.0127879204, 0.0190592874, 0.1003213897, -0.0671776682, -0.0926976651, -0.0811810419, -0.0152238663, 0.2455409318, -0.0568114258, 0.1168314442, 0.0872499049, 0.1088841483, -0.0111403856, -0.1378456652, -0.0316363685, -0.0369000137, 0.0104361605, 0.1222881526, 0.0482548662, -0.3095273376, 0.0012983667, 0.0501094051, 0.0020072625, 0.0251625460, -0.0120020807, 0.0410416164, 0.0678915903, 0.1446343809, 0.0101116197, -0.0118996659, -0.0462827384, -0.0621767379, -0.0457286499, -0.0970096365, -0.0201439168, -0.0099061979, 0.1236046702, -0.1613939703, 0.2183230966, -0.1544531286, -0.0760308951, 0.3754693568, -0.0046499320, -0.5079772472, 0.0273288228, -0.0981978178, -1.4410089254, 0.0050715958, 0.0725045055, -0.0921447128, -0.0763259828, -0.2299472541, 0.0166970920, -0.0308826324, -0.1262189448, 0.0849397033, -0.2155588120, -0.0585226230, 0.0055584200, -0.0935098231, -0.1183375940, -0.1097100973, 0.4070955813, -0.1261096895, 0.2853544652, -0.0127379652, -0.0656296536, -0.0814823359, -0.0779228136, -0.1019406319, -0.1190608442, 0.1388419867, 0.0510007218, -0.2298855036, 0.0974204093, -0.1088220179, -0.2715910077, 0.1140291393, -0.0127283465, -0.0566413365, 0.0407462008, 0.0495489426, -0.0085643213, -0.3670221865, -0.0166414902, 0.0183963217, -0.0920310989, -0.2799223959, 0.0907530040, 0.0294376630, -0.0782915428, 0.0931787938, -0.0335058793, 0.1005479693, -0.1275591850, -1.3567287922, -0.0100481790, -2.5438425541, -0.0494245030, 0.0567195117, -0.3304443657, -1.1760988235, 0.0184205323, -0.4513854682, -0.1871297956, -0.0787879899, 0.0369811617, -0.0027853050, -0.3330552280, -0.0023861032, -0.0592682064, -0.0550268888, 0.1559117138, -0.1380042136, -0.4781101048, -0.0725395754, 0.1329842508, 0.4320595264, -0.0747947320, 0.0123550408, -0.0486979447, 0.0063714338, 0.1952088922, -0.5107831955, 0.3770120144, -0.0981269851, -0.1222056448, -0.0374266356, 0.0542148575, 0.2525602281, -0.0530550741, 0.1231618300, 0.0234146584, -0.1211895719, 0.0156538747, -0.1375638843, -0.0209730696, -0.7631546855, -0.0349543653, -0.1747769266, 0.0029355118, -0.0538005121, -0.0044720201, -0.2714909315, 0.1518885791, -0.1043227464, -0.4640390873, -0.0107474606, 0.0262024570, -0.0573340580, -0.0200822912, -0.1028905213, 0.1624875665, 0.5923639536, -0.0207377113, 0.1720835716, -0.2323482037, -1.8694677353, -0.0008234528, -0.0578843653, -0.5667337179, 0.2363191843, -0.0809570551, 0.3764807284, -0.1983090937, -0.0232706480, -0.3027170897, 0.0223141685, -0.1032057777, -0.0529233962, -0.1172755286, -0.3243040144, -0.9433634281, -0.3052808940, -0.1880420297, -0.5007578135, -0.0133838188, -0.0039279475, -0.1003016159, 0.5240820646, 0.4034507871, -0.0031314814, 0.3045321405, 0.0659511909, 0.0369742252, -0.0461599082, -0.0101137860, 0.0011209379, -0.0989979804, -0.0413897783, 0.0416849963, 0.0608965494, 0.0682805404, 0.4161283374, 0.3324278295, -0.1803640574, 0.0389258489, -0.4654310942, 0.0107912812, -0.0892938972, 0.0311762672, -0.1002378464, 0.0456977002, -0.3074722290, -0.0645422339, -0.0138332481, -0.1261916608, 0.0720982775, 0.2649060786, 0.0524490587, 0.0337779820, 0.1231067032, 0.0586431623, -0.1939130574, 0.2229895294, -0.0827274919, 0.3145528436, 0.0247244444, -0.2078648955, -0.0828237236, -0.2672062218, 0.3992135823, 0.0296689775, 0.1606516540, -0.0851056576, 0.0804297403, -0.1622797251, -0.1881601065, -0.0986022502, 0.1409159154, 0.0008994424, -0.1513122767, -0.1070407256, -0.0606973208, -0.2404084504, -0.7575129867, 0.3695466816, 0.2231788933, -0.0104690986, -0.2001353353, -0.1498906612, -0.0240259767, 0.0923523903, -0.3597907424, -0.2082058638, -0.0224148538, 0.2230071872, -0.3576231301, 0.0249480102, -0.0351877846, -0.3416271210, 0.1343996972, 0.0102340942, -0.0568964146, 0.0224995986, -0.0913664252, -0.1622837633, 0.0054860953, 0.0414277352, -0.0354016796, 0.0041706567, 0.0600054860, -0.0227568336, -1.3813296556, 0.0385708101, -0.0223839395, 0.1318498850, -0.0855502263, -0.1149876714, 0.1159090102, -0.0577360839, -0.1546157300, -0.0835608020, 0.1827487946, -0.4395094514, -0.0291365795, -0.1476172209, -0.0895712152, -0.0501913466, 0.0915559307, 0.2247502804, -0.0915170461, 0.2562473118, -0.3511821628, -0.1391314417, -0.0887059942, -0.0621992946, 0.3977940977, 0.0286217257, 0.3676751852, -0.5554564595, 0.0740304142, 0.2178557813, -0.0625635982, -0.3525585532, 0.2655967176, -0.3926892281, -0.0600191429, 0.1756831110, 0.0352859348, -0.0767799020, -0.0075990977, -0.1492219418, -0.0554000698, -0.0350653827, -0.0431045257, 0.0251370855, 0.0869949982, 0.0139155667, 0.0494292378, 0.1052441299, 0.0776096210, 0.0275755748, -0.1613855809, 0.0061611966, -0.0472814739, -0.1007604674, 0.0099312030, -0.0645281449, 0.0891284272, -0.0891027153, -0.0205747467, 0.2267367691, 0.0343205035, 0.1027445495, -0.0575308278, 0.0134982662, -0.0143998526, -0.0442661531, 0.0263304412, 0.0594310574, -0.0803209841, -0.0570323206, -0.0176431872, -0.1667779535, 0.0804282576, 0.0291001201, 0.0264078472, 0.0174764432, -0.1051919535, 0.0942053348, -0.0755360425, 0.0649974346, -0.1213233918, 0.0912296772, 0.1119729057, -0.1375024170, -0.0807914361, -0.0280388687, -0.0321824588, -0.1316130161, -0.0970669091, 0.0400955603, -0.1203370690, -0.0337417535, -0.1477602124, -0.0331717692, 0.0898397267, 0.0635616481, -0.0537859946, -0.0440312251, -0.0456899032, 0.0535949767, -0.1750237644, 0.0597300343, 0.0402853750, -0.0281096008, -0.0167632513, -0.0991662443, 0.0862605870, -0.0753344968, -0.0840773880, -0.0070979213, -0.0814678371, -0.0259749591, -0.0510484576, 0.1248007566, 0.0414771438, -0.0567203201, -0.1246927455, 0.0226502102, 0.1245847121, -0.0429855101, 0.0433772206, -0.0431309603, -0.0402719900, -0.0413620956, -0.0893134177, -0.0094519984, -0.0698590577, 0.0503274202, 0.0531150065, -0.1206622124, -0.0654202178, -0.0715833008, -0.0408064388, -0.0913323537, 0.0385555029, 0.0663875937, 0.0696443245, -0.1406540871, -0.0056107249, -0.0145591544, 0.0561667159, 0.0484922826, -0.0027751923, -0.0747357681, 0.0875674486, -0.0614625178, -0.1288886219, -0.1215276420, 0.0079438109, -0.0047190483, 0.1157346144, 0.0599518307, -0.1238495409, -0.0419647321, -0.0118056023, -0.0313368142, 0.0701254904, -0.0564144850, 0.0052310131, 0.0432360135, 0.1211633831, 0.0626151115, 0.1015652269, -0.1379909664, 0.0188624505, 0.0723717809, -0.0017990735, 0.0990615785, 0.0569066443, 0.0599111617, 0.0338955000, -0.1029961631, 0.0667436719, 0.1094471514, -0.0091493791, -0.0969301462, 0.1245126128, 0.0809634849, -0.0113688018, -0.0964625403, -0.0138346851, 0.0090994537, 0.0193999950, 0.0896866322, 0.0602829941, 0.0728592947, 0.0373121612, -0.0283960905, 0.0145910913, 0.0074786413, -0.1266376674, 0.0687378272, -0.1034932658, 0.0644594803, 0.0043351054, -0.0054360330, -0.0290559754, 0.0681502819, 0.0945357978, -0.0381682292, 0.0604134537, -0.0487885959, -0.0486228503, 0.1432387978, -0.1214709580, -0.0271159057, 0.0952740237, 0.0878095329, 0.0374610685, 0.0234187823, -0.0315533541, 0.0512369312, 0.0018832386, 0.0448957086, -0.1332219243, 0.0628324822, 0.0010791223, -0.0293101184, -0.0830589533, -0.0986445695, 0.0193864703, -0.0303220991, -0.0452252850, -0.0129313609, -0.0641284585, -0.0145987645, -0.0198912919, 0.0993456319, 0.0373844616, 0.0715059936, 0.0793415830, -0.0222202558, 0.0874678344, -0.0474078320, 0.0774793625, -0.0762791559, -0.1003541201, 0.0334207080, -0.0774966627, -0.0396219678, 0.1025765762, 0.0944308341, -0.0870183408, -0.0349108279, -0.0521609373, -0.0136566358, -0.0728255361, 0.0113311056, -0.0781993270, -0.0898809657, 0.0144822467, -0.0565636531, 0.1151857525, 0.0177757554, 0.1060279012, -0.1148055419, -0.0552144162, -0.0688414350, -0.0973676816, 0.0801505595, -0.0835860074, -0.0424168371, 0.1226838827, -0.0207816064, 0.0476146340, 0.0219633710, -0.0378114581, 0.0459193625, 0.1340185404, 0.0697741359, 0.0468592569, 0.0318810493, 0.0059963265, 0.0031880587, -0.1000001580, 0.0105012339, 0.0838224962, 0.1015712321, -0.0835664272, 0.0140838213, -0.0676798299, -0.0301706791, 0.0174761321, -0.0112454575, 0.0036811263, 0.0444556661, -0.1044419333, -0.0087239146, -0.1150959581, -0.0911267102, -0.1754885763, -0.0744281709, -0.5766302943, -0.0006727519, -0.0585191175, -1.1468728781, 0.0045682103, 0.1174642071, -0.0209771413, 0.0616079755, 0.1971963793, 0.0079128789, 0.3154017627, -0.1256556809, -0.2274748683, 0.8512344956, -1.0714247227, -0.0130155114, 0.0142053245, -0.0417308174, -0.1142316759, 0.6499754786, -0.3347594738, -0.0531566031, -0.0023226908, 0.6144480705, -0.2506653666, 0.0220346861, -0.0945069492, -0.0818011388, 0.2030853182, -0.2954451144, -0.0701467097, 0.0325376987, 0.0110522760, 0.3312321007, -0.5215508938, -1.0735704899, -0.2858003974, -0.0472558811, 0.0291050822, 0.0653609410, 0.3416016400, 0.0135929827, -0.3424760401, -0.0829578862, -0.0264055692, 0.0141343530, -0.0249914229, 0.0565905273, -0.0287426393, 0.8154866695, 0.6094543934, -0.1050380990, -0.2950966060, -0.3991025984, 0.3348948956, -0.0885855183, -0.3474215269, -0.5543692708, 0.8647718430, -0.1377966404, 0.1364537776, 0.3640540838, -0.1155764386, -0.0654485226, -0.0007554481, -1.1400753260, -0.0545422770, -0.1051733792, 0.0941136926, 0.3085930049, -0.0370783806, 0.1855676472, 0.0219707657, -1.6199228764, -0.0503896885, 0.0528896488, -0.0291808229, -0.1771090776, 0.0578164048, -0.1390607059, -1.4273325205, 0.4494284987, 0.0737441778, 0.0613972843, -0.0493466258, 0.0140790651, 0.2428002208, -0.1065077707, -0.1480202079, 0.0527069978, -0.1375051439, 0.0459943339, 0.1537722647, -0.0081544220, 0.9617313743, 0.7089160085, 0.0959627926, 0.0215836242, -0.1391645819, 0.0184553228, 0.0909582153, -0.5673602819, 0.0859439671, -2.9196343422, -0.0367872491, 0.0246539395, -0.3260479271, 0.2440423518, -0.0210032724, -0.1275575757, 0.3061670661, 0.0701599792, -0.4475883543, -0.2451562285, 0.4188653827, -0.0267026816, 0.0114781158, -0.1955586523, 0.0927427858, 0.1044433340, -1.2536529303, -0.2754442096, -0.0598199107, 0.5597870946, -0.1587067991, 0.0548324026, 0.0031064060, 0.2470113188, -0.1776767969, -0.8803284168, 0.1708382964, 0.0092490129, 0.6170032024, -0.2603351474, -0.0111254035, -0.0611032955, -0.7875432968, -0.3931076825, -0.1574323028, 0.3687300086, -0.1194325238, 0.0159466229, -1.0566952229, -0.5704881549, -0.0691315979, -0.0191057269, -0.0084836166, -0.2135677487, -0.0112786945, -0.9776104689, -0.2008838654, -0.3418195248, 0.4931935072, 0.0367838107, 0.1223900840, -0.0665842816, -0.1464592814, 0.0308724996, 0.0248754267, -0.0340379961, -0.5019065142, -0.2258476317, 0.0005638737, -0.1106249765, 0.0271443687, -1.2375358343, 0.1873372793, -0.0975151658, 0.1078473628, -0.3445386589, 0.0034023500, 0.3963495791, 0.5883533359, 0.4919660091, -0.1061460674, -0.0139027750, -0.0378806628, 0.2335948944, -1.0291553736, -0.0605527572, 0.1032167077, -0.1501200497, -0.1093230397, 0.0061354456, -0.1133695096, 0.0198296774, 0.4342206419, -0.4722065032, 0.0266775507, -0.0627291799, -0.0055377702, -0.6470878720, -0.2816202044, -0.1497946978, -1.1572773457, -0.3783540726, 0.1565577984, 0.0096369861, -0.0848761573, 0.4475730658, -0.6752758026, 0.5260553956, -0.4470576048, -0.4764217734, 0.0601474009, -0.1429837644, -0.0773143843, 0.0330997631, 0.2029784024, -0.1347207278, -0.2572358549, -0.4111553133, 0.0451435745, 0.3824568987, 0.1705127358, 1.1189620495, -0.1046845019, -0.0982608497, -0.0486466736, 0.0277716350, 0.0479439087, 0.0265334994, -0.1334337592, 0.2129904330, -0.1934181005, 0.0865858272, -0.4632638991, -0.0526460409, -0.0783064514, -0.0807610303, 0.2889418304, -1.8299106359, 0.5819414854, -0.1813700199, 0.0207847711, 0.0406721570, -0.6269522905, -1.1901485920, 0.0115291979, 0.0125736818, 0.5895010829, 0.0835694149, -0.0552232787, -0.0393307656, -0.3882414997, -0.0255363584, -0.0205375701, -0.7435099483, 0.0077162422, -0.0391698107, 0.0276495740, -0.5340452194, -1.1090586185, -0.4672062695};
# 20 "firmware/parameters.h" 2
# 1 "firmware/weights/b4.h" 1
# 12 "firmware/weights/b4.h"
model_default_t b4[256] = {-2.6147420406, -0.2140385658, -2.9391083717, -0.0642140284, -0.0792063177, 1.8757115602, 27.9821434021, 0.1925711632, 2.3627192974, 2.0271339417, 0.5205867290, 0.9030362964, 4.9256405830, -0.0312221292, 4.0311636925, 5.9257802963, 2.5901000500, -25.6288337708, -2.5730721951, 0.0575095229, -2.7090418339, 7.7672080994, 1.4871716499, 4.4852552414, 26.6959438324, 1.5644519329, 0.0422572307, -0.0937713310, -0.0562641844, -1.4907807112, -11.5342531204, 4.4488587379, -2.8717818260, -3.7807264328, -0.0462063290, 4.4235687256, 5.7568144798, -2.1566047668, -1.1365536451, -0.1188468561, -4.3386249542, 0.6303579807, -0.4997209609, 10.0223140717, -0.5702917576, -2.9342067242, 1.5807225704, -1.1834595203, 1.7191523314, -1.5394240618, -0.0266273599, 12.0362567902, 0.1872320622, -0.6997251511, -3.2430655956, 0.0244521648, -3.4509394169, 9.4602127075, -1.4699345827, 0.2344886512, 0.7716079354, 0.0362063684, -3.0078518391, -0.4160063863, -6.4957509041, -0.0793939680, 26.7380542755, 3.9839339256, 0.3063313365, 3.7283387184, -1.5923750401, 9.9893655777, -0.0742493272, 1.9434690475, -0.2810216844, 0.5672740340, 0.9052706361, -0.0743746161, -0.0814823732, -7.8526067734, -0.0315565355, 3.0182032585, 6.7057785988, -1.4848692417, 0.5654147267, -0.6403907537, -0.0874427930, 0.8118183613, -0.9834142327, -7.0234851837, 2.7171316147, -23.8573474884, -0.1454511285, -0.0294898599, -4.3023509979, -0.0406040661, 5.1349802017, -0.2407718003, -0.0447620749, 27.4913768768, -3.1169176102, -25.6219577789, 4.8261313438, -1.6148931980, -1.6568486691, 1.1445311308, 26.8400230408, -0.0553445332, 0.4498563707, 0.2572967112, -0.0829851180, 14.8014860153, 2.4904549122, -0.0824428275, 6.5226435661, -1.6708028316, 0.5251904130, 4.4617066383, -0.1042603925, 0.8567642570, 6.0327987671, -0.1049095914, 6.5526881218, 0.3710746765, -3.1467211246, 3.1029829979, -0.3300562203, -8.4247341156, -1.7467339039, 3.8659615517, -4.0534625053, 1.5101807117, 1.3656524420, 1.3887953758, 1.1370880604, 11.8404378891, -5.0595598221, -3.2948310375, 0.8462860584, 0.2829416692, -0.0782660842, 0.3387329876, -1.6145526171, 15.5316877365, 2.1342349052, 4.9464364052, -0.1356518865, 0.0196752027, 26.7690582275, -0.0819817483, -5.5586528778, 2.9795677662, -2.4319329262, 3.1518068314, -4.2704696655, -0.0193724167, 3.9021725655, -0.0320911109, 4.9725170135, -25.5141944885, -0.0716603845, -0.0206983574, -1.3248169422, -1.6653125286, -10.7645311356, -0.0122067258, 26.2911396027, 0.8550686836, 12.5938444138, -5.7493586540, 1.3597185612, 0.6267269850, 0.3070337772, 2.5434896946, 0.9111235142, 7.0600042343, -7.6137084961, -0.1890828460, -0.0595062710, -1.2203993797, 6.4218964577, 1.3721197844, 6.8518161774, -6.7952485085, -0.0690264851, -0.0632285550, 0.1037259251, -0.0512251668, 2.8900094032, 0.4159039259, -0.0639737397, -0.0255220253, -0.0781239197, 9.5281677246, 8.0635147095, 1.4902110100, 3.4281568527, 22.6149864197, -0.9243552685, -0.0502391793, -0.0512854680, 4.2594647408, 4.6291990280, 8.1265811920, 2.8098630905, 7.0145826340, 7.7126359940, -0.0396719053, -9.8945379257, 1.4788287878, 0.2638819516, -0.4836264253, 8.3952684402, -0.7733046412, -0.0695399120, 17.2861804962, 0.0320569612, 2.0701444149, 0.0754678547, -0.0875421017, -0.0898470581, -3.8072488308, 2.3942105770, 6.6401534081, 4.8819460869, 2.5214834213, 0.0246046558, -1.7940061092, 1.7918490171, -0.0633731931, -0.0428981893, -4.0367922783, 0.2425188720, -0.5389531255, -0.0379373021, 13.5178575516, -3.8610198498, 25.0029067993, -1.2756332159, 8.3721990585, 5.0607609749, 3.2720472813, 2.8693416119, -0.5314477682, -0.0312398262, 7.2084360123, 1.4928162098, -0.1193623468, 1.4590659142, 5.9322986603, -5.1969304085, -1.9825670719, -5.7563199997, 0.0854507014, -0.6400828958, 2.7217366695};
# 21 "firmware/parameters.h" 2
# 1 "firmware/weights/w6.h" 1
# 12 "firmware/weights/w6.h"
model_default_t w6[1024] = {-0.0016024890, 0.0000087071, 0.0433880500, 0.0012911435, -0.0137719298, -0.0010098866, 0.0119862063, -0.0035492468, -0.0006279456, -0.0016017441, 0.0450604185, -0.0022058273, 0.1165831089, 0.0496542268, -0.1626099199, -0.0106400447, -0.0582608879, 0.1158127338, -0.1082574204, -0.0547865890, 0.0028897817, 0.0010355531, -0.0586148836, 0.0022040154, 0.2293311208, -0.0087050106, -0.0185232572, -0.0005274236, 0.0116199050, -0.0045161685, 0.0537800416, -0.0063421414, 0.0477908887, 0.0033361833, -0.0080731660, 0.0051194150, 0.0220664814, 0.0098575652, 0.0033026319, -0.0171488840, -0.0098629156, 0.0056539983, 0.0042579072, -0.0627502874, 0.0227343291, -0.0168813802, -0.0043004644, -0.0290106703, 0.0013356106, 0.0016188151, 0.0489179268, 0.0003781191, -0.0706195235, -0.0124267591, -0.0684115961, 0.1098227352, 0.0350135230, 0.0079200463, -0.0272272471, -0.0015443397, -0.0027141033, -0.0014155813, 0.0304688998, -0.0028472359, 0.0008173547, 0.0025882768, -0.0615569353, -0.0101929698, -0.1397470087, -0.0018616848, 0.0198163670, -0.0085094450, 0.0012890964, 0.0152615914, 0.0312795527, 0.0168847125, 0.0621148869, 0.0033126536, -0.1241829917, 0.0253427178, 0.0204600468, 0.0271168482, -0.0260454863, -0.0681992173, 0.0018000286, -0.0001706095, -0.0718036741, -0.0033570391, 0.0014936313, -0.0059883315, 0.0867018253, 0.0079287821, 0.0067378688, 0.0031293230, -0.0618727393, -0.0069533330, 0.1932187974, -0.0131188743, -0.0285790414, 0.0137999272, 0.0011466554, -0.0027476097, 0.0453797430, 0.0041635749, -0.0859768391, -0.1170339063, -0.0181490295, -0.0035387168, -0.0724560544, -0.0325421207, 0.0088450303, 0.0881299749, -0.0927203000, 0.0018048799, -0.0352074541, -0.1606143266, -0.0012574915, -0.0001711660, 0.0420680419, 0.0027833488, -0.0149921104, 0.0055739968, -0.0708201304, 0.0098690214, 0.0414810963, 0.0418458879, -0.0634101108, -0.0197795499, -0.0478438959, -0.0258485992, 0.0034543211, -0.0003603116, -0.0012511121, 0.0014309546, 0.0429263972, -0.0106208352, -0.1057984307, 0.0656378195, -0.1074461862, 0.1305114329, -0.0323513187, 0.0207329206, -0.0152799468, 0.0091970945, 0.0025916996, -0.0059423717, 0.0033264293, 0.0312366728, 0.0006658268, -0.0020531695, 0.0344554447, 0.0048262989, -0.0026105959, 0.0687658787, -0.0362855718, -0.0125546362, -0.0966325402, 0.0468673557, -0.0284610670, 0.1121813878, 0.0086370613, 0.0109712481, 0.0204602238, -0.0309223589, -0.0203292463, -0.0006486304, -0.0465582982, -0.1226931661, 0.0011732742, -0.0008948806, 0.0528040119, -0.0020126270, -0.0178129766, -0.0006514183, 0.0236777551, -0.0033504891, 0.0094557395, -0.0100522125, -0.0223436523, 0.0072646020, -0.0012947337, -0.0018403269, 0.0438116230, 0.0001625062, 0.0019511364, 0.0026919269, -0.0884358734, -0.0035903712, 0.0009998261, -0.0311970040, -0.0559901595, 0.0401633158, 0.0807871893, -0.0027052348, -0.0436706319, 0.0150790773, -0.0340050943, 0.0348486081, -0.0066992347, -0.0102477549, -0.1036159620, -0.0797551572, -0.0787332132, -0.0543952808, 0.0020736251, 0.0089312708, 0.1061337069, -0.0020262452, -0.0015369377, -0.0007066608, 0.0412866846, -0.0049824459, -0.0296018068, -0.0206695814, 0.0174101964, -0.0215225294, -0.0036279433, -0.0018606788, 0.0428098142, 0.0022841971, 0.0055666654, 0.0283183772, -0.0719745532, 0.0604180880, -0.0000425455, -0.0032358586, 0.0499678664, -0.0048048948, 0.0040706238, -0.0061341268, 0.0855098665, -0.0010915981, 0.0007903168, -0.0010113132, 0.0061980858, -0.0422283709, 0.0002650397, -0.0022169936, 0.0637021810, -0.0012853018, 0.0027912857, -0.0046875924, -0.1094881371, 0.0052770283, -0.0412632674, -0.0437166058, -0.0119204745, -0.0066597904, 0.0008181587, 0.0042076861, -0.0151002416, -0.0216810666, -0.0068622767, 0.0045814896, -0.0163921900, -0.0303241480, -0.0028788580, 0.0121329017, 0.0047145663, -0.0004365934, 0.0900429264, -0.0071053957, 0.0278417543, -0.0671180859, 0.1055920571, 0.0067192358, -0.0161009673, 0.0021005687, 0.0046359152, 0.0033809005, 0.1066487879, -0.0027150486, 0.0324626416, -0.0188238528, -0.0433980674, 0.0071708071, 0.0248796549, 0.0268706102, -0.0064309482, 0.0002393991, 0.0025423924, -0.0300371610, -0.0233556908, 0.0382786021, 0.0051154289, 0.0032099416, -0.0904608443, 0.0072046956, 0.0825233161, 0.0035426833, -0.0264852047, -0.0761055425, 0.0091706011, -0.0046734991, -0.0625804439, 0.0152122788, -0.0011780476, 0.0093914960, -0.0630884171, -0.1279451698, 0.0009743785, -0.0003735177, -0.0561514348, 0.0037301402, 0.0040369863, -0.0009542595, -0.0829760656, -0.0041587674, 0.1043018922, 0.0779893845, -0.0218417030, 0.0111157997, 0.1452756077, -0.0625682771, -0.0748560429, 0.0378387645, -0.0183149502, 0.0305034351, -0.0179640986, 0.0143343983, 0.0797882229, 0.0912134051, 0.0400105454, -0.0927260742, 0.0025949432, 0.0016451586, -0.0529238433, -0.0012480321, 0.0020404088, 0.0002774660, -0.0871978924, 0.0038041880, -0.0025631562, 0.0008355509, 0.0444796309, -0.0000450243, -0.0160970036, 0.0134814745, -0.0340835117, 0.0317234807, -0.0222831499, -0.0418556631, -0.0575192422, -0.0345554017, 0.0061327373, -0.0571556911, 0.0472599864, 0.0016250850, -0.0050924812, -0.0125020146, -0.0131203225, 0.0254081320, 0.0029907941, 0.0033118820, -0.0930253044, -0.0009339839, 0.0258335490, 0.0093618808, 0.0029202192, -0.0127668781, 0.0001632176, 0.0006997818, -0.0458184667, 0.0048932191, -0.0720742047, 0.0053788791, 0.0033747614, -0.0246073697, -0.0633765161, -0.0074334252, -0.0568186156, 0.0379539281, -0.0998793095, 0.1335698366, -0.0597020574, -0.0981752500, 0.0267588347, 0.0172240511, 0.0538730174, -0.0674555376, -0.0978532210, 0.0738162473, -0.1030542925, 0.0039401911, 0.0001237401, -0.0027168489, 0.0738179833, -0.0041127279, 0.0064903060, -0.0001851922, 0.0390090197, -0.0126819247, -0.0070121367, -0.0290324874, 0.0001837107, 0.0315552764, 0.0100979060, -0.0504796356, 0.0032109413, -0.0073865224, 0.0165293533, -0.0141577646, 0.0220713001, 0.0077110627, -0.0609301440, -0.0048402329, 0.0097461827, -0.0117425090, 0.0418281294, 0.0605864003, 0.0016738476, -0.0070316978, 0.0006620230, 0.0026236391, -0.0491943508, -0.0176039673, -0.0423828140, -0.0266632903, -0.0395714305, 0.0059295958, 0.0014536263, -0.0016586699, 0.0574809238, -0.0035601377, 0.0301925242, 0.0701596588, -0.0029723013, -0.0080393720, -0.0961900204, -0.0385425687, -0.0749431551, -0.0762538016, 0.0182149671, -0.0169992279, 0.1070338264, 0.0514694527, -0.0009685796, -0.0010023749, 0.0417059660, 0.0014210347, -0.0190083645, 0.0223022420, 0.0005568891, 0.0228979513, 0.0036575482, 0.0050333617, -0.0056693102, -0.0386233069, 0.0029812313, -0.0018115978, -0.0706510171, 0.0065379133, 0.0576166324, 0.0119070765, -0.0431708097, -0.0065536876, 0.0290101618, -0.0058692992, 0.0602029897, -0.0433689132, -0.0004530852, 0.0004005141, -0.0399406962, 0.0120473811, 0.0005299876, -0.0004502284, 0.0657370314, -0.0029388834, 0.0034011027, -0.0194909070, -0.0039425697, -0.0113966120, -0.0236869715, -0.0312678851, 0.0052018943, -0.0600405782, 0.0001559733, -0.0012767428, -0.0342060812, 0.0001722914, -0.0008995271, 0.0022081509, 0.0576498993, -0.0085274875, -0.0792026371, 0.0329511538, -0.0009793598, -0.0426575467, 0.0037920116, -0.0028434601, 0.0702338666, -0.0062430864, -0.0002162967, 0.0030505327, -0.0633933693, -0.0054075434, -0.0702324212, 0.0184986722, -0.0170957763, -0.0912535042, 0.0024176906, 0.0029150527, 0.0606531203, -0.0078287451, 0.0093893204, 0.0020716668, -0.0141299386, 0.0243215375, -0.0223824400, 0.0025513424, 0.0266721044, 0.0320685655, 0.0043893727, -0.0223472975, 0.0097749718, -0.0188399218, -0.0418099687, -0.0369591378, 0.0171561204, -0.0656329244, -0.0053024907, -0.0026445100, -0.0700647458, 0.0029760697, -0.0011519742, -0.0023834941, 0.0598008446, 0.0026448062, -0.0012437673, 0.0013159177, 0.0619418994, -0.0003328827, -0.0287794936, 0.0049178293, -0.0047817649, -0.0106953969, 0.0018011176, -0.0029675192, 0.0417681783, -0.0043849829, 0.0019259530, 0.0003500920, 0.0565385856, -0.0076943166, -0.0086104590, 0.0310780294, -0.0621242821, 0.0136068929, 0.0312564857, 0.0181737226, -0.0305166692, -0.0275824908, -0.0023669966, -0.0045552282, -0.0489125848, 0.0135499341, -0.0023072732, 0.0007359988, 0.0437586755, 0.0014421355, -0.0386285000, -0.1471872032, -0.0368250832, -0.0669033676, 0.0009668774, -0.0007113903, 0.0418340936, -0.0006628875, 0.0753184557, -0.0285434015, 0.0000848722, -0.0678669885, 0.0281505678, 0.0005367317, 0.0448212810, 0.0112355454, 0.0026348929, 0.0020171623, -0.0802290961, 0.0103858737, 0.0383385643, 0.0031464093, 0.0053589637, 0.0387639441, -0.0638955906, -0.0939681605, -0.0167827513, 0.0381269790, 0.0134025961, -0.0146305766, 0.0206973087, 0.0358681455, 0.2201763839, 0.0064437194, -0.0253925174, 0.0116685620, 0.0155429710, 0.0307324622, 0.0438496992, -0.0999539271, 0.0259173028, 0.0225996058, -0.0303994268, -0.0316526741, 0.0190745573, 0.0034967121, 0.0510583371, -0.0349788703, 0.0011342099, -0.0006486350, -0.0545412526, 0.0073024342, 0.0022294209, 0.0038052041, -0.0566644259, -0.0038227970, -0.0011720946, 0.0021961040, -0.0633060783, 0.0000359260, 0.0428011380, -0.0176201183, -0.0679435879, -0.0037870798, -0.0010694782, 0.0038348120, -0.0637775660, -0.0049255593, -0.0178072732, -0.0205989741, -0.0326128639, -0.0256825499, 0.0053606019, -0.0029493093, -0.0567349009, 0.0033823836, -0.1011989713, -0.0059129600, 0.0132663809, -0.0082291951, 0.0375152752, -0.0471172631, -0.0439716205, 0.0008974106, 0.0123950541, 0.0189799350, -0.0851380974, 0.1145986542, -0.0119078252, 0.0022367458, 0.0901856497, -0.0005603886, 0.0010979132, -0.0022766085, -0.0814109668, 0.0168436542, -0.0803248957, -0.0002836800, 0.0322468951, 0.1087245196, -0.0477719307, 0.0408994071, -0.0915474892, -0.1053652614, 0.2033891082, 0.0029156036, -0.0307458546, -0.0213847850, 0.0007584371, 0.0000981245, 0.0445454083, -0.0020431748, 0.0048594251, 0.0033283494, -0.0246040560, -0.0457574315, -0.0124036027, 0.0183477085, 0.0146255149, -0.0332331993, -0.0410163812, -0.0119263511, -0.0290813167, -0.0283372570, -0.0013534793, -0.0048347712, -0.0940618962, 0.0033398864, 0.0519307964, -0.0535522215, -0.0348693877, -0.0136333723, -0.0006111808, 0.0003219944, 0.0607706495, 0.0010517655, -0.0020911037, 0.0023227895, -0.1247330904, 0.0090408213, 0.0046784286, -0.0041010962, -0.0480009466, -0.0158928595, 0.0157155190, 0.0035599074, -0.0800776258, 0.0103611182, -0.0574001782, -0.0190079957, -0.0037578519, 0.0200709477, 0.0774065927, -0.0998227224, -0.0582157969, -0.0990471020, 0.0009684214, -0.0024032944, 0.0547209941, -0.0114256432, -0.0026288126, -0.0002943979, -0.0532736927, -0.0005270119, 0.0232072845, -0.0751176775, 0.0136257904, 0.0063505615, 0.0025725123, -0.0018438357, -0.0478803292, 0.0207584053, -0.0075061214, 0.0592205301, -0.0006375742, 0.0504389629, -0.0060773278, -0.0191429146, -0.0233290177, 0.0335953422, 0.1203284711, -0.0077164643, -0.1036189422, 0.0405033901, 0.0006527677, -0.0590801723, -0.2179786265, 0.0247074012, -0.0552882031, -0.0709601864, 0.0234940890, -0.1004207358, -0.0020409431, -0.0028432712, -0.1077054888, 0.0146577964, 0.0060763746, -0.0024009354, -0.0066184099, 0.0079626450, -0.0264396276, -0.0078553408, -0.0359506644, 0.0101704402, 0.0925546139, -0.1123824120, -0.0427533165, 0.1245729700, -0.0063584303, -0.0221633725, -0.0656948611, 0.0383060835, 0.0002413455, 0.0031327663, -0.0607661717, -0.0202568285, 0.0138470298, 0.0029762059, -0.1018298492, -0.0132249855, -0.0004302053, -0.0007499582, 0.0364496261, 0.0025777377, 0.0065079103, 0.0009393595, -0.0770676509, 0.0048257289, 0.0157304164, 0.0048822337, -0.0326651633, -0.0154082980, -0.0019865378, -0.0008222042, 0.0478684083, -0.0000330220, -0.0005233522, 0.1059506610, 0.0402593352, -0.0225235689, -0.1367657781, 0.0098982602, 0.0531683415, -0.1039514840, 0.0009896115, -0.0076423921, 0.1060703173, 0.0116980476, 0.0082614804, -0.0098387441, 0.0820248500, 0.0093902638, 0.0017886646, 0.0037542819, -0.0763694122, -0.0030275851, -0.0009089347, 0.0014820483, -0.0476506464, 0.0008365510, 0.0052922256, -0.0045459904, 0.0664634109, 0.0031969789, -0.0002250020, 0.0037769459, -0.0928527489, -0.0057203076, 0.0056889374, 0.0695152953, -0.1126076952, -0.0078995815, -0.0493700355, 0.0111569026, -0.0250344612, 0.0280009918, -0.0029782348, -0.0016187745, 0.0733215511, -0.0211915728, 0.0019927942, -0.0002210522, 0.0254476480, -0.0029477288, 0.0056707719, -0.0397265106, -0.0041461363, 0.0355878361, 0.0353606343, -0.0161461644, 0.0730189160, -0.0435207449, 0.0022073726, -0.0022204777, 0.0266015865, 0.0065194648, 0.1316384375, -0.0270871092, -0.0674359575, -0.0074157366, 0.0038407855, 0.0021467491, -0.0031772680, -0.0675200894, 0.0037348175, 0.0124929110, 0.0685391426, -0.0064610611, -0.0031585100, 0.0007448939, -0.0575974472, -0.0019175950, 0.0412349626, -0.0067028990, 0.0050650928, 0.0001699830, -0.0469621196, 0.0801752806, 0.0403743088, -0.0645850971, -0.0257965345, 0.0049666548, -0.0314260125, -0.0654780343, -0.0014188670, 0.0021377180, -0.0667100102, 0.0099001238, -0.0006148210, -0.0000758387, 0.0520296022, 0.0049363398, 0.0528840944, 0.0006275604, 0.0996002778, 0.2529577911, 0.0492992550, 0.0166320540, 0.0012203668, 0.0260070730, -0.0121659730, 0.0075230477, 0.1041826308, -0.0127425063, 0.0487712063, 0.0524993315, -0.0252883993, -0.0328323580, -0.0007374935, 0.0007548292, 0.0269599892, -0.0029852153, 0.0024543260, 0.0004805653, -0.0741935968, 0.0161563903, 0.0238301195, 0.1015801728, 0.0379891694, -0.1078243479, 0.1832980514, -0.0573042221, -0.0265320987, 0.0287133884, 0.0338448957, -0.0412502699, 0.0245412588, 0.0491832867, -0.0069636423, 0.0296021942, 0.0133989863, -0.0353964753, -0.0015460352, 0.0020670220, -0.0660135373, 0.0010328658, 0.0004099977, -0.0018390676, 0.0500073694, -0.0027414812, -0.0514744185, 0.0252290387, -0.0203215610, -0.0381235890, 0.0007447411, -0.0014849723, 0.0430631004, -0.0051993304, 0.0417895839, -0.0040974929, 0.0036525445, 0.0204490181, -0.0023138770, -0.0015038720, 0.0315837823, 0.0026123808, 0.0028296229, 0.0027908529, -0.0866758600, 0.0114575066, -0.0044602747, 0.0020032318, -0.0455317944, 0.0278022736, 0.0008730111, 0.0007226499, 0.1562152654, -0.0304012448, 0.0002118791, -0.0026212584, 0.0700133517, 0.0010458138, 0.0145900343, 0.0611284338, -0.0182366967, 0.0031798203, 0.0739422590, 0.0658810064, -0.0379130282, -0.1389610320, -0.0071023502, -0.0035551740, 0.0275606737, 0.0294279531, -0.0020470181, -0.0051871282, 0.0578256808, 0.0045660301, -0.0238537490, -0.0108953388, 0.0230119042, 0.0356137790, -0.0011807444, -0.0020960895, 0.0668617934, 0.0012927614, 0.0437207967, -0.0146876648, -0.0814626515, 0.0257506780, 0.0126832444, 0.0297825467, 0.0205489807, -0.0340803601, 0.0012824705, -0.0021348880, 0.0154312775, -0.0049287956, -0.0277091730, 0.0603114888, -0.0315889120, 0.0222731736, 0.0020942369, -0.0030738146, -0.0676766187, -0.0084905094, -0.0001181618, -0.0015833761, -0.0442797393, 0.0039874259, 0.0013118718, -0.0009216049, -0.0644876435, 0.0097256387};
# 22 "firmware/parameters.h" 2
# 1 "firmware/weights/b6.h" 1
# 12 "firmware/weights/b6.h"
model_default_t b6[4] = {26.3865261078, 5.8518328667, -1.1607069969, -0.1069439650};
# 23 "firmware/parameters.h" 2




struct config2 : nnet::dense_config {
    static const unsigned n_in = 100;
    static const unsigned n_out = 128;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned strategy = nnet::latency;
    static const unsigned reuse_factor = 1;
    static const unsigned n_zeros = 0;
    static const unsigned n_nonzeros = 12800;
    static const unsigned multiplier_limit = ((n_in * n_out + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    static const bool store_weights_in_bram = false;
    typedef model_default_t accum_t;
    typedef model_default_t bias_t;
    typedef model_default_t weight_t;
    typedef layer2_index index_t;
    template<class data_T, class res_T, class CONFIG_T>
    using kernel = nnet::DenseLatency<data_T, res_T, CONFIG_T>;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};


struct relu_config3 : nnet::activ_config {
    static const unsigned n_in = 128;
    static const unsigned table_size = 1024;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    typedef dense_relu_table_t table_t;
};


struct config4 : nnet::dense_config {
    static const unsigned n_in = 128;
    static const unsigned n_out = 256;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned strategy = nnet::latency;
    static const unsigned reuse_factor = 1;
    static const unsigned n_zeros = 0;
    static const unsigned n_nonzeros = 32768;
    static const unsigned multiplier_limit = ((n_in * n_out + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    static const bool store_weights_in_bram = false;
    typedef model_default_t accum_t;
    typedef model_default_t bias_t;
    typedef model_default_t weight_t;
    typedef layer4_index index_t;
    template<class data_T, class res_T, class CONFIG_T>
    using kernel = nnet::DenseLatency<data_T, res_T, CONFIG_T>;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};


struct relu_config5 : nnet::activ_config {
    static const unsigned n_in = 256;
    static const unsigned table_size = 1024;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned reuse_factor = 1;
    typedef dense_1_relu_table_t table_t;
};


struct config6 : nnet::dense_config {
    static const unsigned n_in = 256;
    static const unsigned n_out = 4;
    static const unsigned io_type = nnet::io_parallel;
    static const unsigned strategy = nnet::latency;
    static const unsigned reuse_factor = 1;
    static const unsigned n_zeros = 0;
    static const unsigned n_nonzeros = 1024;
    static const unsigned multiplier_limit = ((n_in * n_out + reuse_factor - 1) / reuse_factor) - n_zeros / reuse_factor;
    static const bool store_weights_in_bram = false;
    typedef model_default_t accum_t;
    typedef model_default_t bias_t;
    typedef model_default_t weight_t;
    typedef layer6_index index_t;
    template<class data_T, class res_T, class CONFIG_T>
    using kernel = nnet::DenseLatency<data_T, res_T, CONFIG_T>;
    template<class x_T, class y_T>
    using product = nnet::product::mult<x_T, y_T>;
};
# 5 "firmware/myproject.cpp" 2


__attribute__((sdx_kernel("myproject", 0))) void myproject(
    input_t input_1[100],
    result_t layer6_out[4]
) {
#line 184 "C:/Mac/Home/Documents/PHYS476/FinalProject/Python/hls4ml_prj/build_prj.tcl"
#pragma HLSDIRECTIVE TOP name=myproject
# 10 "firmware/myproject.cpp"



#pragma HLS ARRAY_RESHAPE variable=input_1 complete dim=0
#pragma HLS ARRAY_PARTITION variable=layer6_out complete dim=0
#pragma HLS INTERFACE axis port=input_1
#pragma HLS INTERFACE axis port=layer6_out
#pragma HLS PIPELINE
# 37 "firmware/myproject.cpp"
 layer2_t layer2_out[128];
#pragma HLS ARRAY_PARTITION variable=layer2_out complete dim=0
 nnet::dense<input_t, layer2_t, config2>(input_1, layer2_out, w2, b2);

    layer3_t layer3_out[128];
#pragma HLS ARRAY_PARTITION variable=layer3_out complete dim=0
 nnet::relu<layer2_t, layer3_t, relu_config3>(layer2_out, layer3_out);

    layer4_t layer4_out[256];
#pragma HLS ARRAY_PARTITION variable=layer4_out complete dim=0
 nnet::dense<layer3_t, layer4_t, config4>(layer3_out, layer4_out, w4, b4);

    layer5_t layer5_out[256];
#pragma HLS ARRAY_PARTITION variable=layer5_out complete dim=0
 nnet::relu<layer4_t, layer5_t, relu_config5>(layer4_out, layer5_out);

    nnet::dense<layer5_t, result_t, config6>(layer5_out, layer6_out, w6, b6);

}
